{
  "contact": "კონტაქტი",
  "rules": "წესები",
  "back": "უკან",
  "level": "დონე:",
  "score": "ქულა:",
  "difficultyGuide": "სირთულეების გზამკვლევი",
  "quizLevels": {
    "level1": "დამწყები",
    "level2": "ახალბედა",
    "level3": "ბრძენი",
    "level4": "ექსპერტი",
    "level5": "ელიტარული",
    "level6": "ოსტატი",
    "leaf": "მარტივი",
    "easyDesc": "დამწყებთათვის განკუთვნილი კითხვები, შესამზადებლად.",
    "Cog": "საშუალო",
    "mediumDesc": "მოითხოვს საბაზისო ცოდნას და მსჯელობის უნარებს.",
    "Fire": "რთული",
    "hardDesc": "ექსპერტის დონe, შესაძლოა, პროფესიონალებსაც კი გაუჭირდეთ!"
  },
  "Guide": {
    "htmlHeading": "Html/CSS სახელმძღვანელო",
    "jsHeading": "ჯავასკრიპტის სახელმძღვანელო",
    "reactHeading": "რეაქტის სახელმძღვანელო",
    "randomHeading": "Random Logic სახელმძღვანელო",
    "leveling": {
      "levelingSystem": "დონეების სისტემა",
      "p": "დონეები განისაზღვრება ხატულების მიხედვით:",
      "easy": "მარტივი", "easyP": "(დამწყების დონე)",
      "medium": "საშუალო", "mediumP": "(გამოცდილთა დონე)",
      "hard": "რთული", "hardP": "(მოწინავე დონე)"
    },
    "questions": {
      "logic": "კითხვის ლოგიკა",
      "p": "კითხვის დასმის შემდეგ ერთვება ლოგიკა:",
      "explanation": " <highLight>არასწორი პასუხის</highLight> მიღების შემთხვევაში, ყოველთვის შეიძლება განმარტების ნახვა, <highLight>განმარტების ღილაკზე</highLight> დაჭერით."
    },
    "mastery": {
      "masteryLevel": "ოსტატობის დონე",
      "p": "აქ ყველაფერი ქულებზეა დამოკიდებული",
      "explanation": "შენი <highLight>ოსტატობის დონე</highLight> დამოკიდებულია <highLight>საბოლოო ქულაზე</highLight>, <radial>მაღალი ქულა</radial> გიხსნის პრესტიჟული ოსტატობის სახელწოდებებს."
    },
    "stats": {
      "aboutStats": "სტატისტიკის შესახებ",
      "p": "სტატისტიკა ქვიზის დასრულების შემდეგ გახდება ცნობილი:",
      "explanation": "სტატისტიკაში ვნახავთ ჩვენს: <radial>სიზუსტეს %</radial>, <radial>სწორ/არასწორ</radial> პასუხებს, <radial>გამოტოვებულ</radial> შეკითხვებს და ჩვენს რანკს: (არსებობს 6 დონე: <rank1>Bronze</rank1> → <rank2>Gold</rank2>)."
    },
    "Rules": {
      "rules": "ქვიზის წესები",
      "p": "თამაშის წესები შემდეგია:",
      "explanation1": "<highLight>მარცხნივ/მარჯვნივ</highLight> ისრები დაგვეხმარება გადავიდეთ <highLight>შემდეგ ან წინა</highLight> კითხვაზე, მას შემდეგ რაც ვუპასუხებთ კითხვას.",
      "explanation2": "არარსებობს <highLight>დროის შეზღუდვა</highLight>, ანუ შეგვიძლია დავფიქრდეთ და შევისწავლოთ კითხვები.",
      "explanation3": "დასაშვებია <highLight>29 საკითხის</highLight> გამოტოვება, შეგვიძლია  <highLight>1 სწორი/არასწორი</highLight> პასუხით ქვიზის დასრულება.",
      "explanation4": "ეს ქვიზის თამაში შესანიშნავია"
    }
  },
  "training":{
    "heroSection": {
      "heading": "გამოცადე შენი კოდური უნარები",
      "paragraf1": "გაიუმჯობესე შენი კოდური უნარები ინტერაქტიული ქვიზებით:",
      "paragraf2": "გამოიწვიე თავი, განიცადე პროგრესი, და დაოსტატდი ვებ პროგრამირებაში.",
      "button1": "დაიწყე ქვიზი",
      "button2": "CodeMeter-ის შესახებ",
      "Questions": "კითხვა",
      "Categories": "კატეგორია",
      "Updates":{
        "Update": "განახლებები",
        "week": "კვირეულად"
      },
      "quotes":{
        "quote1": "ცოდნა არა ნახტომებით, არამედ ყოველდღიური მტკიცე ნაბიჯებით მიიღწევა.",
        "quote2": "სწავლის ძირი მწარე არის... კენწეროში გატკბილდების. ",
        "quote3": "ყოველდღიურად სწავლა არაა მოვალეობა, არამედ იგია განვითარების ხელოვნება."
      },
      "stats":{
        "question": "კითხვა"
      },
      "categories": {
        "htmlCss": "Html/Css-ი",
        "javascript": "ჯავასკრიპტი",
        "react": "რეაქტი",
        "custom": "რანდომული"
      }

    },

    "htmlCss": {
      "core": "საბაზისო",
      "p1": "გაამყარე შენი უნარები <highlight>ფუნდამენტური HTML & CSS გამოწვევებით</highlight>. დაწყებული <em>სემანტიკური ტეგებით</em>, დასრულებული <em>რესპონსიული ლეიაუთებით</em>, ეს ქვიზი დაგეხმარება უფრო ღრმად გაანალიზო და შეისწავლო ფრონტ-ენდის თეორიული მასალა.",
      "p2": "იდეალურია <highlight>ჯუნიორ და საშუა დონის დეველოპერებისთვის</highlight>. უპასუხე <strong>30 საგულდაგულოდ შედგენილ კითხვებს</strong>, რომლებიც შეამოწმებენ შენს პრაქტიკულ ცოდნასა და გავრცელებულ შეცდომებს, ეს კითხვები გაამყარებენ შენს საფუძველს რეალური პროექტებისთვის.",
      "buttons": {
        "start":  "დაწყება",
        "info": "მეტი"
      },
      "Info": {
        "rules": "Html/Css ქვიზის წესები",
        "rule1": "მოგეცემათ 30 მნიშვნელოვანი Html/Css კითხვა.",
        "rule2": "თითოეულ კითხვაზე შეგიძლიათ აირჩიოთ მხოლოდ 1 პასუხი.",
        "rule3": "სწორი პასუხი აინთება <green>მწვანედ</green>, არასწორი - <red>წითლად</red>.",
        "rule4": "სექციაში გექნებათ: Previous, Next, Skip და Explanation ღილაკები.",
        "rule5": "პასუხის დადასტურების შემდეგ გამოჩნდება სწორი პასუხი.",
        "rule6": "დროში არ არის შეზღუდვა, შეგიძლიათ მშვიდად ისწავლოთ.",
        "rule7": "დასრულების შემდეგ მიიღებთ ქულასა და შედეგებს."
      }
    },

    "javascript": {
      "heading": "ჯავასკრიპტი",
      "intermediate": "საშუალო",
      "p1": "გახსენი <highlight>ჯავასკრიპტის ლოგიკისა და პრობლემების გადაჭრის</highlight> ძალა. ეს სექცია გამოგიწვევს შეკითხვებით რომლებიც გააუმჯობესებენ შენს დეველოპერულ აზროვნებას, რთული პირობების მართვადან დაწყებული ყოველდღიური კოდირების ნიმუშების დაუფლებით დამთავრებული.",
      "p2": "ეს ტესტი უნიკალურია თუ აპირებ უნარების გამყარებას, უპასუხე <strong>30 ინტერაქტიულ შეკითხვას</strong> ამ ქვიზში. კითხვები შექმნილია შენი მსჯელობის გასაძლიერებლად და  გავრცელებული შეცდომების გამოსავლენად, აქ ისწავლი ახალ უნარებს რაც დაგეხმარება უკეთ გაანალიზო ჯავასკრიპტის ლოგიკა.",
      "buttons": {
        "start": "დაწყება",
        "info": "მეტი"
      },
      "Info": {
        "rules": "ჯავასკრიპტ ქვიზის წესები",
        "rule1": "მოგეცემათ 30 საინტერესო კითხვა ჯავასკრიპტზე.",
        "rule2": "თითოეულ კითხვაზე შეგიძლიათ აირჩიოთ მხოლოდ 1 პასუხი.",
        "rule3": "სწორი პასუხი აინთება <green>მწვანედ</green>, არასწორი - <red>წითლად</red>.",
        "rule4": "სექციაში გექნებათ: Previous, Next, Skip და Explanation ღილაკები.",
        "rule5": "პასუხის დადასტურების შემდეგ გამოჩნდება სწორი პასუხი.",
        "rule6": "დროში არ არის შეზღუდვა, შეგიძლიათ მშვიდად ისწავლოთ.",
        "rule7": "დასრულების შემდეგ მიიღებთ ქულასა და შედეგებს."
      }
    },

    "react": {
      "heading": "რეაქტი",
      "advanced": "გაფართოებული",
      "p1": "მზად იყავი <highlight>React-ის ძირითადი პრინციპების</highlight> სიღრმისეულად შესასწავლად. ეს ტესტი გაგააზრებინებს — <em>useEffect-ის ზედმეტი რენდერების თავიდან აცილების ხერხებს</em>, როდის და რატომ უნდა გამოიყენო <em>useRef useState-ის ნაცვლად</em>, და დაგახვედრებს რეალურ პატერნებს, როგორიცაა თარგმნა, მდგომარეობის მართვა და სხვა.",
      "p2": "<strong>30 საგულდაგულოდ შედგენილ კითხვაზე</strong> პასუხით, გაიუმჯობესებ მასშტაბური აპლიკაციების შექმნის უნარს, დახვეწავ პრობლემების გადაჭრის გზებს და აღმოაჩენ მეთოდებს, რომელთა შესახებ ვერ შეიტყობდი ჩვეულებრივ ტუტორიალებში.",
      "buttons": {
        "start": "დაწყება",
        "info": "მეტი"
      },
      "Info": {
        "rules": "რეაქტ ქვიზის წესები",
        "rule1": "მოგეცემათ 30 რთული კითხვა რეაქტზე.",
        "rule2": "თითოეულ კითხვაზე შეგიძლიათ აირჩიოთ მხოლოდ 1 პასუხი.",
        "rule3": "სწორი პასუხი აინთება <green>მწვანედ</green>, არასწორი - <red>წითლად</red>.",
        "rule4": "სექციაში გექნებათ: Previous, Next, Skip და Explanation ღილაკები.",
        "rule5": "პასუხის დადასტურების შემდეგ გამოჩნდება სწორი პასუხი.",
        "rule6": "დროში არ არის შეზღუდვა, შეგიძლიათ მშვიდად ისწავლოთ.",
        "rule7": "დასრულების შემდეგ მიიღებთ ქულასა და შედეგებს."
      }
    },

    "random": {
      "heading": "რანდომ ლოგიკა",
      "popular": "პოპულარული",
      "p1": "გაამძაფრე პრობლემების გადაჭრის უნარები <highlight>შემთხვევითი ლოგიკის ქვიზით</highlight>. დაგხვდება რთული ამოცანები, რომლებიც ამოწმებს შაბლონებს, პირობას, ციკლებს, მონაცემების დამუშავებას და მოულოდნელ სიტუაციებს, რასაც ყველა დეველოპერი უნდა უმკლავდებოდეს.",
      "p2": "ამ ტესტში მზად იყავი ისეთი კითხვებისთვის, რაზეც არასდროს დაფიქრებულხარ. გაეცი პასუხი <strong>30 უნიკალურ შემთხვევით კითხვას</strong> რისი საშუალებითაც განივითარებ კრიტიკულ აზროვნებას, დაჩქარებ დებაგინგის პროცესს.",
      "buttons": {
        "start": "დაწყება",
        "info": "მეტი"
      },
      "Info": {
        "rules": "მოულოდნელ-ლოგიკური ქვიზის წესები",
        "rule1": "მოგეცემათ 30 შემთხვევითი და რთული კითხვა.",
        "rule2": "თითოეულ კითხვაზე შეგიძლიათ აირჩიოთ მხოლოდ 1 პასუხი.",
        "rule3": "სწორი პასუხი აინთება <green>მწვანედ</green>, არასწორი - <red>წითლად</red>.",
        "rule4": "სექციაში გექნებათ: Previous, Next, Skip და Explanation ღილაკები.",
        "rule5": "პასუხის დადასტურების შემდეგ გამოჩნდება სწორი პასუხი.",
        "rule6": "დროში არ არის შეზღუდვა, შეგიძლიათ მშვიდად ისწავლოთ.",
        "rule7": "დასრულების შემდეგ მიიღებთ ქულას და გამოხმაურებას."
      }
    }
  },
  "header": {
    "about": "შესახებ",
    "contact": "კონტაქტები",
    "resources": "რესურსები",
    "rules": "წესები"
  },
  "main": {
    "header2": "HTML/CSS ქვიზი",
    "header3": "ჯავასკრიპტის ქვიზი",
    "header4": "რეაქტის ქვიზი",
    "header5": "შემთხვევითი ლოგიკური ქვიზი",
    "p2": "დაწერე ტეგები. მართე სტილი.",
    "p3": "აკონტროლე ლოგიკა. განავითარე ვებგვერდი.",
    "p4": "გამოცადე შენი დეველოპერული ცოდნა",
    "p5": "გაცდი ლოგიკურ მსჯელობას. გადაჭერი ქაოსში.",
    "sec2html": "HTML/CSS ქვიზის სრული სია:",
    "sec2js": "Javascript ქვიზის სრული სია:",
    "sec2react": "React ქვიზის სრული სია:",
    "sec2random": "Random ქვიზის სრული სია:",
    "explanation": "განმარტება",
    "question": "კითხვა",
    "buttons": {
      "previous": "წინა",
      "next": "შემდეგი",
      "submit": "წარდგენა",
      "skip": "გამოტოვება",
      "refresh": "განახლება",
      "explanation": "განმარტება"
    }, 
    "videoTutorial": "ვიდეო გაკვეთილი",
    "videoCreator": "იუთუბ გაკვეთილი <highlight>BroCode</highlight>-ისგან.",
    "challengecomplete": "გამოწვევა დასრულდა!",
    "quizstats": "ქვიზის სტატისტიკა",
    "totalquestions": "ყველა კითხვა",
    "correctanswers": "სწორი პასუხი",
    "wronganswers": "შეცდომა",
    "skipped": "გამოტოვებული",
    "accuracy": "სიზუსტე",
    "finalscore": "საბოლოო ქულა",
    "insightmastery": "შეგრძნებები და ოსტატობა",
    "mostmissed": "შეცდომები:",
    "noincorrectanswers": "არ დაფიქსირდა მცდარი პასუხი",
    "yourmasterylevel": "ოსტატობის დონე:",
    "tryagain": "გამეორება",
    "gohome": "დაბრუნება"
  },
  "footer": {
    "help": "დახმარება",
    "howtoplay": "როგორ ვითამაშო",
    "cantStart": "ვერ ვიწყებ ქვიზს",
    "bug": "ბაგი",
    "more": "მეტი",

    "resources": "რესურსები",
    "docs": "დოკუმენტაცია",
    "blog": "ბლოგი",
    "repo": "GitHub რეპო",
    "community": "საზოგადოება",

    "contact": "კონტაქტი",
    "email": "ელ-ფოსტა",
    "linkedin": "ლინკდინი",
    "instagram": "ინსტაგრამი",
    "feedback": "უკუკავშირი",

    "about": "ჩვენს შესახებ",
    "aboutApp": "CodeMeter-ის შესახებ",
    "purpose": "მიზანი",
    "stack": "ტექნოლოგიები",
    "changelog": "ცვლილებები",

    "quizzes": "სხვა ქვიზები",
    "htmlcss": "HTML და CSS",
    "js": "ჯავასკრიპტი",
    "react": "რეაქტი",
    "custom": "მორგებული",

    "follow": "გამოგვიწერე:",
    "language": "ენა:",
    "copyright": "© 2024-{{year}} | CodeMeter | შექმნილია",
    "rights": "ლუკას მიერ | ყველა უფლება დაცულია.",
    "top": "ზემოთ",
    "quiz": "ქვიზები",

    "social": {
      "followUs": "გამოგვიწერე:",
      "language": "ენები"
    }
  },
  "footerFacts": [
    "ბულიანური ალგებრა შეიქმნა 1840-იან წლებში.",
    "ალან ტიურინგმა ენიგმის კოდი ლოგიკის მეშვეობით გაშიფრა.",
    "რეკურსია არის ფუნქცია, რომელიც საკუთარ თავს იძახებს.",
    "NAND კარიბჭე შეიძლება ნებისმიერი ლოგიკური კარიბჭის შესაქმნელად გამოიყენოს.",
    "იცოდი რომ React-ი შექმნა Facebook-ის ინჟინერმა სულ რამდენიმე დღეში!",
    "ლოგიკაში 'სიმართლის' საპირისპირო ყოველთვის 'ცრუა' — სხვა გზა არ არსებობს!",
    "დე მორგანის წესები ამარტივებს რთულ ლოგიკურ გამოთქმებს.",
    "ჯორჯ ბულის ნამუშევარმა შექმნა ციფრული სქემების საფუძველი.",
    "ლოგიკური კარიბჭეები ყველა კომპიუტერის მშენებლობის ქვაკუთხედია.",
    "XOR აბრუნებს true-ს მხოლოდ მაშინ, როცა შეყვანილები განსხვავებულია — როგორც საიდუმლო ხელის ჩამორთმევა.",
    "ტიურინგის მანქანა თანამედროვე კომპიუტერების მოდელია.",
    "JavaScript-ში `false || true` აბრუნებს true-ს — ლოგიკა ყოველთვის იმარჯვებს.",
    "`პროგრამირებაში if (false)` კოდი არასოდეს გაეშვება, რაც არ უნდა მოინდომო.",
    "კოდირების უმეტეს შეცდომას ლოგიკის პრობლემები იწვევს და არა სინტაქსი.",
    "ფუნქციური პროგრამირება დამოკიდებულია სუფთა ლოგიკასა და უცვლელობაზე.",
    "პარადოქსი არის განცხადება, რომელიც საკუთარ თავს ეწინააღმდეგება — რთული ლოგიკაა!",
    "ტაუტოლოგია არის ლოგიკური ფორმულა, რომელიც ყოველთვის მართალია.",
    "კონტრადიქცია არის ლოგიკური ფორმულა, რომელიც ყოველთვის ცრუა.",
    "ჭეშმარიტების ცხრილები აჩვენებს ყველა შესაძლო შედეგს ლოგიკური გამოთქმებისთვის.",
    "ლოგიკა არ არის მხოლოდ კომპიუტერებისთვის — ის კრიტიკულ აზროვნებასაც აძლიერებს."
  ],
  "htmlcss": {
    "1": {
      "question": "რას ნიშნავს HTML?",
      "options": [
        "Hyper Text Markup Language",
        "Home Tool Markup Language",
        "Hyperlinks and Text Markup Language",
        "Hyper Tool Machine Language"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "Hyper Text Markup Language",
      "explanation": "HTML ნიშნავს ჰიპერტექსტის მარკირების ენას. ის უზრუნველყოფს ვებ-კონტენტის სტრუქტურას და გვაძლევს საშუალებას გავაკეთოთ ბმულები გვერდზე."
    },
    "2": {
      "question": "რომელი ტეგი გამოიყენება HTML-ში ყველაზე დიდი სათაურის შესაქმელად?",
      "options": ["<heading>", "<h1>", "<h3>", "<h6>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<h1>",
      "explanation": "<h1> არის ყველაზე დიდი და მნიშვნელოვანი სათაურის ტეგი HTML-ში, მას შემდეგ მოდის ზომით შედარებით უფრო პატარა <h2>, <h3>...."
    },
    "3": {
      "question": "რომელი HTML ტეგი გამოიყენება შიდა სტილების განსასაზღვრად?",
      "options": ["<style>", "<css>", "<script>", "<link>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<style>",
      "explanation": "<style> ტეგი თავსდება HTML-ის <head>-ერ ნაწილში, შიდა CSS სტილების დასამატებლად, რაც შესაძლებობას გვაძლევს გავსტილოთ ჩვენი გვერდი."
    },
    "4": {
      "question": "რომელი CSS თვისება გამოიყენება ტექსტის ფერის შესაცვლელად?",
      "options": ["font-color", "text-color", "color", "font-style"],
      "level": "<easy>მარტივი</easy>",
      "correct": "color",
      "explanation": "'color' თვისება CSS-ში ცვლის ელემენტის ტექსტის ფერს."
    },
    "5": {
      "question": "რომელი HTML ჩანაწერით ხდება ბმულის შექმნა?",
      "options": [
        "<a>www.example.com</a>",
        "<a href='www.example.com'>Example</a>",
        "<link src='www.example.com'>",
        "<a url='www.example.com'>Example</a>"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "<a href='www.example.com'>Example</a>",
      "explanation": "<a> ტეგი (href) ატრიბუტთან ერთად ქმნის გადამყვან ბმულს მითითებულ მისამართზე."
    },
    "6": {
      "question": "რომელი ტეგის საშუალებით ხდება ტექსტის ახალ სტრიქონზე გადაყვანა HTML-ში?",
      "options": ["<br>", "<lb>", "<break>", "<line>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<br>",
      "explanation": "<br> ტეგი HTML-ში ტექსტი გადაჰყავს ახალ ხაზზე(ქვემოთ)."
    },
    "7": {
      "question": "რომელი CSS თვისება აკონტროლებს ტექსტის ზომას?",
      "options": ["font-style", "text-size", "font-size", "text-style"],
      "level": "<easy>მარტივი</easy>",
      "correct": "font-size",
      "explanation": "'font-size' ცვლის იმას თუ რამდენად დიდი ან პატარა გამოჩნდება ტექსტი CSS-ში"
    },
    "8": {
      "question": "რომელი HTML ტეგი გამოიყენება სურათის ჩასასმელად?",
      "options": ["<image>", "<img>", "<picture>", "<media>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<img>",
      "explanation": "<img> ტეგი HTML-ში სურათის ჩასასმელად გამოიყენება 'src' ატრიბუტი კი გვეხმარება მივუთითოთ რომელი სურათი გვსურს."
    },
    "9": {
      "question": "როგორ იწერება კომენტარი CSS-ში?",
      "options": [
        "// ეს არის კომენტარი",
        "<!-- ეს არის კომენტარი -->",
        "/* ეს არის კომენტარი */",
        "** ეს არის კომენტარი **"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "/* ეს არის კომენტარი */",
      "explanation": "CSS კომენტარი იწერება /* კომენტარი */, ფორმატში, ბრაუზერი მას არ აღიქვამს როგორც კოდურ ჩანაწერს."
    },
    "10": {
      "question": "რომელი ატრიბუტი გამოიყენება HTML-ში ჩასმული(ჩაშენებული) სტილების დასადგენად?",
      "options": ["font", "styles", "style", "class"],
      "level": "<easy>მარტივი</easy>",
      "correct": "style",
      "explanation": "'style' ატრიბუტი საშუალებას გვაძლევს პირდაპირ HTML ელემენტზე დავამატოთ CSS წესები."
    },
    "11": {
      "question": "როგორ უნდა განვათავსოთ ელემენტი ცენტრში, CSS-ში?",
      "options": [
        "margin: auto;",
        "text-align: center;",
        "align: center;",
        "padding: center;"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "margin: auto;",
      "explanation": "'margin: auto;' ჰორიზონტალურად ათავსებს ბლოკ ელემენტს ცენტრში, თუ მას ფიქსირებული სიგანე აქვს."
    },
    "12": {
      "question": "რას ნიშნავს CSS?",
      "options": [
        "Computer Style Sheets",
        "Creative Style Sheets",
        "Cascading Style Sheets",
        "Colorful Style Sheets"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "Cascading Style Sheets",
      "explanation": "CSS ნიშნავს Cascading Style Sheets-ს და გამოიყენება HTML ელემენტების გასასტილად(გასალამაზებლად)."
    },
    "13": {
      "question": "რომელი ტეგი გამოიყენება ტექსტის გასასქელებლად HTML-ში?",
      "options": ["<bold>", "<b>", "<strong>", "<em>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<b>",
      "explanation": "<b> ტეგი ტექსტს სქელ ფონტს აძლევს, მაგრამ არ მატებს სემანტიკურ მნიშვნელობას როგორც ამას აკეთებს <strong>-ტეგი."
    },
    "14": {
      "question": "რომელი CSS თვისება ამცირებს ან ხდის ტექსტს დახრილს?",
      "options": ["font-style: italic", "text-transform: italic", "font-weight: italic", "text-style: italic"],
      "level": "<easy>მარტივი</easy>",
      "correct": "font-style: italic",
      "explanation": "'font-style: italic;' გამოიყენება CSS-ში იმისათვის რომ ტექსტმა მიიღოს უნიკალური ფორმა, ამ შემთხვევაში ტექსტი გახდება დახრილი."
    },
    "15": {
      "question": "როგორ ვირჩევთ ელემენტს id-ის საშუალებით CSS-ში, რომ მოვახდინოთ მისი ამოცნობა და გასტილვა?",
      "options": ["#header", ".header", "*header", "header"],
      "level": "<easy>მარტივი</easy>",
      "correct": "#header",
      "explanation": "CSS-ში '#' სიმბოლო გამოიყენება ელემენტის ID-ის შესარჩევად. მაგალითად, #header ირჩევს id='header' ელემენტს."
    },
    "16": {
      "question": "რა განსხვავებაა div-სა და span ტეგებს შორის?",
      "options": [
        "ორივე არის ბლოკური ელემენტები კონტენტის დასაჯგუფებლად.",
        "<div> გამოიყენება inline სტილებისთვის, ხოლო <span> გამოიყენება განლაგებისთვის.",
        "<div> არის ბლოკ დონის ელემენტი, ხოლო <span> არის ხაზობრივი ელემენტი.",
        "<span> შეუძლია შეიცავდეს ბლოკურ ელემენტებს; <div> ვერა."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "<div> არის ბლოკ დონის ელემენტი, ხოლო <span> არის ხაზობრივი ელემენტი.",
      "explanation": "<div> გამოიყენება განლაგებისთვის და იკავებს მთელ სიგანეს, ხოლო <span>-ტეგი გამოიყენება მცირე ტექსტის inline სტილიზაციისთვის, იგი არ იკავებს მთელს სიგანეს."
    },
    "17": {
      "question": "რომელი HTML ელემენტი გამოიყენება ვიდეო ფაილების დასაკრავად(შემოსატანად)?",
      "options": ["<media>", "<video>", "<player>", "<file>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<video>",
      "explanation": "<video> ელემენტი HTML-ში საშუალებას იძლევა ჩავსვათ და ვაკონტროლოთ ვიდეო ფაილის შემოტანა ზომის მითითება, დაკვრა, სიმაღლე და სხვა."
    },
    "18": {
      "question": "რა არის <div>-ის ნაგულისხმევი 'display' თვისება CSS-ში?",
      "options": ["inline", "block", "flex", "grid"],
      "level": "<easy>მარტივი</easy>",
      "correct": "block",
      "explanation": "<div> ნაგულისხმევად არის ბლოკური ელემენტი, რაც ნიშნავს იმას რომ იგი დაიკავებს მთელ სიგანეს."
    },
    "19": {
      "question": "რომელი CSS თვისება ცვლის ფონურ ფერს( ფერს)?",
      "options": ["color", "bgcolor", "background-color", "bg-color"],
      "level": "<easy>მარტივი</easy>",
      "correct": "background-color",
      "explanation": "'background-color' ცვლის ელემენტის ფონურ ფერს CSS-ში."
    },
    "20": {
      "question": "რომელი HTML ტეგი გამოიყენება პარაგრაფის შესაქმნელად?",
      "options": [
        "<para>",
        "<paragraph>",
        "<p>",
        "<pg>"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "<p>",
      "explanation": "<p> ტეგი გამოიყენება პარაგრაფის განსასაზღვრად HTML-ში. ბრაუზერები ავტომატურად ამატებს სივრცეს თითოეული პარაგრაფის წინ და შემდეგ."
    },
    "21": {
      "question": "რა არის `z-index` CSS-ში?",
      "options": [
        "ფენის სიღრმის კონტროლი",
        "ელემენტის პიქსელური პოზიცია",
        "ტექსტის ზომის მორგება",
        "ელემენტის განლაგება ხაზზე"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ფენის სიღრმის კონტროლი",
      "explanation": "`z-index` განსაზღვრავს ელემენტების ფენათა მიმდევრობას, რაც უფრო მეტია ინდექსი მით უფრო მაღლა დგას იგი სხვებზე."
    },
    "22": {
      "question": "რა არის `flexbox` CSS-ში?",
      "options": [
        "ლინკების სტილი",
        "ტექსტის გაფორმება",
        "გადახვევის ეფექტი",
        "ელემენტების განლაგების მოდელი"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ელემენტების განლაგების მოდელი",
      "explanation": "`flexbox` გამოიყენება ელემენტების მოქნილად განლაგებისთვის კონტეინერში."
    },
    "23": {
      "question": "რომელია სწორი ტეგი ფორმის შესაქმნელად (login/registration) პირადი ინფორმაციისთვის?",
      "options": ["<form>", "<input>", "<submit>", "<button>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<form>",
      "explanation": "<form> გამოიყენება მომხმარებლის მიერ ინფორმაციის შესაყვანად, მაგ პაროლი, მობ. ნომერი, სახელი და სხვა."
    },
    "24": {
      "question": "რომელია სწორი ატრიბუტი ტექსტური ველის მნიშვნელობის განსასაზღვრად?",
      "options": ["value", "input", "text", "placeholder"],
      "level": "<easy>მარტივი</easy>",
      "correct": "value",
      "explanation": "`value` განსაზღვრავს input ველში მოცემულ მნიშვნელობას."
    },
    "25": {
      "question": "რომელი Css-ის მეთოდი გამოიყენება ელემენტის დამალვისთვის?",
      "options": ["display: none", "visibility", "hidden", "opacity"],
      "level": "<easy>მარტივი</easy>",
      "correct": "display: none",
      "explanation": "`display: none` სრულად მალავს(შლის) ელემენტს."
    },
    "26": {
      "question": "რა მიზანი აქვს <!DOCTYPE html> განცხადებას?",
      "options": ["CSS ფაილის დაკავშირება", "HTML ვერსიის განსაზღვრა", "JavaScript-ის ჩასმა", "კომენტარის შექმნა"],
      "level": "<easy>მარტივი</easy>",
      "correct": "HTML ვერსიის განსაზღვრა",
      "explanation": "DOCTYPE ბრაუზერს ეუბნება, HTML-ის რომელ ვერსიაშია დაწერილი გვერდი, რათა ის სწორად იყოს ნაჩვენები."
    },
    "27": {
      "question": "რომელი თეგი გამოიყენება HTML-ში ცხრილის შესაქმნელად?",
      "options": ["<table>", "<tab>", "<tr>", "<td>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<table>",
      "explanation": "<table> თეგი გამოიყენება HTML-ში ცხრილის შესაქმნელად."
    },
    "28": {
      "question": "რომელი თეგი განსაზღვრავს ცხრილის მწკრივს?",
      "options": ["<td>", "<th>", "<tr>", "<row>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<tr>",
      "explanation": "<tr> თეგი განსაზღვრავს ცხრილის მწკრივს (row)."
    },
    "29": {
      "question": "რომელი თეგი განსაზღვრავს ცხრილის უჯრას?",
      "options": ["<cell>", "<td>", "<tc>", "<tr>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<td>",
      "explanation": "<td> განსაზღვრავს ცხრილის უჯრას, ანუ მონაცემების უჯრედს."
    },
    "30": {
      "question": "როგორ ვახდენთ კლასის მინიჭებას HTML-ში?",
      "options": ["class='classname'", ".class: classname", "#class: classname", "id='classname'"],
      "level": "<easy>მარტივი</easy>",
      "correct": "class='classname'",
      "explanation": "HTML-ში class ატრიბუტი ენიჭება ელემენტს ამდაგვარად: class='classname'."
    },
    "31": {
      "question": "რა არის <img> თეგში alt ატრიბუტის მნიშვნელობა და მიზანი?",
      "options": ["გამოსახულების სტილიზაცია", "სათაურის დამატება", 
      "აჩვენოს ალტერნატიული ტექსტი თუ სურათის ჩატვირთვა ვერ ხდება", 
      "გამოსახულების მდებარეობის განსაზღვრა"],
      "level": "<easy>მარტივი</easy>",
      "correct": "აჩვენოს ალტერნატიული ტექსტი თუ სურათის ჩატვირთვა ვერ ხდება",
      "explanation": "alt ატრიბუტი უზრუნველყოფს ალტერნატიული ტექსტის ჩვენებას, თუ სურათი ვერ ჩაიტვირთება."
    },
    "32": {
      "question": "რომელი თეგი გამოიყენება დაულაგებელი სიისთვის?",
      "options": ["<ul>", "<ol>", "<li>", "<list>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<ul>",
      "explanation": "<ul> ქმნის დაულაგებელ სიას, რომელიც წერტილებით არის დანიშნული."
    },
    "33": {
      "question": "რომელი თეგი განსაზღვრავს სიის ერთ ელემენტს?",
      "options": ["<item>", "<li>", "<ul>", "<ol>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<li>",
      "explanation": "<li> წარმოადგენს სიის ერთ ელემენტს HTML-ში, იგი ძირითადად იწერება <ul>-ში ან <ol>-ში."
    },
    "34": {
      "question": "რომელი CSS თვისება წყვეტს ფონური სურათის გამეორებას?",
      "options": ["background-repeat: no;", "background-no-repeat: true;", "no-repeat: background;", "background-repeat: no-repeat;"],
      "level": "<easy>მარტივი</easy>",
      "correct": "background-repeat: no-repeat;",
      "explanation": "background-repeat: no-repeat; აჩერებს ფონური სურათის გამეორებას, იგი ძირითადად გამოსადეგარია როდესაც გვაქვს პატარა ზომის სურათი."
    },
    "35": {
      "question": "რომელი ერთეული დამოკიდებულია მშობლის ფონტის ზომაზე?",
      "options": ["px", "em", "cm", "%"],
      "level": "<easy>მარტივი</easy>",
      "correct": "em",
      "explanation": "'em' ერთეული დამოკიდებულია მშობელი ელემენტის ფონტის ზომაზე."
    },
    "36": {
      "question": "რომელი CSS მნიშვნელობა ხდის ელემენტს უხილავს, მაგრამ მაინც ტოვებს სივრცეს?",
      "options": ["hidden", "display: none;", "visibility: hidden;", "opacity: 100"],
      "level": "<easy>მარტივი</easy>",
      "correct": "visibility: hidden;",
      "explanation": "'visibility: hidden;' ელემენტს უხილავს ხდის, მაგრამ სივრცეს ტოვებს."
    },
    "37": {
      "question": "რას აკეთებს z-index თვისება CSS-ში?",
      "options": ["ზუმის დონის განსაზღვრა", "ელემენტების ზედდების მიმდევრობის განსაზღვრა", "ფონტის სისქის დაყენება", "გვერდის ინდექსის შეცვლა"],
      "level": "<easy>მარტივი</easy>",
      "correct": "ელემენტების ზედდების მიმდევრობის განსაზღვრა",
      "explanation": "z-index-ი განსაზღვრვს თუ რომელი ელემენტი აღმოჩნდება შედარებით უფრო მაღლა როდესაც ელემენტები ერთმანეთს ხურავენ ერთამენთით."
    },
    "38": {
      "question": "როგორ გავხადოთ სია ჰორიზონტალური მიმდევრობის?",
      "options": ["display: inline;", "flex-direction: column;", "list-style: none;", "display: flex;"],
      "level": "<easy>მარტივი</easy>",
      "correct": "display: flex;",
      "explanation": "'display: flex;' ქმნის ჰორიზონტალურ (ან ვერტიკალურ) განლაგებას Flexbox მოდელით."
    },
    "39": {
      "question": "რომელი თეგი გამოიყენება აუდიო ფაილების ჩასამაგრებლად HTML-ში?",
      "options": ["<audio>", "<sound>", "<mp3>", "<music>"],
      "level": "<easy>მარტივი</easy>",
      "correct": "<audio>",
      "explanation": "<audio> თეგი გამოიყენება აუდიო ფაილების HTML-ში ჩასამაგრებლად."
    },
    "40": {
      "question": "რომელი ფსევდო-კლასი აირჩევს ელემენტის პირველ შვილს?",
      "options": [":first", ":first-child", "::first", ":nth-child(1)"],
      "level": "<medium>საშუალო</medium>",
      "correct": ":first-child",
      "explanation": ":first-child ფსევდო კლასი არჩევს ელემენტის პირველ შვილს მის მშობელ ელემენტში."
    },
    "41": {
      "question": "რა ფუნქცია აქვს 'position: absolute'-ს?",
      "options": ["ელემენტის ფიქსაცია viewport-ზე", "ელემენტის ამოღება ნაკადიდან და განთავსება უახლოეს პოზიცირებულ წინაპართან", "ელემენტის სქროლვადობა", "ელემენტის ცენტრში განლაგება"],
      "level": "<medium>საშუალო</medium>",
      "correct": "ელემენტის ამოღება ნაკადიდან და განთავსება უახლოეს პოზიცირებულ წინაპართან",
      "explanation": "position: absolute ელემენტს ნორმალური დოკუმენტის ნაკადიდან აგდებს და მას უახლოესი წინაპრის მიხედვით „სტატიკურისგან“ განსხვავებულ პოზიციაზე ათავსებს."
    },
    "42": {
      "question": "რა არის CSS-ში პოზიციის ნაგულისხმევი მნიშვნელობა?",
      "options": ["absolute", "relative", "static", "fixed"],
      "level": "<medium>საშუალო</medium>",
      "correct": "static",
      "explanation": "ნაგულისხმებად, ელემენტები არიან სტატისტიკურ რეჟიმში, რაც იმას ნიშნავს რომ ისინი მიყვებიან ნორმალურ დოკუმენტურ ნაკადს"
    },
    "43": {
      "question": "რომელი CSS თვისება ამატებს ჩრდილს ტექსტს?",
      "options": ["text-style", "font-shadow", "text-shadow", "box-shadow"],
      "level": "<medium>საშუალო</medium>",
      "correct": "text-shadow",
      "explanation": "text-shadow' ამატებს ჩრდილის ეფექტს ტექსტზე."
    },
    "44": {
      "question": "რომელი ატრიბუტი ხსნის ბმულს ახალ ჩანართში?",
      "options": ["target='_blank'", "new-tab", "href='_new'", "open='tab'"],
      "level": "<medium>საშუალო</medium>",
      "correct": "target='_blank'",
      "explanation": "target='_blank' ბმულს ხსნის ახალ ჩანართში ან ფანჯარაში."
    },
    "45": {
      "question": "რომელი HTML ელემენტია საუკეთესო ვარიანტი რომ მოვახდინოთ სანავიგაციო ლინკების მარკირება?",
      "options": [
        "<section>", "<nav>",
        "<aside>", "<menu>"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "<nav>",
      "explanation": "<nav> არის სემანტიკური HTML ელემენტი, რომელიც სპეციალურადაა განკუთვნილი სანავიგაციო ბმულებისთვის."
    },
    "46": {
      "question": "ზუსტად რას აკეთებს <label> ტეგი HTML-ის forms-ში?",
      "options": [
        "ის აჯგუფებს რამდენიმე input ველს",
        "ის სტილავს ფორმ ელემენტს",
        "ის განსაზღვრავს შეყვანის წარწერას input ელემენტისთვის",
        "ის ადასრუებს მომხლარებლის input-ს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის განსაზღვრავს შეყვანის წარწერას input ელემენტისთვის",
      "explanation": "The <label> tag connects text to an input element, making forms more accessible and easier to use."
    },
    "47": {
      "question": "CSS-ში, რას აკეთებს ძირითადად 'position: relative'?",
      "options": [
        "ანთავსებს ელემენტს რელატიურად მის მშობელთან",
        "ანთავსებს ელემენტს რელატიურად მის ნორმალურ პოზიციაზე",
        "აფიქსირებს ელემენტს თავის ადგილზე",
        "ანტავსებს ელემენტს relative-ურად ხედვის პორტთან"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ანთავსებს ელემენტს რელატიურად მის ნორმალურ პოზიციაზე",
      "explanation": "'position: relative' საშუალებას გაძლევთ გადაადგილოთ ელემენტი ისე, რომ ის არ ამოვიდეს დოკუმენტის ნორმალური განლაგებიდან. ასევე ის ქმნის პოზიცირების კონტექსტს ნებისმიერი აბსოლუტურად პოზიციონირებული შვილის ელემენტისთვის."
    },
    "48": {
      "question": "რომელი CSS თვისება ამატებს სივრცეს ელემენტებს შორის (საზღვრებს(border) გარეთ)?",
      "options": ["padding", "margin", "border-spacing", "gap"],
      "level": "<medium>საშუალო</medium>",
      "correct": "margin",
      "explanation": "'margin' განსაზღვრავს ელემენტის გარე სივრცეს, საზღვრებს გარეთ."
    },
    "49": {
      "question": "როგორ დავაწესოთ სტილი მხოლოდ მაშინ, როცა ელემენტზე მაუსს გადავატარებთ?",
      "options": [":hover", ":active", ":visited", ":focus"],
      "level": "<medium>საშუალო</medium>",
      "correct": ":hover",
      "explanation": ":hover ფსევდო კლასი ახდენს სტილის შემოტანას მაშინ როდესაც მომხარებელი უთითებს ელემენტს მაუსის გამოყენებით."
    },
    "50": {
      "question": "რა მიზანი აქვს <head> თეგს HTML დოკუმენტში?",
      "options": ["მთავარი კონტენტის განსაზღვრა", "სკრიპტების, სტილების და მეტა-მონაცემების ჩასმა", "body კონტენტის დაწერა", "სერვერის ლოგიკის შენახვა"],
      "level": "<medium>საშუალო</medium>",
      "correct": "სკრიპტების, სტილების და მეტა-მონაცემების ჩასმა",
      "explanation": "<head> თეგი შეიცავს მეტა-მონაცემებს, სტილებს და სკრიპტებს HTML დოკუმენტისთვის."
    },
     "51": {
      "question": "რომელი ტეგი გამოიყენება ცხრილის მწკრივის შესაქმნელად?",
      "options": ["<th>", "<tr>", "<td>", "<row>"],
      "level": "<medium>საშუალო</medium>",
      "correct": "<tr>",
      "explanation": "<tr> აღნიშნავს table row-ს და გამოიყენება ცხრილის უჯრების ჰორიზონტალურ მწკრივში დასაჯგუფებლად."
    },
    "52": {
      "question": "რომელი თვისება ცვლის ელემენტის ფონის ფერს Css-ში?",
      "options": ["color", "bg-color", "background-color", "background"],
      "level": "<medium>საშუალო</medium>",
      "correct": "background-color",
      "explanation": "background-color აყენებს ელემენტის ფონს ტექსტისა და შიგთავსის უკან."
    },
    "53": {
      "question": "რომელი input ტიპი ქმნის სლაიდერის კონტროლს?",
      "options": ["range", "slider", "scale", "number"],
      "level": "<medium>საშუალო</medium>",
      "correct": "range",
      "explanation": "input type='range' ქმნის სლაიდერს, რომელიც იძლევა მნიშვნელობის შერჩევის საშუალებას მინიმუმსა და მაქსიმუმს შორის."
    },
    "54": {
      "question": "ზუსტად სად ვამატებთ ჩვენს <script>-ტეგს ჩვენს html დოკუმენტში, რომ შემოვიტანოთ ფუნქციონალური კოდები",
      "options": ["<head>", "<body>", "<meta>", "<link>"],
      "level": "<medium>საშუალო</medium>",
      "correct": "<body>",
      "explanation": "ჩვენ ვამატებთ ჩვენს script ტეგს ჩვენი html დოკუმენტის ტანში<body>, რათა შესაძლებელი გახდეს ჯავასკრიპტის შემოტანა."
    },
    "55": {
      "question": "გვაქვს ორი ელემენტი: <div style='position: relative; z-index: 20;...'></div> და <div style='position: relative; z-index: 10;...'></div>. რომელი ელემენტი აღმოჩნდება თუ ისინი იქნებიან დადგმული ერთ წერტილში?",
      "options": [
        "div-ი რომელსაც აქვს z ინდექსად 10",
        "div-ი რომელსაც აქვს z ინდექსად 20",
        "ისინი გამოჩნდებიან ერთნაიად",
        "ეს დამოკიდებულია HTML-ის ბრძანებაზე"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "div-ი რომელსაც აქვს z ინდექსად 20",
      "explanation": "div-ი რომელსაც აქვს z ინდექსად 20 აქვს უფრო მაღალი z ინდექსი ვიდრე მეორეს (z-10), ამიტომაც იგი აღმოჩნდება უფრო მაღლა და დაჩრდილავს მეორე დივს თუ ისინი აღმოჩნდებიან ერთ წერტილში."
    },
    "56": {
      "question": "Css-ში რომელი სელექტორი ირჩევს ყველა <p> ელემენტს <div>-ის შიგნით?",
      "options": ["div.p", "div p", "p > div", "div + p"],
      "level": "<medium>საშუალო</medium>",
      "correct": "div p",
      "explanation": "'div p' ირჩევს ყველა <p> ელემენტს, რომელიც ამ <div>-ის შთამომავალია."
    },
    "57": {
      "question": "რას აკეთებს <meta charset='UTF-8'> ტეგი?",
      "options": [
        "განსაზღვრავს დოკუმენტის ენას",
        "აიძულებს სტილის ფაილის ჩასმას",
        "განსაზღვრავს სიმბოლოების კოდირებას",
        "ამატებს SEO საკვანძო სიტყვებს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "განსაზღვრავს სიმბოლოების კოდირებას",
      "explanation": "იგი ეუბნება ბრაუზერს გამოიყენოს UTF-8 კოდირება, რომელიც უჭერს მხარს თითქმის ყველა ენას და სიმბოლოს."
    },
    "58": {
      "question": "რომელი თვისება ადგენს ელემენტის ფონტს?",
      "options": ["font", "font-style", "font-family", "text-font"],
      "level": "<medium>საშუალო</medium>",
      "correct": "font-family",
      "explanation": "'font-family' განსაზღვრავს ტექსტის გამოსატან ფონტს (ტიპოგრაფიას)."
    },
    "59": {
      "question": "რას აკეთებს 'display: flex' თვისება?",
      "options": [
        "ათავსებს ტექსტს ცენტრში",
        "იყენებს float განლაგებას",
        "ჩართავს მოქნილ (flex) განლაგებას",
        "ხდის ელემენტს sticky-ს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ჩართავს მოქნილ (flex) განლაგებას",
      "explanation": "'display: flex' ააქტიურებს Flexbox-ის მოდელს რომ მან დააწყოს და განახორციელოს სივრცეების განთავსება მონაცემებს შორის."
    },
    "60": {
      "question": "რომელი ტეგი განსაზღვრავს ნავიგაციის ბმულების კონტეინერს?",
      "options": ["<nav>", "<button>", "<aside>", "<menu>"],
      "level": "<medium>საშუალო</medium>",
      "correct": "<nav>",
      "explanation": "<nav> არის HTML5-ის სემანტიკური ტეგი, რომელიც აჯგუფებს ნავიგაციის ბმულებს."
    },
    "61": {
      "question": "რა განსხვავებაა class-სა და ID-ს შორის HTML-ში?",
      "options": ["class უნიკალურია, ID შეიძლება განმეორდეს", "ID შეიძლება განმეორდეს, class უნიკალურია", "class-ის გამოყენება ბევრგან შეიძლება, ID კი უნიკალურია", "ორივე ერთია"],
      "level": "<medium>საშუალო</medium>",
      "correct": "class-ის გამოყენება ბევრგან შეიძლება, ID კი უნიკალურია",
      "explanation": "class შეიძლება მიენიჭოს რამდენიმე ელემენტს, ხოლო ID მხოლოდ ერთ ტეგს მთელ გვერდზე."
    },
    "62": {
      "question": "რომელი CSS ერთეულია დამოკიდებული root ელემენტის ფონტზე?",
      "options": ["em", "rem", "px", "%"],
      "level": "<medium>საშუალო</medium>",
      "correct": "rem",
      "explanation": "`rem` ნიშნავს 'root em' და ეფუძნება root (`<html>`) ელემენტის ფონტის ზომას."
    },
    "63": {
      "question": "რომელი CSS ერთეულია საუკეთესო მასშტაბირებადი სივრცისთვის ყველა ეკრანზე?",
      "options": ["px", "rem", "vh", "pt"],
      "level": "<medium>საშუალო</medium>",
      "correct": "rem",
      "explanation": "`rem` ერთეულები მასშტაბირდებიან root ფონტზე დაყრდნობით, რაც მათ იდეალურს ხდის რესპონსიული დიზაინისთვის."
    },
    "64": {
      "question": "როგორ იცვლება ტექსტის ფერი Tailwind CSS-ში?",
      "options": ["color-red", "font-color-red", "text-red-500", "bg-red-500"],
      "level": "<medium>საშუალო</medium>",
      "correct": "text-red-500",
      "explanation": "Tailwind იყენებს utility კლასებს როგორიცაა `text-red-500`, `დან:red-50  მდე:red-950` ტექსტის ფერის შესაცვლელად."
    },
    "65": {
      "question": "რა არის Tailwind CSS-სა და ჩვეულებრივ CSS-ს შორის მთავარი განსხვავება?",
      "options": ["Tailwind გამოიყენება ხაზში", "Tailwind არ აქვს შეზღუდვები", "Tailwind იყენებს utility კლასებს", "Tailwind მხარს უჭერს ყველა ანიმაციას"],
      "level": "<medium>საშუალო</medium>",
      "correct": "Tailwind იყენებს utility კლასებს",
      "explanation": "Tailwind ეფუძნება utility-first მიდგომას, სადაც თითოეული სტილი ცალკე კლასით არის წარმოდგენილი."
    },
    "66": {
      "question": "რომელი პოზიციონირების მნიშვნელობა ტოვებს ელემენტს ფიქსირებულს სკროლის დროს?",
      "options": ["relative", "static", "sticky", "fixed"],
      "level": "<medium>საშუალო</medium>",
      "correct": "fixed",
      "explanation": "Fixed პოზიცია აჩერებს ელემენტს viewport-ზე და არ გადაადგილდება გვერდის გადახვევისას ანუ არის ფიქსირებული ეკრანზე."
    },
    "67": {
      "question": "რას აკეთებს `position: sticky`?",
      "options": ["ამაგრებს ზედა ნაწილში", "იქცევა როგორც absolute", "იქცევა როგორც relative შემდეგ fixed", "ფარავს ელემენტს"],
      "level": "<medium>საშუალო</medium>",
      "correct": "იქცევა როგორც relative შემდეგ fixed",
      "explanation": "Sticky ელემენტი ნორმალურად იძვრის მანამ, სანამ არ მიაღწევს კონკრეტულ scroll პოზიციას და შემდეგ ხდება fixed-ის ტიპის, დამოკიდებულია როგორ გავსტილავთ."
    },
    "68": {
      "question": "რა არის <div> ელემენტის ნაგულისხმევი display გამოტანის თვისება?",
      "options": ["inline", "block", "flex", "grid"],
      "level": "<medium>საშუალო</medium>",
      "correct": "block",
      "explanation": "`<div>` ელემენტები ნაგულისხმევად block ელემენტებია რაც იმას ნიშნავს რომ იგი იკავებს მთელს სიგანეს."
    },
    "69": {
      "question": "რომელი Tailwind კლასი ანიჭებს padding-ს ყველა მხარეს?(ზემოთ, ქვემოთ, მარცხნივ და მარჯვნივ)",
      "options": ["pd-4", "space-4", "p-4", "padding-4"],
      "level": "<medium>საშუალო</medium>",
      "correct": "p-4",
      "explanation": "Tailwind-ში `p-4` ნიშნავს padding-ის დამატებას ყველა მხარეს ერთდროულად(ზემოთ, ქვემოთ, მარცხნივ და მარჯვნივ)."
    },
    "70": {
      "question": "როგორ გამოიყენება box shadow, Tailwind CSS-ში?",
      "options": ["shadow-md", "box-shadow", "shadow: md", "shd-md"],
      "level": "<medium>საშუალო</medium>",
      "correct": "shadow-md",
      "explanation": "Tailwind-ს აქვს მზა utility კლასები როგორებიცაა `shadow`, `animate`, box-shadow-ის გამოსაყენებლად."
    },
    "71": {
      "question": "რომელი HTML ტეგში ვწერთ ჩვენს პირად მონაცემებს: სახელი, ტელ. ნომ და?",
      "options": ["<footer>", "<form>", "<link>", "<aside>"],
      "level": "<medium>საშუალო</medium>",
      "correct": "<form>",
      "explanation": "<form> ელემენტი გამოიყენება მონაცემების შესანახად როგორებიცაა username, mobile phone, password, ამ ყველაფერს ვწერთ <form> ტეგში."
    },
    "72": {
      "question": "HTML/CSS-ში, რადაა მიჩნეული 'root' ვებგვერდის ელემენტი?",
      "options": [
        "<body>",
        "<html>",
        "<head>",
        "<main>"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "<html>",
      "explanation": "<html> ელემენტი არის HTML დოკუმენტის ფესვი. ხოლო CSS-ში, :root მიზანში იღებს ამ ელემენტს<html>, იგი ხშირად გამოიყენება გლობალური ცვლადების განსასაზღვრად."
    },
    "73": {
      "question": "რა განსხვავებაა `em` და `rem` ერთეულებს შორის CSS-ში?",
      "options": ["em ფიქსირებულია, rem შედარებითია", "em იყენებს root-ის ზომას, rem მშობელს", "em მშობლის ზომაზეა დამოკიდებული, rem root-ზე", "ისინი იდენტურია"],
      "level": "<medium>საშუალო</medium>",
      "correct": "em მშობლის ზომაზეა დამოკიდებული, rem root-ზე",
      "explanation": "`em` დამოკიდებულია მშობლის ფონტის ზომაზე, ხოლო `rem` — ფესვის (`html`) ზომაზე."
    },
    "74": {
      "question": "რომელი CSS-ს ხელსაწყოს საშუალებიტ შეგვიძლია შევცვალოთ კურსორის ტიპი როდესაც ვაკეთებთ hovering-ს ელემენტზე?",
      "options": [
        "pointer-events",
        "cursor",
        "hover",
        "mouse-style"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "cursor",
      "explanation": "cursor ხელსაწყო ცვლის მაუსის სტილს როდესაც ვაკეთებთ hovering-ს ელემენტზე, მაგალითად `cursor: pointer;` ხდის მაუსის ნაგულისხმევ სურათს(ისარს) საჩვენებელი თითის ფორმად(აიკონად)."
    },
    "75": {
      "question": "რა არის CSS ცვლადების გამოყენების მთავარი უპირატესობა?",
      "options": ["უფრო სწრაფი რენდერინგი", "ადვილი ანიმაციები", "მნიშვნელობების ხელახალი გამოყენება", "მომხმარებლის შრიფტები"],
      "level": "<medium>საშუალო</medium>",
      "correct": "მნიშვნელობების ხელახალი გამოყენება",
      "explanation": "CSS ცვლადები აადვილებს სტილებში განმეორებითი მნიშვნელობების ხელახალ გამოყენებას."
    },
    "76": {
      "question": "Css-ში რომელი სელექტორი მიმართავს კლასს?",
      "options": [".header", "#header", "header", "header[]"],
      "level": "<medium>საშუალო</medium>",
      "correct": ".header",
      "explanation": "კლასის სელექტორები იწყება წერტილით (`.`), რომელსაც მოსდევს კლასის სახელი."
    },
    "77": {
      "question": "CSS-ში სურათის ზომის შეცვლისას, რომელი თვისება ინარჩუნებს მის ორიგინალ პროპორციებს, რათა არ გამოიყურებოდეს გაწელილი ან დამტვრეული?",
      "options": [
        "object-fit",
        "image-ratio",
        "background-size",
        "aspect-ratio"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "object-fit",
      "explanation": "`object-fit` თვისება აკონტროლებს თუ როგორ მოერგება სურათი კონტეინერს. მაგალითად, `object-fit: cover;` ან `contain;` ინარჩუნებს სწორ პროპორციებს და თავიდან იცილებს დამახინჯებას."
    },
    "78": {
      "question": "HTML-ში, როგორ შეგვიძლია გავხადოთ input ტეგის ტიპი რადიო ღილაკად?",
      "options": [
        "<input type='button'>",
        "<input type='radio'>",
        "<input type='checkbox'>",
        "<input type='circle'>"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "<input type='radio'>",
      "explanation": "როდესაც ვაყენებთ `type` ატრიბუტს `radio`-ზე, ეს ქმნის წრიულ ფორმას როგორც ასარჩევ ვარიანტს, რომელიც მომხარებელს საშუალებას აძლევს აირჩიოს ერთ-ერთი ვარიანტი სიიდან."
    },
    "79": {
      "question": "HTML-ში, როგორ ან რისთვის გამოიყენება <svg> ტეგი?",
      "options": [
        "მასშტაბირებადი ვექტორული გრაფიკის საჩვენებლად",
        "რომ მოვათავსოთ ხმის ეფექტი",
        "ვიდეოს დაკვრის დასამატებლად",
        "რომ გავსტილოთ ტექსტი გრადიენტებით"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "მასშტაბირებადი ვექტორული გრაფიკის საჩვენებლად",
      "explanation": "<svg> ტეგი გამოიყენება რომ შეიქმნას უნიკალური ფორმის ვექტორი HTML-ში. SVG სურათები რჩება ბასრი ყველანაირ რეზოლუციაში და იგი გამოიყენება ლამაზი UX/UI ვიზუალებისთვის."
    },
    "80": {
      "question": "რას აკეთებს `overflow: hidden`?",
      "options": ["აჩენს scrollbars", "აჭრის გადაჭარბებულ კონტენტს", "ცენტრავს შიგთავსს", "ზრდის ელემენტის ზომას"],
      "level": "<medium>საშუალო</medium>",
      "correct": "აჭრის გადაჭარბებულ კონტენტს",
      "explanation": "`overflow: hidden` ფარავს იმ კონტენტს, რომელიც გადააჭარბებს ელემენტის საზღვრებს."
    },
    "81": {
      "question": "რა განსხვავებაა `min-width` და `max-width` შორის?",
      "options": ["min-width აყენებს ფიქსირებულ ზომას", "max-width ცვლის margin-ს", "min-width განსაზღვრავს მინიმალურ დასაშვებ ზომას", "არანაირი სხვაობა არაა"],
      "level": "<hard>რთული</hard>",
      "correct": "min-width განსაზღვრავს მინიმალურ დასაშვებ ზომას",
      "explanation": "`min-width` აყალიბებს მინიმალურ სიგანეს, ხოლო `max-width` — მაქსიმალურს."
    },
    "82": {
      "question": "რომელი Tailwind კლასი აკონტროლებს Flex ელემენტებს შორის ჰორიზონტალურ მანძილს?",
      "options": ["gap-x", "margin-x", "space-x", "padding-x"],
      "level": "<hard>რთული</hard>",
      "correct": "space-x",
      "explanation": "`space-x-*` Tailwind-ში ქმნის ჰორიზონტალურ სივრცეს შვილ ელემენტებს შორის."
    },
    "83": {
      "question": "რა არის `box-sizing` თვისების ნაგულისხმევი მნიშვნელობა?",
      "options": ["border-box", "content-box", "auto", "none"],
      "level": "<hard>რთული</hard>",
      "correct": "content-box",
      "explanation": "ნაგულისხმევად, `box-sizing` არის `content-box`, რაც ნიშნავს, რომ padding და border არ შედის ზომებში."
    },
    "84": {
      "question": "CSS-ში, რომელი მეთოდის საშუალებით შეგვიძლია შევქმნათ რამდენიმე ფერის მიქსი ფონზე?",
      "options": [
        "background: color-mix(...)",
        "background: gradient-color(...)",
        "background: linear-gradient(...)",
        "background: color-gradient(...)"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "background: linear-gradient(...)",
      "explanation": "CSS-ში, `linear-gradient()` გამოიყენება `background`-თან ერთად რომ შეიქმნას ფერთა მიქსის გრადიენტი. მაგალითად: `background: linear-gradient(to bottom, red, blue, green);`."
    },
    "85": {
      "question": "რომელი მედია ქუერი გამოიყენება ეკრანებისთვის, რომელთა სიგანე ნაკლებია 768px-ზე?",
      "options": ["@media (min-width: 768px)", "@media screen", "@media (max-width: 768px)", "@media <768"],
      "level": "<hard>რთული</hard>",
      "correct": "@media (max-width: 768px)",
      "explanation": "`max-width: 768px` გამოიყენება იმ ეკრანებზე, რომლებიც 768 პიქსელზე პატარაა."
    },
    "86": {
      "question": "რომელი იყო HTML-ის პირველი ვერსია და როდის შეიქმნა იგი?",
      "options": ["HTML 1.0 - 1991", "HTML 2.0 - 1995", "HTML 3.2 - 1997", "HTML5 - 2014"],
      "level": "<hard>რთული</hard>",
      "correct": "HTML 1.0 - 1991",
      "explanation": "HTML 1.0 შეიქმნა ტიმ ბერნერს-ლიის მიერ 1991 წელს, ვებ დოკუმენტების მარტივი ფორმატირებისთვის და დაკავშირებისთვის."
    },
    "87": {
      "question": "ვინ შექმნა HTML და რატომ?",
      "options": ["ბრენდან აიხმა, სტილების შექმნისთვის", "ტიმ ბერნერს-ლიმ, დოკუმენტების გაზიარებისთვის", "ლინუს ტორვალდსმა, Linux ვებსაიტებისთვის", "სტივ ჯობსმა, Apple-ის საიტებისთვის"],
      "level": "<hard>რთული</hard>",
      "correct": "ტიმ ბერნერს-ლიმ, დოკუმენტების გაზიარებისთვის",
      "explanation": "ტიმ ბერნერს-ლიმ შექმნა HTML, რათა მკვლევრებს შეეძლოთ ერთმანეთთან დაკავშირებული დოკუმენტების გაზიარება ვებსივრცეში."
    },
    "88": {
      "question": "რატომ არ ითვლება HTML და CSS პროგრამულ ენებად?",
      "options": ["არ იყენებენ სემიკოლონს", "არ შეუძლიათ ვებსაიტების შექმნა", "არ შეიცავენ ლოგიკას ან კონტროლის ნაკადს", "ბრაუზერში არ მუშაობენ"],
      "level": "<hard>რთული</hard>",
      "correct": "არ შეიცავენ ლოგიკას ან კონტროლის ნაკადს",
      "explanation": "HTML არის მარკირების ხოლო CSS არიას  და სტილიზაციის ენები და არა პროგრამირების, რადგან არ შეუძლიათ ლოგიკური ოპერაციებისა და გადაწყვეტილებების მიღება."
    },
    "89": {
      "question": "რომელი ვერსია გვაჩვენებს HTML-ის თანამედროვე სტილს სემანტიკური ტეგებით როგორებიცაა:`<article>` და `<section>`?",
      "options": ["HTML 3.2", "HTML 4.01", "HTML5", "XHTML"],
      "level": "<hard>რთული</hard>",
      "correct": "HTML5",
      "explanation": "HTML5-მა შემოიტანა სემანტიკური ტეგები, რათა უკეთ აღიწეროს სტრუქტურა და ვებ კონტენტის მნიშვნელობა."
    },
    "90": {
      "question": "რა იყო CSS-ის შექმნის მიზანი 1996 წელს?",
      "options": ["JavaScript-ის ჩანაცვლება", "HTML-ის კონტენტისგან განცალკევებით სტილიზაცია(სტილის გამოყოფა შიგთავსისგან)", "გვერდის დატვირთვის აჩქარება", "მობილური აპების შექმნა"],
      "level": "<hard>რთული</hard>",
      "correct": "HTML-ის კონტენტისგან განცალკევებით სტილიზაცია(სტილის გამოყოფა შიგთავსისგან)",
      "explanation": "CSS შეიქმნა სტილისა და შიგთავსის დასაშორებლად, რათა ვებსაიტების სტრუქტურა უფრო მარტივად სამართავი და თანმიმდევრული ყოფილიყო."
    },
    "91": {
      "question": "რომელ წელს იქნა პირველად შემოთავაზებული CSS (Cascading Style Sheets)?",
      "options": [
        "1994",
        "1989",
        "2000",
        "1997"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "1994",
      "explanation": "CSS-ი პირველად იქნა შემოთავაზებული Håkon Wium Lie-ს მიერ 1994 წელს, მისი მიზანი იყო კონტენტისა და დიზაინის განცალკევება ვებზე."
    },
    "92": {
      "question": "როგორ მართავს Tailwind CSS-მ ადაპტურ დიზაინს?",
      "options": ["იყენებს პირდაპირ მედია-კითხვებს", "ამატებს საკუთარი JavaScript ზღვარს", "იყენებს utility კლასებს როგორიცაა `md:` და `lg:`", "არ უჭერს მხარს ადაპტურობას"],
      "level": "<hard>რთული</hard>",
      "correct": "იყენებს utility კლასებს როგორიცაა `md:` და `lg:`",
      "explanation": "Tailwind იყენებს პრეფიქსებს (`md:`, `lg:` და სხვა), რათა სტილები მიესადაგოს ეკრანის ზომას."
    },
    "93": {
      "question": "რა არის ძირითადი განსხვავება absolute და sticky პოზიციონირებებს შორის?",
      "options": [
      "Sticky თავისუფლად მოძრაობს, absolute - არა", 
      "Sticky დამოკიდებულია სქროლზე, ხოლო absolute-ი უახლოეს პოზიციონირებულ მშობელზე", 
      "Sticky იყენებს z-index-ს, absolute - არა", 
      "განსხვავება არ არსებობს"],
      "level": "<hard>რთული</hard>",
      "correct": "Sticky დამოკიდებულია სქროლზე, ხოლო absolute-ი უახლოეს პოზიციონირებულ მშობელზე",
      "explanation": "Sticky ელემენტები მოძრაობენ გვერდთან ერთად მანამ, სანამ არ მიაღწევენ განსაზღვრულ პოზიციას; Absolute პოზიციას იკავებს უახლოეს მშობელთან(relative)."
    },
    "94": {
      "question": "რატომ შეიძლება უფრო სასურველად ჩავთვალოთ `em` or `rem` ერთეულების გამოყენება პიქსელის(px) მაგივრად CSS-ში?",
      "options": [
      "ადვილია აკრეფა", 
      "ისინი უკეთ მასშტაბირდებიან მომხმარებლის პარამეტრებთან", 
      "უფრო სწრაფად იტვირთება", 
      "მხოლოდ მობილურზე მუშაობს"],
      "level": "<hard>რთული</hard>",
      "correct": "ისინი უკეთ მასშტაბირდებიან მომხმარებლის პარამეტრებთან",
      "explanation": "em და rem არიან მშობლიური ერთეულები, რაც იმას ნიშნავს რომ ისინი ეხმარებიანso რომ შექმნან მეტად ხელმისაწვდომი და ეკრანზე მორგებული დიზაინი."
    },
    "95": {
      "question": "CSS-ში, თუ ელემენტის სიგანეს 100vw-ზე დააყენებთ, რატომ შეიძლება გაჩნდეს ჰორიზონტალური სკროლი?",
      "options": [
        "რადგან vw მოიცავს სკროლის ზოლს",
        "რადგან vw იგნორირებას უკეთებს padding-ს",
        "რადგან vw ეფუძნება მშობელ კონტეინერს",
        "რადგან vw ნაგულისხმევად მოიცავს margin-ს"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "რადგან vw მოიცავს სკროლის ზოლს",
      "explanation": "`vw` ერთეული ეფუძნება მთელ viewport-ის სიგანეს, მათ შორის იმ სივრცეს, რომელსაც ვერტიკალური სკროლის ზოლი იკავებს. სისტემებზე, სადაც სკროლის ზოლი იკავებს ადგილს, 100vw შეიძლება ოდნავ უფრო ფართო იყოს ხილულ არეზე, რაც იწვევს გადავსებას და ჰორიზონტალური სკროლის გაჩენას."
    },
    "96": {
      "question": "რა შედეგს იძლევა `flex: 1` flex კონტეინერში?",
      "options": [
      "აკლებს ელემენტის ზომას", 
      "ზრდის ელემენტს და ავსებს თავისუფალ სივრცეს", 
      "ამწკრივებს მარცხნივ", 
      "აფიქსირებს ზომას"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ზრდის ელემენტს და ავსებს თავისუფალ სივრცეს",
      "explanation": "`flex: 1` აძლევს ელემენტს უფლებას გაიზარდოს და თანაბრად შეავსოს თავისუფალი სივრცე სხვა ელემენტებთან ერთად."
    },
    "97": {
      "question": "ხშირ შემთხვევაში, უფრო რთული განლაგებებისთვის რატომ ამჯობინებენ ხოლმე დეველოპერები Grid-ს ვიდრე Flexbox-ს CSS-ში ?",
      "options": [
        "რადგან Grid-ს შეუძლია ელემენტების ერთდროულად განლაგება როგორც რიგებში, ასევე სვეტებში",
        "რადგან Grid ავტომატურად ავსებს HTML-ს ჩვენთვის",
        "რადგან Grid უფრო სწრაფად იტვირთება, ვიდრე Flexbox-ი",
        "იმიტომ რომ Grid-ი უფრო სწრაგად მუშაობს CSS-ის გარეშე"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "რადგან Grid-ს შეუძლია ელემენტების ერთდროულად განლაგება როგორც რიგებში, ასევე სვეტებში",
      "explanation": "Flexbox-ი ერთგანზომილებიანია, იგი შექმნილია ერთ რიგში ან სვეტში ელემენტების განლაგებისთვის. CSS Grid-ი კი ორ განზომილებიანია, რაც იმას ნიშნავს რომ იგი საშუალებას გვაძლევს ელემენტები ერთდროულად როგორც რიგებში, ასევე სვეტებში განვათავსოთ, რაც იდეალურს ხდის რთული გვერდის სტრუქტურებისთვის."
    },
    "98": {
      "question": "რისთვის შეიქმნა CSS-ის box model (ბლოკის მოდელი)?",
      "options": [
        "JavaScript ფუნქციების დასაწერად",
        "3D ფიგურების შესაქმნელად",
        "Padding-ის, border-ის და margin-ის სამართავად",
        "მხოლოდ ტექსტის გასაფორმებლად"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "Padding-ის, border-ის და margin-ის სამართავად",
      "explanation": "Box model განსაზღვრავს როგორ ითვლება სივრცე ელემენტის გარშემო padding, border და margin-ის გამოყენებით."
    },
    "99": {
      "question": "რა მოხდება თუ ელემენტს ექნება ორივე თვისება: `display: none` და `visibility: hidden` მინიჭებული?",
      "options": [
        "ერთმანეთს უქმებენ",
        "ელემენტი უფრო ხილული ხდება",
        "მხოლოდ `display: none` მუშაობს",
        "ელემენტი ფიქსირებული ხდება"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მხოლოდ `display: none` იმუშავებს",
      "explanation": "`display: none` სრულად აშორებს ელემენტს განლაგებიდან, ხოლო `visibility: hidden` მხოლოდ უხილავს ხდის ტექსტს, თუმცა იგი ტოვებს სივრცეს."
    },
    "100": {
      "question": "რა განსხვავებაა სემანტიკურ და არასემანტიკურ HTML ტეგებს შორის?",
      "options": [
        "`<div>` სემანტიკურია, `<section>` არა",
        "სემანტიკური ტეგები აღწერენ მნიშვნელობასა და სტრუქტურას",
        "არასემანტიკური ტეგები მოძველებულია",
        "განსხვავება არ არსებობს"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "სემანტიკური ტეგები აღწერენ მნიშვნელობასა და სტრუქტურას",
      "explanation": "სემანტიკური ტეგები, როგორიცაა `<article>`, `<header>`, `<nav>` უკეთ ეხმარება ბრაუზერსა და საძიებო სისტემებს კონტენტის გაგებაში და თანამშრომლობენწვდომების გაუმჯობესებაში(თანამშრომლობენ SEO-სთან)."
    },
    "101": {
      "question": "ვებ პროგრამირებაში, რას წარმოადგენს SEO და რატომ არის იგი ასე მნიშვნელოვანი?",
      "options": [
        "საძიებო სისტემის ოპტიმიზაცია(SEO) არსებობს რომ გაუმჯობესდეს საიტის ხილვადობა და უფრო მარტივად საპოვნელს ხდის გვერდს",
        "ელ.ფოსტის უსაფრთხო ოპერაციები(SEO) - არის მომხმარებლის შეტყობინებების დასაცავად",
        "სისტემის შეცდომის შედეგი(SEO) - გამოიყენება აპლიკაციების გამართვისთვის",
        "სერვერის საბოლოო წერტილის ოპერაცია(SEO) - API მოთხოვნების დასამუშავებლად"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "საძიებო სისტემის ოპტიმიზაცია(SEO) არსებობს რომ გაუმჯობესდეს საიტის ხილვადობა, იგი უფრო მარტივად საპოვნელს ხდის გვერდს",
      "explanation": "SEO (საძიებო სისტემის ოპტიმიზაცია) ეს ვებსაიტის გაუმჯობესების პრაქტიკაა, რათა საძიებო სისტემები მას უფრო მაღალ რეიტინგში აყენებდნენ. სოლიდური SEO ეხმარება უფრო მეტ ხალს აღმოაჩინონ შენი ვებგვერდი ინტერნეტში ძიების დროს."
    }
  },
  "javascript": {
    "1": {
      "question": "რა არის ცვლადი ჯავასკრიპტში და რატომ ვიყენებთ მას?",
      "options": [
        "ის ქმნის ფუნქციებს.",
        "ცვლადს შეგვიძლია მივცეთ მნიშვნელობა ან უნიკალური სახელი.",
        "ჩვენ არ ვიყენებთ ცვლადებს ჯავასკრიპტში.",
        "ის შეიცავს მომხმარებლის ინფორმაციას."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ცვლადს შეგვიძლია მივცეთ მნიშვნელობა ან უნიკალური სახელი.",
      "explanation": "ცვლადები ჰგავან კონტეინერს რადგან მასში ვინახავთ ღირებულებებს. ჯავასკრიპტში ჩვენ ვიყენებთ let, const ან var(არაა რეკომენდირებული მისი გამოყენება)."
    },
    "2": {
      "question": "რა განსხვავებაა const-სა და let-ს შორის?",
      "options": [
        "const-ის შეცვლა არაა დაშვებული როდესაც, let-ის გარდაქმნა დაშვებულია.",
        "let-ი გამოიყენება მხოლოდ ფუნქციებს შიგნით.",
        "const-ი გაცილებით უფრო სწრაფია ვიდრე let-ი",
        "მათ შორის არანაირი სხვაობა არაა."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "const-ის შეცვლა არაა დაშვებული როდესაც, let-ის გარდაქმნა დაშვებულია.",
      "explanation": "როდესაც ვიყენებთ კონსტანტას(const) ჩვენ არ შეგვიძლია მისი ღირებულების შეცვლა(გარდაქმნა), ხოლო let-ის განახლება დასაშვებია."
    },
    "3": {
      "question": "რას წარმოადგენს var-ი ჯავასკრიპტში?",
      "options": [
        "ისაა const-ის თანამედროვე ჩამნაცვლებელი ხელსაწყო.",
        "ისაა ძველი მეთოდი ცვლადის დეკლარაციისთვის.",
        "ისაა მუდმივი ცვლადი, რომელიც არასოდეს შეიცვლება.",
        "ის გამოიყენება მხოლოდ მასივების განსასაზღვრად."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ისაა ძველი მეთოდი ცვლადის დეკლარაციისთვის.",
      "explanation": "ES6-ის შემოსვლამდე, var იყო მთავარი და ერთადერთი გზა ცვლადის შესაქმნელად, მას აქვს ფუნქციის ფარგლები, Let-ისა და Const-ისგან განსხვავებით, რომლებსაც აქვთ ბლოკის ფარგლები."
    },
    "4": {
      "question": "შეგვიძლია თუ არა ჩვენ ცვლადების გამოცხადება ფუნქციებში?",
      "options": [
        "არა, ცვლადების შემოტანა მხოლოდ გლობალურადაა დასაშვები.",
        "დიახ, ცვლადების გამოცხადება დასაშვებია ფუნქციებში.",
        "მხოლოდ const-ტიპის ცვლადები შეიძლება იყოს გამოყენებული ფუნქციებში.",
        "ცვლადები უნდა გამოცხადდენ გარეთ(ფუნქციის) და შემდეგ გამოყენებულ იქნას შიგნით(ფუნქციაში)."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "დიახ, ცვლადების გამოცხადება შესაძლებელია ფუნქციებში",
      "explanation": "ფუნქციებს შუძლიათ ჰქონდეთ თავიანთი ცვლადები, რომლებიც არ იკითხება მათ გარეთ(ფუნქციას შეუძლია გამოიყენოს გარეთ განთავსებული ცვლადი)."
    },
    "5": {
      "question": "რას წარმოადგენს ფუნქციის დეკლარაცია ჯავასკრიტში?",
      "options": [
        "ფუნქციის გამოცხადების გზა ფუნქციის საკვანძო სიტყვის გამოყენებით.",
        "ცვლადი, რომელიც ინახავს ფუნქციას.",
        "ფუნქციის დეკლარაცია შექმნილია ავტომატურად.",
        "ისაა მეთოდი რომელიც გამოიყენება მხოლოდ კლასებში."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ფუნქციის გამოცხადების გზა ფუნქციის საკვანძო სიტყვის გამოყენებით",
      "explanation": "ფუნქციის დეკლარაცია (const car = function() {return your code}), იწყება ფუნქციის საკვანძო სიტყვით და მისი გამოძახება შესაძლებელია მის განსაზღვრამდეც კი, ამწევი ფუნქციის გამო."
    },
    "6": {
      "question": "რას წარმოადგენს ისრის ფუნქცია ჯავასკრიტში?",
      "options": [
        "ის წარმოადგენს მრავალი ფუნქციის გაერთიანებულ სახეობას.",
        "ისაა ფუნქციის ტიპი, რომელსაც აქვს თავისი განმასხვავებელი უნარები.",
        "ფუნქცია, რომელიც მხოლოდ მასივებთან მუშაობს.",
        "ეს არის ფუნქცია, რომელსაც არ შეუძლია მნიშვნელობების დაბრუნება."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ისაა ფუნქციის ტიპი, რომელსაც აქვს თავისი განმასხვავებელი უნარები.",
      "explanation": "ისრის ფუნქცია გამოიყურება ამგვარად: const arrow = () => {}, ის აბრუნებს ღირებულებებს ავტომატურად რაც იმას ნიშნავს რომ იგი არ საჭიროებს return-სიტყვის გამოყენებას. თუმცა მას არ გააჩნია თავისი this გასაღები სიტყვა, რაც მათ ფუნქციონირებას განსხვავებულს ხდის ჩვეულებრივისგან."
    },
    "7": {
      "question": "რა განსხვავებაა ფუნქციის დეკლარაციასა და ისრის ფუნქციას შორის?",
      "options": [
        "ფუნქციის დეკლარაცია გამოიყენება გლობალურად, ისრისებრი ფუნქციები - არა.",
        "ისრის ფუნქციები დეკლარაციაზე უფრო სწრაფია.",
        "ისინი ერთნაირები არიან, არააქვთ სხვაობა.",
        "ისრის ფუნქციებს არ შეუძლია პარამეტრების ქონა."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ფუნქციის დეკლარაცია გამოიყენება გლობალურად, ისრისებრი ფუნქციები - არა.",
      "explanation": "ფუნქციის დეკლარირება იყენებს `function` საკვანძო სიტყვას, და ხდება მისი აწევა(„აწევა“ ნიშნავს, რომ ჯავასკრიფტს შინაგანად გადააქვს ფუნქციის დეკლარაცია კომპილაციის დროს ზედა ნაწილში(თავში)), ამიტომ მათი გამოძახება მოქნილია. ისრის ფუნქცია იყენებს `=>`-ს ფუნქცია სიტყვის მაგიერ, მას არ აქვს საკუთარი `this`, მას შეუძლია მნიშვნელობების ავტომატურად დაბრუნება ერთი გამოსახულების სახით."
    },
    "8": {
      "question": "რას აკეთებს Math.random() ფუნქცია JavaScript-ში?",
      "options": [
        "იგი აბრუნებს შემთხვევითად არჩეულ ციფრს 0-დან 1-ის ჩათვლით.",
        "იგი აბრუნებს შემთხვევითად არჩეულ ციფრს 0-დან 100-ის ჩათვლით.",
        "იგი აგენერირებს მხოლოდ შემთხვევით მთელ რიცხვების",
        "იგი შემთხვევითობის პრინციპით ირჩევს მასივის ელემენტს."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "იგი აბრუნებს შემთხვევითად არჩეულ ციფრს 0-დან 1-ის ჩათვლით.",
      "explanation": "Math.random()-ი აგენერირებს მცურავ-წერტილოვან რიცხვს 0-იდან (inclusive; 0.1,0.99...) 1-ამდე (exclusive)."
    },
    "9": {
      "question": "როგორ მუშაობს Math.floor()-ი?",
      "options": [
        "იგი ამრგვალებს ციფრს დაბლა, ყველაზე ახლო ციფრამდე.",
        "იგი ამრგვალებს ციფრს მაღლა, ყველაზე ახლო ციფრამდე.",
        "იგი აბრუნებს ყველაზე დიდ ციფრს.",
        "იგი აშორებს ათწილადებს, მაგრამ არ ამრგვალებს ციფრებს."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "იგი ამრგვალებს ციფრს დაბლა, ყველაზე ახლო ციფრამდე.",
      "explanation": "Math.floor() ყოველთვის ამრგვალებს ციფრს ახლო დაბალ ციფრამდე(აშორებს ათწილად ნაწილს), მაგ: გვაქვს 1.99, ჩვენ შედეგად მივირებთ 1-ს."
    },
    "10": {
      "question": "რას შვება Math.max()?",
      "options": [
        "იგი აბრუნებს ყველაზე პატარა ღირებულების ციფრს.",
        "იგი ეძებს ყველაზე დიდ ციფრს მოცემული სიიდან(მაგ: მასივიდან).",
        "მისი წყალობით ხდება ციფრების დამრგვალება.",
        "იგი აგენერირებს შემთხვევით ციფრებს."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "იგი ეძებს ყველაზე დიდ ციფრს მოცემული სიიდან(მაგ: მასივიდან).",
      "explanation": "Math.max() აბრუნებს ყველაზე მაღალი ღირებულების მქონე ციფრს მასში,(მასივიდან)."
    },
    "11": {
      "question": "რა არის Math, JavaScript-ში და რაში გვჭირდება ის?",
      "options": [
        "ბიბლიოთეკა რიცხვებთან და გამოთვლებთან სამუშაოდ",
        "ცვლადების შესაქმნელი გზა",
        "სპეციალური ტიპის ციკლი",
        "გამოიყენება მასივების შესაქმნელად"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ბიბლიოთეკა რიცხვებთან და გამოთვლებთან სამუშაოდ",
      "explanation": "Math() არის ჯავასკრიფტში ჩაშენებული ობიექტი, რომელიც უზრუნველყოფს გამოთვლების მეთოდებს, როგორიცაა შემთხვევითი რიცხვები, დამრგვალება და ხარისხები."
    },
    "12": {
      "question": "რას აკეთებს Math.min() JavaScript-ში?",
      "options": [
        "პოულობს ყველაზე პატარა რიცხვს მოწოდებულებიდან",
        "პოულობს ყველაზე დიდ რიცხვს",
        "ამრგვალებს რიცხვს ქვემოთ",
        "გენერირებს შემთხვევით რიცხვს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "პოულობს ყველაზე პატარა რიცხვს მოწოდებულებიდან",
      "explanation": "Math.min() აბრუნებს მოწოდებული არგუმენტებიდან ყველაზე დაბალ მნიშვნელობას."
    },
    "13": {
      "question": "რას დააბრუნებს: Math.pow(2, 3)",
      "options": [
        "6",
        "8",
        "9",
        "5"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "8",
      "explanation": "Math.pow(x, y) აბრუნებს x-ს y ხარისხში აყვანილს. ამგვარად, 2³ = 8."
    },
    "14": {
      "question": "რას დააბრუნებს Math.sqrt(25)?",
      "options": [
        "5",
        "25",
        "2.5",
        "10"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "5",
      "explanation": "Math.sqrt(n) აბრუნებს რიცხვის კვადრატულ ფესვს. 25-ის კვადრატული ფესვი 5-ის ტოლია."
    },
    "15": {
      "question": "რას დააბრუნებს Math.round(4.6)?",
      "options": [
        "4",
        "5",
        "4.5",
        "6"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "5",
      "explanation": "Math.round() ამრგვალებს რიცხვს უახლოეს მთელ რიცხვამდე. 4.6 ამრგვალებს 5-მდე."
    },
    "16": {
      "question": "რას დააბრუნებს Math.ceil(4.2)?",
      "options": [
        "4",
        "5",
        "4.5",
        "2"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "5",
      "explanation": "Math.ceil() ყოველთვის ამრგვალებს რიცხვს უახლოეს მთელ რიცხვამდე."
    },
    "17": {
      "question": "რას აკეთებს = ოპერატორი JavaScript-ში?",
      "options": [
        "ადარებს ორ მნიშვნელობას",
        "მინიჭებს მნიშვნელობას ცვლადს",
        "ამოწმებს ტოლობას ტიპის გათვალისწინებით",
        "ამოწმებს ტოლობას ტიპის გარეშე"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "მინიჭებს მნიშვნელობას ცვლადს",
      "explanation": "ერთჯერადი = არის მინიჭების ოპერატორი, რომელიც გამოიყენება ცვლადში მნიშვნელობის შესანახად."
    },
    "18": {
      "question": "რა განსხვავებაა == და ===-ს შორის JavaScript-ში?",
      "options": [
        "== ამოწმებს მხოლოდ მნიშვნელობას, === ამოწმებს მნიშვნელობას და ტიპს",
        "ორივე ზუსტად ერთნაირია",
        "=== მუშაობს მხოლოდ რიცხვებთან",
        "== მუშაობს მხოლოდ სტრინგებთან"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "== ამოწმებს მხოლოდ მნიშვნელობას, === ამოწმებს მნიშვნელობას და ტიპს",
      "explanation": "== ადარებს მნიშვნელობებს ტიპის კონვერტაციით, ხოლო === მკაცრად ამოწმებს როგორც მნიშვნელობას, ასევე ტიპს."
    },
    "19": {
      "question": "რას აკეთებს != ოპერატორი?",
      "options": [
        "ამოწმებს არის თუ არა ორი მნიშვნელობა ტოლი",
        "ამოწმებს არის თუ არა ორი მნიშვნელობა განსხვავებული",
        "მინიჭებს მნიშვნელობას",
        "გარდაქმნის რიცხვად"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ამოწმებს არის თუ არა ორი მნიშვნელობა განსხვავებული",
      "explanation": "!= აბრუნებს true-ს, თუ მნიშვნელობები განსხვავებულია, false-ს, თუ ისინი ერთნაირია."
    },
    "20": {
      "question": "რას აკეთებს += ოპერატორი JavaScript-ში?",
      "options": [
        "აკლებს და ანიჭებს მნიშვნელობას",
        "ამატებს მნიშვნელობას ცვლადს და ანიჭებს მას",
        "ამრავლებს მნიშვნელობებს",
        "ადარებს ორ რიცხვს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ამატებს მნიშვნელობას ცვლადს და ანიჭებს მას",
      "explanation": "x += y ნიშნავს x = x + y. ეს შეკრებისა და ხელახლა მინიჭების შემოკლებული ფორმაა."
    },
    "21": {
      "question": "რას აკეთებს -= ოპერატორი JavaScript-ში?",
      "options": [
        "ამატებს მნიშვნელობას ცვლადს",
        "აკლებს მნიშვნელობას ცვლადიდან და ანიჭებს მას",
        "ყოფს მნიშვნელობებს",
        "ამოწმებს ტოლობას"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "აკლებს მნიშვნელობას ცვლადიდან და ანიჭებს მას",
      "explanation": "x -= y ნიშნავს, რომ x = x - y. ის აკლებს y-ს x-ს და შედეგს უბრუნებს."
    },
    "22": {
      "question": "რას აკეთებს *= ოპერატორი?",
      "options": [
        "ამატებს ორ რიცხვს",
        "ამრავლებს ცვლადს მნიშვნელობაზე და ანიჭებს მას",
        "ამოწმებს განსხვავებულობას",
        "ყოფს და ანიჭებს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ამრავლებს ცვლადს მნიშვნელობაზე და ანიჭებს მას",
      "explanation": "x *= y ნიშნავს x = x * y. ის მრავლდება და ხელახლა ანაწილებს."
    },
    "23": {
      "question": "რას აკეთებს /= ოპერატორი?",
      "options": [
        "ყოფს ცვლადს მნიშვნელობაზე და ანიჭებს მას",
        "ამრავლებს ცვლადს",
        "ამოწმებს მკაცრ ტოლობას",
        "ამატებს რიცხვებს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ყოფს ცვლადს მნიშვნელობაზე და ანიჭებს მას",
      "explanation": "x /= y ნიშნავს x = x / y. ის ყოფს და ხელახლა ანაწილებს."
    },
    "24": {
      "question": "რას აკეთებს % ოპერატორი JavaScript-ში?",
      "options": [
        "აბრუნებს ნაშთს გაყოფის შემდეგ",
        "აბრუნებს რიცხვის პროცენტს",
        "ამატებს ათწილადებს",
        "ამრგვალებს ქვემოთ"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "აბრუნებს ნაშთს გაყოფის შემდეგ",
      "explanation": "x % y აბრუნებს ნაშთს x-ის y-ზე გაყოფის შემდეგ. მაგალითი: 10 % 3 = 1."
    },
    "25": {
      "question": "რას აბრუნებს Math.abs(-7)?",
      "options": [
        "-7",
        "7",
        "0",
        "NaN"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "7",
      "explanation": "Math.abs() აბრუნებს რიცხვის აბსოლუტურ (დადებით) მნიშვნელობას."
    },
    "26": {
      "question": "რას აბრუნებს Math.trunc(4.9)?",
      "options": [
        "4",
        "5",
        "4.9",
        "0"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "4",
      "explanation": "Math.trunc() ფუნქცია რიცხვის ათწილად ნაწილს დამრგვალების გარეშე შლის."
    },
    "27": {
      "question": "რას წარმოადგენს Math.PI JavaScript-ში?",
      "options": [
        "3.14 (π-ს მნიშვნელობა)",
        "უდიდესი მთელი რიცხვი",
        "უსასრულობა",
        "ორეულის კვადრატული ფესვი"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "3.14 (π-ს მნიშვნელობა)",
      "explanation": "Math.PI იძლევა π-ს (pi) მნიშვნელობას, დაახლოებით 3.14159-ს."
    },
    "28": {
      "question": "რა არის NaN JavaScript-ში?",
      "options": [
        "არ არის რიცხვი (არასწორი მათემატიკის შედეგი)",
        "Null მნიშვნელობა",
        "ცვლადის ტიპი",
        "უსასრულობა"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "არ არის რიცხვი (არასწორი მათემატიკის შედეგი)",
      "explanation": "NaN ნიშნავს „რიცხვი არ არის“. მაგალითად: 0/0-ის გაყოფით NaN-ს ვიღებთ."
    },
    "29": {
      "question": "რა არის უსასრულობა(infinity) JavaScript-ში?",
      "options": [
        "ძალიან დიდი რიცხვი",
        "სპეციალური მნიშვნელობა, რომელიც ყველა რიცხვზე დიდია",
        "იგივე undefined",
        "მასივის ტიპი"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "სპეციალური მნიშვნელობა, რომელიც ყველა რიცხვზე დიდია",
      "explanation": "უსასრულობა წარმოადგენს მნიშვნელობას, რომელიც უფრო დიდია, ვიდრე JavaScript-ში შესაძლო უდიდესი რიცხვი."
    },
    "30": {
      "question": "რას აკეთებს typeof ოპერატორი?",
      "options": [
        "ამოწმებს მნიშვნელობის ტიპს",
        "ამოწმებს არის თუ არა მნიშვნელობები ტოლი",
        "ქმნის ახალ ცვლადს",
        "ამრგვალებს რიცხვებს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ამოწმებს მნიშვნელობის ტიპს",
      "explanation": "typeof აბრუნებს მნიშვნელობის მონაცემთა ტიპს. მაგალითად: typeof 5 არის „რიცხვი“."
    },
    "31": {
      "question": "რა არის ფანჯრის ობიექტი(window) JavaScript-ში?",
      "options": [
        "წარმოადგენს ბრაუზერის ფანჯარას და შეიცავს ჩაშენებულ მეთოდებს",
        "ცვლადების გამოცხადების გზა",
        "გამოიყენება მხოლოდ მასივებისთვის",
        "ფუნქციის დეკლარაციაა"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "წარმოადგენს ბრაუზერის ფანჯარას და შეიცავს ჩაშენებულ მეთოდებს",
      "explanation": "ფანჯრის ობიექტი ბრაუზერებში გლობალური ობიექტია. ის წარმოადგენს ბრაუზერის ფანჯარას და შეიცავს ისეთ მეთოდებს, როგორიცაა alert, prompt და confirm."
    },
    "32": {
      "question": "რას აკეთებს window.alert() ფუნქცია?",
      "options": [
        "აჩვენებს შეტყობინების ფანჯარას",
        "მომხმარებელს სთხოვს შეყვანას",
        "ხურავს ბრაუზერს",
        "გარდაქმნის მნიშვნელობას სტრიქონად"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "აჩვენებს შეტყობინების ფანჯარას",
      "explanation": "window.alert() აჩვენებს მარტივ შეტყობინების ფანჯარას შეტყობინებით."
    },
    "33": {
      "question": "რას აკეთებს window.prompt() ფუნქცია?",
      "options": [
        "აჩვენებს ფანჯარას ტექსტის შესაყვანად",
        "აჩვენებს გაფრთხილების შეტყობინებას",
        "ავტომატურად ასრულებს ფუნქციას",
        "გარდაქმნის რიცხვებს სტრიქონებად"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "აჩვენებს ფანჯარას ტექსტის შესაყვანად",
      "explanation": "window.prompt() აჩვენებს დიალოგურ ფანჯარას, რომელიც მომხმარებელს სთხოვს შეყვანის მონაცემებს და აბრუნებს მათ სტრიქონის სახით."
    },
    "34": {
      "question": "რას აბრუნებს window.confirm() ფუნქცია?",
      "options": [
        "ყოველთვის სტრიქონს",
        "true თუ დააჭირეს OK-ს, false თუ დააჭირეს Cancel-ს",
        "ყოველთვის რიცხვს",
        "არაფერს არ აბრუნებს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "true თუ დააჭირეს OK-ს, false თუ დააჭირეს Cancel-ს",
      "explanation": "window.confirm() აჩვენებს დიალოგურ ფანჯარას OK/Cancel ღილაკებით და აბრუნებს ლოგიკურ მნიშვნელობას."
    },
    "35": {
      "question": "როგორ გადავიყვანოთ JavaScript-ში სტრიქონი '123' რიცხვად?",
      "options": [
        "Number('123')",
        "String('123')",
        "Boolean('123')",
        "parseString('123')"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "Number('123')",
      "explanation": "სტრიქონის რიცხვად გადაკეთება შეგვიძლია Number()-ის ან parseInt()-ის გამოყენებით. მაგალითი: Number('123') → 123."
    },
    "36": {
      "question": "როგორ გადავიყვანოთ რიცხვი 0 ლოგიკურ რიცხვად(boolean)?",
      "options": [
        "Boolean(0)",
        "Number(0)",
        "String(0)",
        "parseInt(0)"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "Boolean(0)",
      "explanation": "Boolean(0) აბრუნებს false-ს, ხოლო Boolean(1) აბრუნებს true-ს."
    },
    "37": {
      "question": "რას აბრუნებს String(123)?",
      "options": [
        "123 როგორც რიცხვი",
        "'123' როგორც სტრიქონი",
        "true",
        "NaN"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "'123' როგორც სტრიქონი",
      "explanation": "String() გარდაქმნის მნიშვნელობებს სტრიქონებად. მაგალითი: String(123) → '123'."
    },
    "38": {
      "question": "რისთვის გამოიყენება if ოპერატორი JavaScript-ში?",
      "options": [
        "კოდის ბევრჯერ გამეორებისთვის",
        "ახალი ცვლადების შესაქმნელად",
        "გადაწყვეტილებების მისაღებად პირობებზე დაყრდნობით",
        "შეტყობინების ფანჯრის გამოსატანად"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "გადაწყვეტილებების მისაღებად პირობებზე დაყრდნობით",
      "explanation": "if ოპერატორი კოდს მხოლოდ იმ შემთხვევაში ასრულებს, თუ პირობა მართალია."
    },
    "39": {
      "question": "რას აკეთებს else ოპერატორი?",
      "options": [
        "ასრულებს კოდს მხოლოდ მაშინ, როცა if პირობა ჭეშმარიტია",
        "ასრულებს კოდს მაშინ, როცა if პირობა ცრუა",
        "ასრულებს პროგრამას",
        "აცხადებს ცვლადს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ასრულებს კოდს მაშინ, როცა if პირობა ცრუა",
      "explanation": "else ბლოკი სრულდება, როდესაც if პირობა არ არის ჭეშმარიტი."
    },
    "40": {
      "question": "რომელია if...else- ოპერატორის სწორი სინტაქსი?",
      "options": [
        "if (პირობა) { კოდი } else { კოდი }",
        "if პირობა then კოდი else კოდი",
        "if { პირობა } else { კოდი }",
        "if (პირობა) => else { კოდი }"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "if (პირობა) { კოდი } else { კოდი }",
      "explanation": "სწორი სინტაქსია: if(პირობა){ ... } else { ... }."
    },
    "41": {
      "question": "რა მოხდება, თუ if ოპერატორში პირობა მცდარია?",
      "options": [
        "if ბლოკში არსებული კოდი შესრულდება",
        "if ბლოკში არსებული კოდი გამოტოვებულია",
        "პროგრამა სრულად შეჩერდება",
        "ყოველთვის გაეშვება else ბლოკი"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "if ბლოკში არსებული კოდი გამოტოვებულია",
      "explanation": "თუ პირობა მცდარია, if ბლოკში არსებული კოდი იგნორირებულია."
    },
    "42": {
      "question": "შეუძლია თუ არა if ოპერატორს ჰქონდეს რამდენიმე else if ბლოკი?",
      "options": [
        "კი, შეგიძლიათ გამოიყენოთ else if მრავალი პირობისთვის",
        "არა, მხოლოდ ერთი else არის დაშვებული",
        "კი, მაგრამ მხოლოდ switch-თან ერთად",
        "არა, JavaScript ამას არ იძლევა"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "კი, შეგიძლიათ გამოიყენოთ else if მრავალი პირობისთვის",
      "explanation": "შეგიძლიათ რამდენიმე „else if“ ბლოკი ჯაჭვურად დააკავშიროთ რამდენიმე პირობის შესამოწმებლად."
    },
    "43": {
      "question": "რა მოხდება, თუ if ან else if პირობებიდან არცერთი არ არის ჭეშმარიტი, მაგრამ else არსებობს?",
      "options": [
        "else ბლოკი გაეშვება",
        "არაფერი მოხდება",
        "პროგრამა დაიშლება",
        "პირველი პირობა მაინც გაეშვება"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "else ბლოკი გაეშვება",
      "explanation": "თუ არცერთი პირობა არ არის ჭეშმარიტი, else ბლოკი გაიშვება, როგორც ნაგულისხმევი ვარიანტი."
    },
    "44": {
      "question": "რა არის ternary ოპერატორი JavaScript-ში?",
      "options": [
        "ოპერატორი, რომელიც ციკლებს უშვებს",
        "მოკლე ჩანაწერი if...else-ისთვის",
        "ფუნქციების გამოცხადების გზა",
        "switch ბრძანების ტიპი"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "მოკლე ჩანაწერი if...else-ისთვის",
      "explanation": "ternary ოპერატორი იყენებს პირობას ? value1 : value2, როგორც მალსახმობს if...else-ისთვის."
    },
    "45": {
      "question": "რას დაგვიბრუნებს გამოსახულება (5 > 3 ? 'დიახ' : 'არა'), შედეგად?",
      "options": [
        "'დიახ'",
        "'არა'",
        "true",
        "false"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "'დიახ'",
      "explanation": "რადგან 5 > 3 მართალია, ternary ოპერატორი აბრუნებს 'დიახ'-ს."
    },
    "46": {
      "question": "რისთვის გამოიყენება switch ოპერატორი?",
      "options": [
        "მრავალი შესაძლო შემთხვევიდან კოდის გასაშვებად",
        "ცვლადების შესაცვლელად",
        "კოდის გასამეორებლად",
        "მასივების გამოსაცხადებლად"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "მრავალი შესაძლო შემთხვევიდან კოდის გასაშვებად",
      "explanation": "გადამრთველი(switch) ამოწმებს მნიშვნელობას მრავალი შემთხვევის მიმართ და გაუშვებს შესაბამისს."
    },
    "47": {
      "question": "რომელი საკვანძო სიტყვა გამოიყენება switch, case-ში შესრულების შესაჩერებლად?",
      "options": [
        "exit",
        "break",
        "stop",
        "return"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "break",
      "explanation": "break ოპერატორი აჩერებს switch-ის შემდეგ შემთხვევაზე გაშვებას."
    },
    "48": {
      "question": "რა მთავარი განსხვავება if...else-სა და switch-ს შორის?",
      "options": [
        "if...else ამოწმებს მრავალ პირობას, switch ამოწმებს ერთ მნიშვნელობას შემთხვევებთან",
        "switch ყოველთვის უფრო სწრაფია ვიდრე if...else",
        "if...else ვერ ადარებს რიცხვებს",
        "ისინი ზუსტად ერთნაირია"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "if...else ამოწმებს მრავალ პირობას, switch ამოწმებს ერთ მნიშვნელობას შემთხვევებთან",
      "explanation": "if...else პირობებისთვისაა, ხოლო switch ადარებს ერთ მნიშვნელობას სხვადასხვა შემთხვევებს."
    },
    "49": {
      "question": "როდის უნდა გამოვიყენოთ ternary-ი ოპერატორი, if...else-ის ნაცვლად?",
      "options": [
        "როცა გვჭირდება მოკლე ერთსტრიქონიანი გადაწყვეტილება",
        "როცა გვინდა ბევრ შემთხვევასთან შედარება",
        "როცა გვჭირდება ციკლები",
        "ცვლადების გამოცხადებისას"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "როცა გვჭირდება მოკლე ერთსტრიქონიანი გადაწყვეტილება",
      "explanation": "ternary ოპერატორი საუკეთესოა სწრაფი, მარტივი პირობებისთვის. რთული ლოგიკისთვის გამოიყენება if...else."
    },
    "50": {
      "question": "რა მთავარი განსხვავებებია: if...else-ს, ternary-სა და switch-ს შორის?",
      "options": [
        "if...else ამუშავებს პირობებს, ternary არის if...else-ის მოკლე ჩანაწერი, ხოლო switch ამოწმებს ერთ მნიშვნელობას მრავალ ვარიანტთან",
        "სამივე ზუსტად ერთნაირია",
        "Ternary ყოველთვის უფრო სწრაფია ვიდრე switch",
        "Switch მუშაობს მხოლოდ რიცხვებთან"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "if...else ამუშავებს პირობებს, ternary არის if...else-ის მოკლე ჩანაწერი, ხოლო switch ამოწმებს ერთ მნიშვნელობას მრავალ ვარიანტთან",
      "explanation": "თითოეულს თავისი გამოყენება აქვს: if...else პირობებისთვის, ternary მოკლე გამოსახულებებისთვის და switch მრავალი ზუსტი დამთხვევისთვის."
    },
    "51": {
      "question": "ჯავასკრიპტში, შეგვიძლია თუ არა რომ გამოვიყენოთ ternary-ი ოპერატორი if/else და switch-ის მსგავსად,(ჩავსვათ მასში ბევრი ვარიანტი)?",
      "options": [
        "კი, მაგრამ ეს კოდის წაკითხვას ართულებს",
        "არა, მხოლოდ ერთი ternary არის დაშვებული",
        "კი, და ეს ყოველთვის უფრო სწრაფია ვიდრე if...else",
        "არა, ეს ყოველთვის გამოიტანს შეცდომას"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "კი, მაგრამ ეს კოდის წაკითხვას ართულებს",
      "explanation": "შეგიძლიათ რამდენიმე სამოპერატორის ჯაჭვურად დაკავშირება მრავალი პირობის დასამუშავებლად, თუმცა გრძელი ჯაჭვები კოდის წაკითხვას ართულებს."
    },
    "52": {
      "question": "რა შეიძლება იყოს ternary ოპერატორის ჯაჭვურად გაერთიანების შესაძლო უარყოფითი მხარე?",
      "options": [
        "ეს კოდს უფრო ნელა აყენებს მუშაობას",
        "ეს კოდს დამაბნეველსა და რთულად წასაკითხად აქცევს",
        "ეს თანამედროვე JavaScript-ში არ არის მხარდაჭერილი",
        "ეს ყოველთვის იწვევს უსასრულო ციკლს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ეს კოდს დამაბნეველსა და რთულად წასაკითხად აქცევს",
      "explanation": "მიუხედავად იმისა, რომ სამმაგი ოპერატორები სასარგებლოა, მათი ზედმეტად ჯაჭვურად დაკავშირებამ შეიძლება ლოგიკა ნაკლებად ნათელი გახადოს if...else-თან ან switch-თან შედარებით."
    },
    "53": {
      "question": "როგორ შეუძლია ternary ოპერატორს ციკლების ან განმეორებადი პირობების სიმულირება?",
      "options": [
        "პირობების ჯაჭვურად დაკავშირებით, რომლებიც ფუნქციებს განმეორებით იძახებენ",
        "break და continue-ის გამოყენებით",
        "if ოპერატორების ჩადგმით",
        "switch-ში გადაყვანით"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "პირობების ჯაჭვურად დაკავშირებით, რომლებიც ფუნქციებს განმეორებით იძახებენ",
      "explanation": "Ternary ოპერატორების ჯაჭვურად დაკავშირება შესაძლებელია განმეორებით იმის გადასაწყვეტად, თუ რომელი ფუნქცია ან გამოსახულება გამოიძახონ, რითაც ხდება ციკლის მსგავსი ქცევის სიმულირება."
    },
    "54": {
      "question": "რას დააბრუნებს 'Hello World'.lastIndexOf('o')?",
      "options": [
        "4",
        "7",
        "5",
        "-1"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "7",
      "explanation": "lastIndexOf პოულობს სიმბოლოს ბოლო შემთხვევას. „Hello World“-ში ბოლო „o“ მე-7 ინდექსშია."
    },
    "55": {
      "question": "რას დააბრუნებს 'JavaScript'.startsWith('Java')?",
      "options": [
        "true",
        "false",
        "null",
        "undefined"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "true",
      "explanation": "startsWith() ამოწმებს, იწყება თუ არა სტრიქონი მოცემული ქვესტრიქონით. 'JavaScript' იწყება 'Java'-თი."
    },
    "56": {
      "question": "რას დააბრუნებს 'ReactJS'.endsWith('JS')?",
      "options": [
        "ჭეშმარიტია",
        "მცდარია",
        "ნული",
        "განუსაზღვრელი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ჭეშმარიტია",
      "explanation": "endsWith() ამოწმებს, მთავრდება თუ არა სტრიქონი მოცემული ქვესტრიქონით. 'ReactJS' მთავრდება 'JS'-ით."
    },
    "57": {
      "question": "რას დააბრუნებს 'frontend developer'.includes('end')?",
      "options": [
        "ჭეშმარიტია",
        "მცდარია",
        "0",
        "-1"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ჭეშმარიტია",
      "explanation": "includes() ამოწმებს, არსებობს თუ არა ქვესტრიქონი სტრიქონში. „frontend developer“ მოიცავს „end“-ს."
    },
    "58": {
      "question": "რას დააბრუნებს 'JavaScript'.slice(0, 4)?",
      "options": [
        "'Java'",
        "'avaS'",
        "'Script'",
        "'ava'"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "'Java'",
      "explanation": "slice(start, end) სტრიქონის ნაწილს ამოყოფს. ინდექსი 0-დან 4-მდე იძლევა 'Java'-ს."
    },
    "59": {
      "question": "რა განსხვავებაა: slice()-სა და substring()-ს შორის?",
      "options": [
        "slice საშუალებას აძლევს უარყოფით ინდექსებს, substring კი — არა",
        "substring ყოველთვის უფრო სწრაფია",
        "slice მუშაობს მხოლოდ მასივებთან",
        "ისინი ზუსტად ერთნაირია"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "slice საშუალებას აძლევს უარყოფით ინდექსებს, substring კი — არა",
      "explanation": "ორივე სტრიქონის ნაწილებს ამოყოფს, მაგრამ slice() უარყოფით ინდექსებს უჭერს მხარს, ხოლო substring() - არა."
    },
    "60": {
      "question": "რას დააბრუნებს: '   hello world  '.trim()",
      "options": [
        "'hello world'",
        "'  hello world  '",
        "'world'",
        "'hello'"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "'hello world'",
      "explanation": "trim() აშორებს თეთრ სივრცეს სტრიქონის ორივე ბოლოდან."
    },
    "61": {
      "question": "რას დააბრუნებს 'hello'.toUpperCase() ფუნქცია?",
      "options": [
        "'HELLO'",
        "'hello'",
        "'Hello'",
        "შეცდომა"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "'HELLO'",
      "explanation": "toUpperCase()-ი სტრიქონში ყველა სიმბოლოს დიდ ასოდ გარდაქმნის."
    },
    "62": {
      "question": "რას დააბრუნებს: 'WORLD'.toLowerCase()?",
      "options": [
        "'WORLD'",
        "'world'",
        "'World'",
        "undefinied"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "'world'",
      "explanation": "toLowerCase()-ი სტრიქონში ყველა სიმბოლოს პატარა ასოდ გარდაქმნის."
    },
    "63": {
      "question": "რას დააბრუნებს: 'a,b,c'.split(',')?",
      "options": [
        "['a', 'b', 'c']",
        "'a b c'",
        "['abc']",
        "['a','b,c']"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "['a', 'b', 'c']",
      "explanation": "split() მოცემული გამყოფის გამოყენებით სტრიქონს მასივად ყოფს."
    },
    "64": {
      "question": "რა არის მეთოდების ჯაჭვური კავშირი(method chaining) JavaScript-ში?",
      "options": [
        "ერთ ხაზში ერთი და იგივე მნიშვნელობაზე მრავალი მეთოდის გამოძახება",
        "ცვლადების ერთმანეთთან დაკავშირება",
        "მრავალი ციკლის გამოყენება",
        "მასივების გაერთიანება"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ერთ ხაზში ერთი და იგივე მნიშვნელობაზე მრავალი მეთოდის გამოძახება",
      "explanation": "მეთოდების ჯაჭვური დაყოფა გულისხმობს რამდენიმე მეთოდის ერთმანეთის მიყოლებით გამოყენებას. მაგალითად: 'hello'.toUpperCase().split('')."
    },
    "65": {
      "question": "რას დააბრუნებს: 'hello world'.toUpperCase().split(' ')?",
      "options": [
        "['HELLO', 'WORLD']",
        "['hello', 'world']",
        "['HELLOWORLD']",
        "['hello world']"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "['HELLO', 'WORLD']",
      "explanation": "თავდაპირველად toUpperCase() ქმნის 'HELLO WORLD'-ს, შემდეგ split(' ') ქმნის ორი სიტყვისგან შემდგარ მასივს."
    },
    "66": {
      "question": "რას დააბრუნებს: && (და) ოპერატორი?",
      "options": [
        "აბრუნებს true-ს მხოლოდ მაშინ, როცა ორივე მხარე ჭეშმარიტია",
        "აბრუნებს true-ს, თუ რომელიმე მხარე ჭეშმარიტია",
        "ყოველთვის აბრუნებს false-ს",
        "მნიშვნელობებს რიცხვებად გარდაქმნის"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "აბრუნებს true-ს მხოლოდ მაშინ, როცა ორივე მხარე ჭეშმარიტია",
      "explanation": "ლოგიკური AND (&&) მხოლოდ მაშინ აბრუნებს true-ს, როდესაც ორივე გამოსახულება true-ა."
    },
    "67": {
      "question": "რას დააბრუნებს: || (ან) ოპერატორი?",
      "options": [
        "აბრუნებს true-ს, თუ ორივე ჭეშმარიტია",
        "აბრუნებს true-ს, თუ მინიმუმ ერთი ჭეშმარიტია",
        "ყოველთვის აბრუნებს false-ს",
        "აბრუნებს boolean-ის საპირისპიროს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "აბრუნებს true-ს, თუ მინიმუმ ერთი ჭეშმარიტია",
      "explanation": "ლოგიკური OR (||) აბრუნებს true-ს, თუ რომელიმე გამოსახულება true-ა."
    },
    "68": {
      "question": "რას დააბრუნებს: !(უტოლობა) ჯავასკრიპტში?",
      "options": [
        "true-ს აქცევს false-ად და false-ს true-ად",
        "ამოწმებს ტოლობას",
        "ამატებს რიცხვებს",
        "მასივში გადადის"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "true-ს აქცევს false-ად და false-ს true-ად",
      "explanation": "NOT ოპერატორი (!) ლოგიკურ მნიშვნელობას ინვერსირებს."
    },
    "69": {
      "question": "რომელი ციკლი გააგრძელებს მუშაობას მანამ, სანამ პირობაა ჭეშმარიტი?",
      "options": [
        "for ციკლი",
        "while ციკლი",
        "do ციკლი",
        "switch ციკლი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "while ციკლი",
      "explanation": "while ციკლი აგრძელებს შესრულებას მანამ, სანამ მისი პირობა არ გახდება მცდარი."
    },
    "70": {
      "question": "რას დაბეჭდავს, while ციკლი?: let i = 0; while(i < 3){ console.log(i); i++;}",
      "options": [
        "0 1 2",
        "1 2 3",
        "0 1 2 3",
        "უსასრულო ციკლი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "0 1 2",
      "explanation": "ციკლი მუშაობს მაშინ, როდესაც i < 3-ია, დაბეჭდავს 0, 1 და 2-ს."
    },
    "71": {
      "question": "რომელი ციკლი ასრულებს კოდის ბლოკს ფიქსირებულ რაოდენობაში?",
      "options": [
        "for ციკლი",
        "while ციკლი",
        "switch",
        "if პირობა"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "for ციკლი",
      "explanation": "for ციკლი ჩვეულებრივ გამოიყენება კოდის გარკვეული რაოდენობის ჯერ გასაშვებად, მაგალითად, მასივში იტერაციისას."
    },
    "72": {
      "question": "რას დაბეჭდავს ეს for ციკლი?: for(let i=0; i<3; i++){ console.log(i);}",
      "options": [
        "0 1 2",
        "1 2 3",
        "0 1 2 3",
        "უსასრულო ციკლი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "0 1 2",
      "explanation": "ციკლი იწყება 0-დან, მუშაობს, როდესაც i < 3-ია და ყოველ ჯერზე ზრდის i-ს."
    },
    "73": {
      "question": "რომელი ციკლი შესრულდება ერთხელ მაინც, მაშინაც კი, თუ პირობა მცდარია?",
      "options": [
        "for ციკლი",
        "while ციკლი",
        "do...while ციკლი",
        "switch"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "do...while ციკლი",
      "explanation": "do...while ციკლი ჯერ ბლოკს ასრულებს, შემდეგ კი პირობას ამოწმებს, ამიტომ ის ყოველთვის ერთხელ მაინც სრულდება."
    },
    "74": {
      "question": "რას დაბეჭდავს ეს კოდი: let i = 5; do { console.log(i); i++;} while(i < 5);",
      "options": [
        "არაფერს",
        "5",
        "5 6",
        "უსასრულო ციკლი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "5",
      "explanation": "do...while ციკლი პირობის შემოწმებამდე ერთხელ მუშაობს, ამიტომ ის ბეჭდავს 5-ს, მიუხედავად იმისა, რომ i < 5 არის false."
    },
    "75": {
      "question": "რას წარმოადგენს ფუნქციის დეკლარაცია JavaScript-ში?",
      "options": [
        "ფუნქცია, რომელიც function საკვანძო სიტყვითა და სახელით არის განსაზღვრული",
        "ფუნქცია, რომელიც ცვლადში ინახება",
        "მეთოდი ობიექტის შიგნით",
        "ჩაშენებული მეთოდი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ფუნქცია, რომელიც function საკვანძო სიტყვითა და სახელით არის განსაზღვრული",
      "explanation": "ფუნქციის დეკლარაცია განსაზღვრავს დასახელებულ ფუნქციას, მაგალითად function greet() { return 'Hello'; }"
    },
    "76": {
      "question": "რა არის ფუნქციის გამოსახულება(function expression)?",
      "options": [
        "ფუნქცია, რომელიც ცვლადში ინახება",
        "მეთოდი Math-ში",
        "ციკლი return-ით",
        "მხოლოდ ისრის ფუნქცია"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ფუნქცია, რომელიც ცვლადში ინახება",
      "explanation": "ფუნქციის გამოსახულება ქმნის ფუნქციას და ანიჭებს მას ცვლადს, მაგ., const greet = function() { return 'Hi'; }"
    },
    "77": {
      "question": "რომელი მასივის მეთოდი ქმნის ახალ მასივს თითოეული ელემენტის გარდაქმნით?",
      "options": [
        "map()",
        "filter()",
        "reduce()",
        "forEach()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "map()",
      "explanation": "map() თითოეულ ელემენტს იყენებს ფუნქციას და აბრუნებს ახალ მასივს."
    },
    "78": {
      "question": "რომელი მასივის მეთოდი ქმნის ახალ მასივს ისეთი ელემენტებით, რომლებიც ტესტს წარმატებით ასრულებენ?",
      "options": [
        "map()",
        "filter()",
        "reduce()",
        "slice()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "filter()",
      "explanation": "filter() ამოწმებს თითოეულ ელემენტს და ინახავს მხოლოდ იმ ელემენტებს, რომლებიც აკმაყოფილებენ პირობას."
    },
    "79": {
      "question": "რომელი მასივის მეთოდი ამცირებს ყველა მნიშვნელობას ერთ მნიშვნელობად?",
      "options": [
        "map()",
        "filter()",
        "reduce()",
        "concat()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "reduce()",
      "explanation": "reduce() ამუშავებს მასივის ყველა ელემენტს და აერთიანებს მათ ერთ მნიშვნელობად, მაგალითად, ჯამად."
    },
    "80": {
      "question": "რა განსხვავებაა map()-სა და forEach()-ს შორის?",
      "options": [
        "map() აბრუნებს ახალ მასივს, forEach() კი — არა",
        "forEach() უფრო სწრაფია",
        "map() ცვლის ორიგინალ მასივს, forEach() — არა",
        "ისინი ზუსტად ერთნაირია"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "map() აბრუნებს ახალ მასივს, forEach() კი — არა",
      "explanation": "map() ქმნის და აბრუნებს ახალ მასივს, ხოლო forEach() მხოლოდ თითოეულ ელემენტზე ასრულებს კოდს."
    },
    "81": {
      "question": "რომელი მასივის მეთოდი აბრუნებს პირველ ელემენტს, რომელიც ემთხვევა პირობას?",
      "options": [
        "filter()",
        "find()",
        "map()",
        "reduce()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "find()",
      "explanation": "find() აბრუნებს პირველ ელემენტს, რომელიც აკმაყოფილებს პირობას, ხოლო filter() აბრუნებს ყველა შესაბამის ელემენტს."
    },
    "82": {
      "question": "რომელი მასივის მეთოდი ამოწმებს, ემთხვევა თუ არა პირობას სულ მცირე ერთი ელემენტი მაინც?",
      "options": [
        "every()",
        "some()",
        "find()",
        "includes()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "some()",
      "explanation": "some() აბრუნებს true-ს, თუ ერთი ელემენტი მაინც გაივლის ტესტს."
    },
    "83": {
      "question": "რომელი მასივის მეთოდი ამოწმებს, ემთხვევა თუ არა ყველა ელემენტი პირობას?",
      "options": [
        "filter()",
        "every()",
        "some()",
        "map()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "every()",
      "explanation": "every() აბრუნებს true-ს მხოლოდ იმ შემთხვევაში, თუ ყველა ელემენტი აკმაყოფილებს პირობას."
    },
    "84": {
      "question": "რომელი მასივის მეთოდი ამოწმებს, შეიცავს თუ არა მასივი კონკრეტულ მნიშვნელობას?",
      "options": [
        "find()",
        "some()",
        "includes()",
        "concat()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "includes()",
      "explanation": "includes() აბრუნებს true-ს, თუ მასივი შეიცავს მოცემულ მნიშვნელობას."
    },
    "85": {
      "question": "რომელი მასივის მეთოდი აბრუნებს პირველი შესაბამისი ელემენტის ინდექსს?",
      "options": [
        "indexOf()",
        "find()",
        "filter()",
        "slice()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "indexOf()",
      "explanation": "indexOf() აბრუნებს მასივში მნიშვნელობის პირველი გამოჩენის პოზიციას."
    },
    "86": {
      "question": "რომელი მასივის მეთოდი შლის ბოლო ელემენტს?",
      "options": [
        "pop()",
        "push()",
        "shift()",
        "unshift()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "pop()",
      "explanation": "pop() შლის ბოლო ელემენტს და აბრუნებს მას."
    },
    "87": {
      "question": "რომელი მასივის მეთოდი ამატებს ელემენტს ბოლოს?",
      "options": [
        "pop()",
        "push()",
        "shift()",
        "concat()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "push()",
      "explanation": "push() ამატებს ერთ ან მეტ ელემენტს მასივის ბოლოში."
    },
    "88": {
      "question": "რომელი მასივის მეთოდი აბრტყელებს ჩადგმულ მასივებს ერთ მასივად?",
      "options": [
        "map()",
        "flat()",
        "reduce()",
        "slice()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "flat()",
      "explanation": "flat() ქმნის ახალ მასივს ჩადგმული მასივების ერთ დონეზე გაბრტყელებით."
    },
    "89": {
      "question": "რომელი მასივის მეთოდი ალაგებს ელემენტებს ადგილზე?",
      "options": [
        "sort()",
        "reverse()",
        "map()",
        "filter()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "sort()",
      "explanation": "sort() ახარისხებს მასივის ელემენტებს ადგილზე და აბრუნებს დახარისხებულ მასივს."
    },
    "90": {
      "question": "რომელი მასივის მეთოდი უცვლის ელემენტებს თანმიმდევრობას?",
      "options": [
        "reverse()",
        "sort()",
        "slice()",
        "splice()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "reverse()",
      "explanation": "reverse() აბრუნებს მასივის ელემენტებს ადგილზე."
    },
    "91": {
      "question": "რას აკეთებს spread ოპერატორი (...) JavaScript მასივებში?",
      "options": [
        "აკოპირებს მასივის ყველა ელემენტს ახალ მასივში",
        "შლის ელემენტებს",
        "ამატებს რიცხვებს ერთმანეთთან",
        "ითვლის მასივის ელემენტებს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "აკოპირებს მასივის ყველა ელემენტს ახალ მასივში",
      "explanation": "გავრცელების ოპერატორი მასივის ელემენტებს ახალ მასივში ან ფუნქციის არგუმენტებში აფართოებს."
    },
    "92": {
      "question": "spread operator-ის ფუნქცია ზედაპირული ასლის შექმნაა თუ მასივის მითითება?",
      "options": [
        "ზედაპირული ასლი",
        "ღრმა ასლი",
        "მხოლოდ მითითება",
        "იგი შლის ორიგინალს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ზედაპირული ასლი",
      "explanation": "გავრცელების ოპერატორი ქმნის ზედაპირულ ასლს, რაც იმას ნიშნავს, რომ ჩადგმული ობიექტები ან მასივები კვლავ მითითებულია."
    },
    "93": {
      "question": "რა განსხვავებაა მასივის მინიჭებასა(=-ტოლობით) და spread operator(...)-ს შორის?",
      "options": [
        "= აკოპირებს მითითებას, ... აკოპირებს ელემენტებს",
        "= აკოპირებს ელემენტებს, ... აკოპირებს მითითებას",
        "ორივე ერთსა და იმავეს აკეთებს",
        "მხოლოდ ... მუშაობს მასივებისთვის"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "= აკოპირებს მითითებას, ... აკოპირებს ელემენტებს",
      "explanation": "მასივის მინიჭება =-ით მიუთითებს იმავე მითითებაზე; spread ქმნის ახალ მასივს კოპირებული ელემენტებით."
    },
    "94": {
      "question": "როგორ გამოიყურება ერთი პარამეტრის მქონე ისრისებრი ფუნქციის სინტაქსი?",
      "options": [
        "(x) => x * 2",
        "function(x) { return x*2 }",
        "x => return x*2",
        "x => {x*2}"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "(x) => x * 2",
      "explanation": "ერთი პარამეტრის მქონე ისრისებრ ფუნქციებს შეუძლიათ ფრჩხილების გამოტოვება და პირდაპირ გამოსახულებას აბრუნებენ."
    },
    "95": {
      "question": "რა სხვაობაა ისრის ფუნქციასა და ნორმალურ ფუნქციას შორის?",
      "options": [
        "ისრის ფუნქციებს არ აქვთ საკუთარი 'this'",
        "ისრის ფუნქციებს არ შეუძლიათ მნიშვნელობის დაბრუნება",
        "ჩვეულებრივ ფუნქციებს არ შეუძლიათ არგუმენტების მიღება",
        "ისრის ფუნქციები ყოველთვის ასინქრონულად სრულდება"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ისრის ფუნქციებს არ აქვთ საკუთარი 'this'",
      "explanation": "ისრის ფუნქციები, ჩვეულებრივი ფუნქციებისგან განსხვავებით, „ამას“ მათი მიმდებარე სფეროდან მემკვიდრეობით იღებენ."
    },
    "96": {
      "question": "როგორ იწერება ისრის ფუნქცია, მრავალი პარამეტრით?",
      "options": [
        "(a, b) => a + b",
        "a, b => a + b",
        "function(a, b) => a+b",
        "(a, b) => {return a+b}"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "(a, b) => a + b",
      "explanation": "მრავალი პარამეტრი ფრჩხილებში უნდა იყოს შეფუთული და ისრის ფუნქციას შეუძლია პირდაპირ დააბრუნოს მნიშვნელობა."
    },
    "97": {
      "question": "რას აღნიშნავს „THIS“-საკვანძო სიტყვა, ობიექტის მეთოდის შიგნით გამოძახებულ ნორმალურ ფუნქციაში?",
      "options": [
        "ობიექტს თავად",
        "გლობალურ ობიექტს",
        "ყოველთვის undefined-ს",
        "პირველ პარამეტრს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ობიექტს თავად",
      "explanation": "'this'- მეთოდი ეხება ობიექტს რომელიც ახდენს მეთოდების გამოძახებას."
    },
    "98": {
      "question": "რას აღნიშნავს „THIS“ ჩვეულებრივ ფუნქციაში, რომელსაც alone ეწოდება?",
      "options": [
        "გლობალურ ობიექტს (window ბრაუზერში)",
        "ობიექტს, რომელშიც შეიქმნა",
        "ახლომდებარე ისრის ფუნქციას",
        "ყოველთვის null-ს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "გლობალურ ობიექტს (window ბრაუზერში)",
      "explanation": "დამოუკიდებელი ფუნქციის „ეს“ მიუთითებს გლობალურ ობიექტზე არამკაცრ რეჟიმში, ან განუსაზღვრელზე მკაცრი რეჟიმის შემთხვევაში."
    },
    "99": {
      "question": "შეიძლება თუ არა, ისრის ფუნქციების გამოყენება ობიექტის მეთოდად?",
      "options": [
        "კი, მაგრამ 'this' არ მიუთითებს ობიექტზე",
        "კი, 'this' ნორმალურად მუშაობს",
        "არა, ისრის ფუნქციებს ობიექტებში გამოყენება არ შეუძლიათ",
        "მხოლოდ მაშინ თუ ობიექტი მასივია"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "კი, მაგრამ 'this' არ მიუთითებს ობიექტზე",
      "explanation": "ისრის ფუნქციები „ამას“ მშობელი სფეროდან მემკვიდრეობით იღებენ, ამიტომ მათ ობიექტებში საკუთარი კონტექსტი არ აქვთ."
    },
    "100": {
      "question": "რომელია სწორი გზა რომ დავაკოპიროთ მასივი, spread operator-ის გამოყენებით?",
      "options": [
        "let newArr = [...oldArr]",
        "let newArr = oldArr",
        "let newArr = oldArr.copy()",
        "let newArr = oldArr{}"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "let newArr = [...oldArr]",
      "explanation": "გავრცელების ოპერატორი ქმნის ახალ მასივს იგივე ელემენტებით: [...oldArr]."
    },
    "101": {
      "question": "რა არის კლასი JavaScript-ში?",
      "options": [
        "შაბლონი ობიექტების შესაქმნელად",
        "ფუნქცია, რომელიც ყოველთვის აბრუნებს რიცხვს",
        "ფუნქციების მასივი",
        "ცვლადის გამოსაცხადებელი საკვანძო სიტყვა"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "შაბლონი ობიექტების შესაქმნელად",
      "explanation": "კლასები უზრუნველყოფენ შაბლონს საერთო თვისებებითა და მეთოდებით ობიექტების შესაქმნელად."
    },
    "102": {
      "question": "როგორ უნდა შევქმნათ ობიექტი კლასიდან?",
      "options": [
        "let obj = new ClassName()",
        "let obj = ClassName()",
        "let obj = ClassName.new()",
        "let obj = create ClassName()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "let obj = new ClassName()",
      "explanation": "საკვანძო სიტყვა „new“ ქმნის კლასის ეგზემპლარს."
    },
    "103": {
      "question": "რა არის მემკვიდრეობა ჯავასკრიპტის კლასებში?",
      "options": [
        "კლასს შეუძლია გააფართოვოს სხვა კლასი და ხელახლა გამოიყენოს მისი თვისებები/მეთოდები",
        "კლასი, რომლის გამოყენებაც შესაძლებელია როგორც ცვლადი",
        "ფუნქცია კლასის შიგნით",
        "ცვლადის მინიჭება სხვას"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "კლასს შეუძლია გააფართოვოს სხვა კლასი და ხელახლა გამოიყენოს მისი თვისებები/მეთოდები",
      "explanation": "მემკვიდრეობა კლასს საშუალებას აძლევს ხელახლა გამოიყენოს მშობელი კლასის კოდი „extends“ საკვანძო სიტყვის გამოყენებით."
    },
    "104": {
      "question": "რას აკეთებს საკვანძო სიტყვა „super“-ი?",
      "options": [
        "იძახებს მშობელი კლასის კონსტრუქტორს ან მეთოდებს",
        "ქმნის ახალ ობიექტს",
        "შლის მშობლის მეთოდებს",
        "ცვლადს ანიჭებს მნიშვნელობას"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "იძახებს მშობელი კლასის კონსტრუქტორს ან მეთოდებს",
      "explanation": "super()-ს შეუძლია მშობელი კლასის კონსტრუქტორის გამოძახება, ხოლო super.method()-ს შეუძლია მშობელი მეთოდის გამოძახება."
    },
    "105": {
      "question": "როგორ განვსაზღვროთ „Getter“ კლასში?",
      "options": [
        "get propertyName() { return this.value }",
        "getter propertyName() { return this.value }",
        "function get(propertyName) { return this.value }",
        "set propertyName() { this.value }"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "get propertyName() { return this.value }",
      "explanation": "გეტერები საშუალებას გაძლევთ განსაზღვროთ მეთოდი, რომელზეც წვდომა შესაძლებელია თვისების მსგავსად."
    },
    "106": {
      "question": "როგორ განვსაზღვროთ „Setter“ კლასში?",
      "options": [
        "set propertyName(value) { this.value = value }",
        "setter propertyName(value) { this.value = value }",
        "function set(propertyName, value) { this.value = value }",
        "get propertyName(value) { this.value = value }"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "set propertyName(value) { this.value = value }",
      "explanation": "სეტერები საშუალებას გაძლევთ, მორგებული კოდის შესრულებისას თვისებას მიანიჭოთ მნიშვნელობა."
    },
    "107": {
      "question": "რომელი საკვანძო სიტყვა გამოიყენება კლასის გასაფართოებლად?",
      "options": [
        "extends",
        "super",
        "inherit",
        "class"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "extends",
      "explanation": "საკვანძო სიტყვა „extends“ კლასს სხვა კლასისგან მემკვიდრეობით მიღების საშუალებას აძლევს."
    },
    "108": {
      "question": "შეუძლია თუ არა შვილობილ კლასს მშობელ მეთოდებზე წვდომა მათი ხელახალი განსაზღვრის გარეშე?",
      "options": [
        "კი, მემკვიდრეობის გზით",
        "არა, ყველა მეთოდი თავიდან უნდა განისაზღვროს",
        "მხოლოდ სტატიკური მეთოდები",
        "მხოლოდ გეტერები და სეტერები"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "კი, მემკვიდრეობის გზით",
      "explanation": "შვილობილი კლასები ავტომატურად მემკვიდრეობით იღებენ არაპრივატულ მეთოდებს მშობელი კლასიდან."
    },
    "109": {
      "question": "რა მოხდება თუ ჩვენ გამოვიძახებთ super()-ს შვილი კლასის კონსტრუქტორში?",
      "options": [
        "იგი იძახებს მშობელი კლასის კონსტრუქტორს",
        "იგი იძახებს შვილი კონსტრუქტორს რეკურსიულად",
        "იგი ქმნის ახალ ობიექტს",
        "იგი აგდებს შეცდომას"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "იგი იძახებს მშობელი კლასის კონსტრუქტორს",
      "explanation": "კონსტრუქტორში super() ასრულებს მშობელ კონსტრუქტორს და საშუალებას იძლევა სათანადო ინიციალიზაციის."
    },
    "110": {
      "question": "რაში გვჭირდება „Getter“-ი და „Setter“-ი კლასებში?",
      "options": [
        "თვისებებზე წვდომის კონტროლისთვის და დამატებითი ლოგიკის გასაშვებად",
        "მასივების შესანახად",
        "ცვლადების გამოსაცხადებლად",
        "super მეთოდების გამოსაძახებლად"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "თვისებებზე წვდომის კონტროლისთვის და დამატებითი ლოგიკის გასაშვებად",
      "explanation": "გეტერები და სეტერები თვისებების კონტროლირებულ წაკითხვას/ჩაწერას იძლევიან და შეიძლება მოიცავდნენ ვალიდაციას ან გამოთვლილ მნიშვნელობებს."
    },
    "111": {
      "question": "ჩამოთვლილთაგან რომლის საშუალებით შეგვიძლია მივიღოთ მასივი რომლის პირველი ასო იქნება დიდი ალფავიტით დაწერილი?",
      "options": [
        "let arr = ['hello']; arr[0].toUpperCase();",
        "let arr = ['hello']; arr.first().toUpperCase();",
        "let arr = ['hello']; arr.toUpperCase(0);",
        "let arr = ['hello']; arr[1].toUpperCase();"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "let arr = ['hello']; arr[0].toUpperCase();",
      "explanation": "მასივის პირველი ელემენტი 0 ინდექსზეა და სტრიქონებს აქვთ toUpperCase() მეთოდი."
    },
    "112": {
      "question": "ჩამონათვალიდან რომელი ვარიანტი მიგვიყვანს იმ შედეგამდე რომ ჩანაწერის პირველი ასო გახდეს დიდი, დანარჩენი კი პატარა ასოებით დაიწეროს?",
      "options": [
        "let str = 'jAVaScRIPt'; str[0].toUpperCase() + str.slice(1).toLowerCase();",
        "let str = 'jAVaScRIPt'; str.capitalize();",
        "let str = 'jAVaScRIPt'; str.upperFirst();",
        "let str = 'jAVaScRIPt'; str.toUpperCaseFirst();"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "let str = 'jAVaScRIPt'; str[0].toUpperCase() + str.slice(1).toLowerCase();",
      "explanation": "პირველი სიმბოლოსთვის ვიყენებთ toUpperCase()-ს, შემდეგ slice()-ს და დანარჩენებისთვის toLowerCase()-ს."
    },
    "113": {
      "question": "როგორ უნდა ვაკავშირებთ მეთოდები ჯაჭვურად, ისე რომ შემცირდეს სივრცეები და სტრიქონი დაიწეროს პატარა ასოებით?",
      "options": [
        "'  HELLO  '.trim().toLowerCase();  // ჯერ trim, შემდეგ lowercase",
        "'  HELLO  '.toLowerCase().trim();  // ჯერ lowercase, შემდეგ trim",
        "ორივე trim().toLowerCase() და toLowerCase().trim() მუშაობს ერთნაირად",
        "'  HELLO  '.lowercase().trim();  // არასწორი მეთოდი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ორივე trim().toLowerCase() და toLowerCase().trim() მუშაობს ერთნაირად",
      "explanation": "ორივე ბრძანება მუშაობს, რადგან სივრცეების შემცირება და რეგისტრის გარდაქმნა დამოუკიდებელი ოპერაციებია."
    },
    "114": {
      "question": "როგორ შეგვიძლია რომ მივიღოთ ელემენტი DOM-ში, ID-ით რომელსაც ქვია 'title'?",
      "options": [
        "document.getElementById('title')  // ტრადიციული მეთოდი",
        "document.querySelector('#title')  // CSS-სტილის სელექტორი",
        "ორივე getElementById და querySelector('#title') სწორია",
        "document.getById('title')  // არასწორია"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ორივე getElementById და querySelector('#title') სწორია",
      "explanation": "როგორც getElementById()-ს, ასევე querySelector('#id')-ს შეუძლია ელემენტის არჩევა ID-ის მიხედვით, თუმცა querySelector უფრო მოქნილია და არ დაგავიწყდეთ ამ მეთოდის გამოყენებისას სელექტორის სიმბოლო # ან .-ს გამოყენება."
    },
    "115": {
      "question": "რომელი მეთოდის საშუალებით შევძლებთ რომ ავირჩიოთ გვერდზე პირველი აბზაცი?",
      "options": [
        "document.querySelector('p')",
        "document.getElementByTag('p')",
        "document.select('p')",
        "document.querySelect('p')"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "document.querySelector('p')",
      "explanation": "querySelector() ირჩევს პირველ ელემენტს, რომელიც შეესაბამება CSS სელექტორს."
    },
    "116": {
      "question": "რომელი მეთოდის საშუალებით შევძლებთ მოვნიშნოთ გვერდზე, აბზაცის ყველა ელემენტი?",
      "options": [
        "document.querySelectorAll('p')  // აბრუნებს NodeList-ს <p>-ების",
        "document.getElementsByTagName('p')  // აბრუნებს HTMLCollection-ს <p>-ების",
        "ორივე querySelectorAll და getElementsByTagName მუშაობს <p>-ის არჩევისთვის",
        "document.getAll('p')  // არასწორია"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ორივე querySelectorAll და getElementsByTagName მუშაობს <p>-ის არჩევისთვის",
      "explanation": "querySelectorAll() აბრუნებს NodeList-ს, getElementsByTagName() კი აბრუნებს HTMLCollection-ს. ორივეს შეუძლია <p> ელემენტების არჩევა."
    },
    "117": {
      "question": "რომელი ჯავასკრიპტ მეთოდის საშუალებით ხდება ასქროლვა, ამ შემთხვევაში სრულიად ზემოთ?",
      "options": [
        "window.scrollTo({ top: 0, behavior: 'smooth' });",
        "document.scrollTo(0);",
        "window.scrollSmooth(0);",
        "document.scroll({top: 0});"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "window.scrollTo({ top: 0, behavior: 'smooth' });",
      "explanation": "scrollTo() ოფციებით საშუალებას გაძლევთ შეუფერხებლად გადაახვიოთ კონკრეტულ პოზიციაზე."
    },
    "118": {
      "question": "როგორ უნდა დავამატოთ click დაწკაპუნების event-ი ღილაკზე, რომლის ID იქნება 'btn'?",
      "options": [
        "document.getElementById('btn').addEventListener('click', () => { console.log('Clicked'); });",
        "document.querySelector('btn').onClick = () => { console.log('Clicked'); };",
        "button('btn').click(() => { console.log('Clicked'); });",
        "document.addEvent('btn', 'click', () => { console.log('Clicked'); });"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "document.getElementById('btn').addEventListener('click', () => { console.log('Clicked'); });",
      "explanation": "addEventListener() ღილაკს მოვლენების დამმუშავებელს ამაგრებს."
    },
    "119": {
      "question": "როგორ ავიცილოთ თავიდან ფორმის გვერდის განახლება გაგზავნის შემდეგ?",
      "options": [
        "form.addEventListener('submit', (e) => { e.preventDefault(); });",
        "form.onsubmit = false;",
        "form.stop();",
        "return false;"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "form.addEventListener('submit', (e) => { e.preventDefault(); });",
      "explanation": "preventDefault() აჩერებს ნაგულისხმევ ქცევას, როგორიცაა გვერდის ხელახლა ჩატვირთვა ფორმის გაგზავნისას."
    },
    "120": {
      "question": "როგორ შევცვალოთ ელემენტის ტექსტური შინაარსი, რომლის ID არის 'msg'?",
      "options": [
        "document.getElementById('msg').textContent = 'Hello!';  // სასურველი",
        "document.getElementById('msg').innerText = 'Hello!';  // ასევე მუშაობს",
        "ორივე textContent და innerText ცვლის ტექსტს ელემენტში",
        "document.querySelector('msg').text = 'Hello!';  // არასწორი მეთოდი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ორივე textContent და innerText ცვლის ტექსტს ელემენტში",
      "explanation": "როგორც textContent, ისევ innerText მუშაობს, თუმცა textContent-ი უფრო სწრაფი და თანმიმდევრულია."
    },
    "121": {
      "question": "რა გავლენას ახდენს API ვებ პროგრამირებაში?",
      "options": [
        "ის ქმნის გვერდის HTML სტრუქტურას",
        "ის საშუალებას აძლევს აპლიკაციებს იკონტაქტონ და გაცვალონ მონაცემები",
        "ის გამოიყენება მხოლოდ CSS-ით სტილისთვის",
        "ის მუდმივად ინახავს მონაცემებს ბრაუზერში"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის საშუალებას აძლევს აპლიკაციებს იკონტაქტონ და გაცვალონ მონაცემები",
      "explanation": "API ნიშნავს აპლიკაციის პროგრამირების ინტერფეისს. ის საშუალებას აძლევს თქვენს აპლიკაციას დაუკავშირდეს სერვერებს ან სერვისებს მონაცემების გასაგზავნად და მისაღებად."
    },
    "122": {
      "question": "ყველაზე ხშირად, ჯავასკრიპტის რომელი მეთოდი გამოიყენება API-დან მონაცემების მოსათხოვნად?",
      "options": [
        "console.log()",
        "fetch()",
        "document.querySelector()",
        "Math.random()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "fetch()",
      "explanation": "fetch() არის ჩაშენებული JavaScript ფუნქცია API-ებისა და სერვერებისთვის HTTP მოთხოვნების გასაგზავნად."
    },
    "123": {
      "question": "fetch()-ის გამოყენებისას, რა ტიპის მონაცემები ბრუნდება ჩვეულებრივ API-დან?",
      "options": [
        "HTML",
        "JSON",
        "CSS",
        "მხოლოდ XML"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "JSON",
      "explanation": "თანამედროვე API-ების უმეტესობა მონაცემებს JSON ფორმატში აბრუნებს, რადგან ის მსუბუქია და JavaScript-ისთვის ადვილად გასაანალიზებელი."
    },
    "124": {
      "question": "როგორ გარდავქმნათ fetch() პასუხი გამოსაყენებელ JSON-ად?",
      "options": [
        "response.toJSON()",
        "response.parse()",
        "response.json()",
        "response.JSON()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "response.json()",
      "explanation": "fetch()-ის გამოძახების შემდეგ, პასუხის გამოსაყენებელ JavaScript ობიექტად გადასაყვანად უნდა გამოიყენოთ response.json()."
    },
    "125": {
      "question": "როგორ გავუმკლავდეთ შეცდომებს მოძიების მოთხოვნებში?",
      "options": [
        "fetch-ის შემდეგ .catch()-ის გამოყენებით",
        "გვერდის გადატვირთვით",
        "try...catch-ის დაწერით HTML-ში",
        "JavaScript-ის გამორთვით"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "fetch-ის შემდეგ .catch()-ის გამოყენებით",
      "explanation": "fetch()-ი აბრუნებს პირობას(Promise), ამიტომ ჩვენ შეცდომებს თავი უნდა გავართვათ .catch() ან try...catch-ის გამოყენებით, async/await-თან ერთად."
    },
    "126": {
      "question": "ჩამოთვლილთაგან, რომელია ასინქრონული API ზარების დამუშავების თანამედროვე გზა?",
      "options": [
        "Callback-ები",
        "async/await",
        "setInterval",
        "alert()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "async/await",
      "explanation": "async/await ხდის ასინქრონულ კოდს წაკითხვადს და თანამედროვე ჯავასკრიპტში იგი უფრო ფართოდ გამოიყენება API call-ებისთვის."
    },
    "127": {
      "question": "რას აკეთებს JSON.stringify(), API-ებთან მუშაობისას?",
      "options": [
        "ის გარდაქმნის JavaScript ობიექტებს JSON სტრიქონად",
        "ის გარდაქმნის JSON-ს JavaScript ობიექტად",
        "ის შლის ცარიელ ადგილებს სტრიქონებიდან",
        "ის ასრულებს JavaScript კოდს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის გარდაქმნის JavaScript ობიექტებს JSON სტრიქონად",
      "explanation": "API-ები ხშირად საჭიროებენ მონაცემებს JSON სტრიქონის ფორმატში, ამიტომ მონაცემების გაგზავნისას გამოიყენება JSON.stringify()."
    },
    "128": {
      "question": "რას აკეთებს JSON.parse() API მონაცემებთან მუშაობისას?",
      "options": [
        "JSON სტრიქონს გარდაქმნის JavaScript ობიექტად",
        "რიცხვებს გარდაქმნის სტრიქონებად",
        "შლის ცარიელ ადგილებს",
        "ინახავს მონაცემებს localStorage-ში"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "JSON სტრიქონს გარდაქმნის JavaScript ობიექტად",
      "explanation": "API-ები მონაცემებს JSON სტრიქონების სახით აბრუნებენ. JSON.parse() გარდაქმნის მათ JavaScript ობიექტებად, რომელთა გამოყენებაც შეგიძლიათ."
    },
    "129": {
      "question": "როგორ უნდა დავამახსოვროთ ობიექტი მაგალითად: {name: 'Luka'}, localStorage-ში?",
      "options": [
        "localStorage.setItem('user', {name: 'Luka'})",
        "localStorage.setItem('user', JSON.stringify({name: 'Luka'}))",
        "localStorage.save('user', 'Luka')",
        "localStorage.push({name: 'Luka'})"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "localStorage.setItem('user', JSON.stringify({name: 'Luka'}))",
      "explanation": "localStorage მხოლოდ სტრიქონებს ინახავს. შენახვამდე ობიექტების გადასაყვანად გამოიყენეთ JSON.stringify()."
    },
    "130": {
      "question": "როგორ უნდა მოხდეს ობიექტის აღდგენა რომელიც უკვე განთავსებულია localStorage-ში {name: 'Luka'}?",
      "options": [
        "localStorage.getItem('user')",
        "JSON.parse(localStorage.getItem('user'))",
        "localStorage.load('user')",
        "localStorage.getObject('user')"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "JSON.parse(localStorage.getItem('user'))",
      "explanation": "localStorage ყველაფერს სტრიქონების სახით ინახავს. შენახული სტრიქონის ობიექტად გადასაყვანად გამოიყენეთ JSON.parse()."
    },
    "131": {
      "question": "როგორ ვაგზავნით მონაცემებს fetch-ინგის წყალობით, API-სთან (მაგ: პოსტის მოთხოვნა)?",
      "options": [
        "fetch(url, { method: 'POST', body: JSON.stringify(data) })",
        "fetch.send(url, data)",
        "document.write(data)",
        "fetch(url).post(data)"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "fetch(url, { method: 'POST', body: JSON.stringify(data) })",
      "explanation": "მონაცემების გაგზავნისას, fetch-ს სჭირდება მეთოდი ('POST') და ტექსტი, რომელიც ჩვეულებრივ JSON-ად გარდაიქმნება JSON.stringify()-ის გამოყენებით."
    },
    "132": {
      "question": "რატომ იყენებენ დეველოპერები API-ს რეალური დროის პროექტებში?",
      "options": [
        "გვერდების გასაფორმებლად CSS-ით",
        "მონაცემების მისაღებად ან გასაგზავნად სერვერებიდან ან მესამე მხარის სერვისებიდან",
        "JavaScript-ის თავიდან ასაცილებლად",
        "მხოლოდ შემთხვევითი რიცხვების შესაქმნელად"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "მონაცემების მისაღებად ან გასაგზავნად სერვერებიდან ან მესამე მხარის სერვისებიდან",
      "explanation": "API-ები დეველოპერებს საშუალებას აძლევს, თავიანთ აპლიკაციებში ინტეგრირება მოახდინონ მონაცემებსა და სერვისებში, როგორიცაა ამინდი, რუკები, გადახდები ან ავტორიზაცია."
    },
    "133": {
      "question": "როგორ გავაუქმოთ ფუნქცია JavaScript-ში (მისი გაშვების სიხშირის შესაზღუდად)?",
      "options": [
        "setTimeout-ში შეფუთვით და clearTimeout-ით მისი შეჩერებით",
        "setInterval-ის გამოყენებით პირდაპირი გამოძახების ნაცვლად",
        "ფუნქციის სწრაფად მრავალჯერ გამოძახებით",
        "ფუნქციის წინ await-ის დამატებით"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "setTimeout-ში შეფუთვით და clearTimeout-ით მისი შეჩერებით",
      "explanation": "დებოუნსინგი უზრუნველყოფს, რომ ფუნქცია გაშვებული იყოს მხოლოდ განმეორებითი ზარების პაუზის შემდეგ, რაც ხშირად გამოიყენება ძიების შეყვანისას ან მოვლენების ზომის შეცვლისას."
    },
    "134": {
      "question": "რომელი მასივის მეთოდია საუკეთესო პირობის შესაბამისი პირველი ელემენტის მოსაძებნად?",
      "options": [
        "map()",
        "filter()",
        "find()",
        "forEach()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "find()",
      "explanation": "find() აბრუნებს პირველ ელემენტს, რომელიც ემთხვევა პირობას, ხოლო filter() აბრუნებს ყველა შესაბამის ელემენტს."
    },
    "135": {
      "question": "რა ძირითადი განსხვავებებია ორმაგ ტოლობასა('==') და and მკაცრ ტოლობას შორის('===')?",
      "options": [
        "== ადარებს მნიშვნელობებს ტიპის გარდაქმნით, === ადარებს მნიშვნელობებს ტიპის გარდაქმნის გარეშე",
        "ისინი ყველა შემთხვევაში იდენტურია",
        "=== უფრო ნელია ვიდრე ==",
        "== მუშაობს მხოლოდ რიცხვებთან"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "== ადარებს მნიშვნელობებს ტიპის გარდაქმნით, === ადარებს მნიშვნელობებს ტიპის გარდაქმნის გარეშე",
      "explanation": "=== არის მკაცრი თანასწორობა (ტიპის გარდაქმნის გარეშე), ხოლო == ახდენს ტიპის იძულებას, მას ეწოდება არამკაცრი ტოლობა, იგი არ ამოწმებს ტიპს."
    },
    "136": {
      "question": "როგორ შეგვიძლია რომ დავაკოპიროთ მასივი, ორიგინალის შეცვლის გარეშე?",
      "options": [
        "let copy = original;",
        "let copy = [...original];",
        "let copy = original.copy();",
        "let copy = new Array(original)"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "let copy = [...original];",
      "explanation": "გავრცელების ოპერატორის გამოყენებით იქმნება მასივის ზედაპირული ასლი ორიგინალის შეცვლის გარეშე."
    },
    "137": {
      "question": "რომელი მეთოდი გამოიყენება ორი მასივის გასაერთიანებლად?",
      "options": [
        "concat()",
        "merge()",
        "append()",
        "combine()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "concat()",
      "explanation": "concat() აკავშირებს ორ მასივს და აბრუნებს ახალ მასივს ორიგინალების შეცვლის გარეშე."
    },
    "138": {
      "question": "რა არის არჩევითი ჯაჭვური ოპერატორის (?.) დანიშნულება?",
      "options": [
        "ის თავიდან იცილებს შეცდომებს, თუ თვისება არ არსებობს",
        "ის გარდაქმნის undefined მნიშვნელობებს ცარიელ სტრიქონებად",
        "ის მუშაობს მხოლოდ მასივებთან",
        "ის აიძულებს მნიშვნელობას იყოს true"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის თავიდან იცილებს შეცდომებს, თუ თვისება არ არსებობს",
      "explanation": "სურვილისამებრ ჯაჭვური დაყოფა (?.) უსაფრთხოდ წვდება ღრმად ჩადგმულ თვისებებს შეცდომების გარეშე, თუ თვისება აკლია."
    },
    "139": {
      "question": "როგორ შევაჩეროთ setInterval ციკლი?",
      "options": [
        "clearTimeout()",
        "stopInterval()",
        "clearInterval()",
        "break"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "clearInterval()",
      "explanation": "setInterval() წყდება clearInterval()-ის გამოყენებით ინტერვალის ID-ით."
    },
    "140": {
      "question": "რას წარმოადგენს event delegation-ი ჯავასკრიპტში?",
      "options": [
        "ერთი event listener-ის მიმაგრება მშობელზე შვილების მოვლენების სამართავად",
        "მრავალი listener-ის შექმნა თითოეულ შვილ ელემენტზე",
        "მოვლენების დაყოვნება საჭიროებამდე",
        "ბრაუზერის ნაგულისხმევი ქმედებების თავიდან აცილება"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ერთი event listener-ის მიმაგრება მშობელზე შვილების მოვლენების სამართავად",
      "explanation": "მოვლენების დელეგირება აუმჯობესებს მუშაობას მშობელი ელემენტის მოსმენით და შვილეული მოვლენების დამუშავებით მოვლენების ბუშტუკების მეშვეობით."
    },
    "141": {
      "question": "რომელი ციკლი იძლევა გარანტიას, რომ ბლოკი ერთხელ მაინც გაიშვება?",
      "options": [
        "for ციკლი",
        "while ციკლი",
        "do...while ციკლი",
        "forEach ციკლი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "do...while ციკლი",
      "explanation": "do...while ციკლი პირობის შემოწმებამდე თავის ბლოკს ერთხელ მაინც ასრულებს."
    },
    "142": {
      "question": "როგორ შეგვიძლია შევქმნათ ობიექტის ღრმა ასლი, თანამედროვე ჯავასკრიპტში?",
      "options": [
        "let copy = {...obj};",
        "let copy = JSON.parse(JSON.stringify(obj));",
        "let copy = obj;",
        "let copy = obj.clone();"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "let copy = JSON.parse(JSON.stringify(obj));",
      "explanation": "JSON.parse(JSON.stringify(obj))-ის გამოყენებით, ობიექტის სტრიქონად და პირიქით გარდაქმნით, იქმნება ღრმა ასლი."
    },
    "143": {
      "question": "ჯავასკრიპტში რას აბრუნებს new Date() ფუნქცია?",
      "options": [
        "მიმდინარე თარიღისა და დროის სტრიქონი",
        "ობიექტი, რომელიც წარმოადგენს მიმდინარე თარიღსა და დროს",
        "1975 წლიდან წამების რაოდენობა",
        "Undefined"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ობიექტი, რომელიც წარმოადგენს მიმდინარე თარიღსა და დროს",
      "explanation": "new Date() ქმნის Date ობიექტს, რომელიც შეიცავს მიმდინარე თარიღსა და დროს, საიდანაც შეგიძლიათ ფორმატირება ან მნიშვნელობების ამოღება."
    },
    "144": {
      "question": "როგორ მივიღოთ მიმდინარე წლის თარიღი ობიექტიდან?",
      "options": [
        "new Date().getYear()",
        "new Date().getFullYear()",
        "new Date().year()",
        "Date.now().year"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "new Date().getFullYear()",
      "explanation": "getFullYear() აბრუნებს 4-ნიშნა წელს Date ობიექტიდან. getYear() მოძველებულია."
    },
    "145": {
      "question": "როგორ მივიღოთ მიმდინარე თვე, რიცხვის სახით(0-11), თარიღის ობიექტიდან?",
      "options": [
        "new Date().getMonth()",
        "new Date().getMonthNumber()",
        "new Date().month()",
        "Date.getMonth()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "new Date().getMonth()",
      "explanation": "getMonth() აბრუნებს ნულზე დაფუძნებულ ინდექსს (0 = იანვარი, 11 = დეკემბერი)."
    },
    "146": {
      "question": "რას მივიღებთ ამ კოდის გაშვებით: new Date(0)?",
      "options": [
        "1970 წლის 1 იანვარი, 00:00:00 UTC",
        "2000 წლის 1 იანვარი",
        "წლის პირველი დღე ადგილობრივი დროით",
        "Invalid Date"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "1970 წლის 1 იანვარი, 00:00:00 UTC",
      "explanation": "JavaScript-ში თარიღის ობიექტები მილიწამებს ითვლიან 1970 წლის 1 იანვრიდან UTC-ის დროით."
    },
    "147": {
      "question": "როგორ მივიღოთ თვის და დღე, Date ობიექტიდან?",
      "options": [
        "new Date().getDay()",
        "new Date().getDate()",
        "new Date().day()",
        "new Date().getMonth()"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "new Date().getDate()",
      "explanation": "getDate() აბრუნებს თვის დღეს (1-31). getDay() აბრუნებს კვირის დღეს (0-6)."
    },
    "148": {
      "question": "როგორ დავაფორმატოთ თარიღი წაკითხვად String-ტიპად?",
      "options": [
        "new Date().toString()",
        "new Date().toDateString()",
        "new Date().toLocaleDateString()",
        "ყველა ზემოთ ჩამოთვლილი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ყველა ზემოთ ჩამოთვლილი",
      "explanation": "ჯავასკრიპტი გვთავაზობს კონვერტაციის რამდენიმე მეთოდს, თარიღი ობიექტის სტრიქონად გადაყვანისთვის."
    },
    "149": {
      "question": "რას აკეთებს setTimeout?",
      "options": [
        "ფუნქციას დაუყოვნებლივ უშვებს",
        "გეგმავს ფუნქციის გაშვებას გარკვეული დაყოვნების შემდეგ",
        "ფუნქციას აჩერებს",
        "ფუნქციას უსასრულოდ იმეორებს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "გეგმავს ფუნქციის გაშვებას გარკვეული დაყოვნების შემდეგ",
      "explanation": "setTimeout-ი ადგენს ფუნქციისთვის გრაფიკს რომ გაუშვას იგი ერთხელ მითითებული მილიწამების შემდეგ."
    },
    "150": {
      "question": "რატომ შეიძლება დაგვჭირდეს clearTimeout-ის გამოყენება?",
      "options": [
        "დაგეგმილი ფუნქციის გასაუქმებლად სანამ იგი შესრულდება",
        "ტაიმაუტის ფუნქციის განმეორებისთვის",
        "ტაიმაუტის დასაჩქარებლად",
        "ის საჭიროა მხოლოდ ანიმაციებისთვის"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "დაგეგმილი ფუნქციის გასაუქმებლად სანამ იგი შესრულდება",
      "explanation": "clearTimeout(timerId) აჩერებს setTimeout-ის მიერ დანიშნულ ფუნქციას. იგი სასარგებლოა როდესაც გვინდა რომ თავიდან ავიცილოთ არასაჭირო კოდის ზედმეტჯერ გაშვება, მაგალითად როგორიცაა: სქროლონგის event-ები რეაქტში."
    },
    "151": {
      "question": "როგორ დავნიშნოთ ტაიმ-აუტი და შემდეგ გავაუქმოთ იგი?",
      "options": [
        "let timer = setTimeout(fn, 1000); clearTimeout(timer);",
        "setTimeout(fn, 1000).stop();",
        "setTimeout(fn, 1000).clear();",
        "let timer = setTimeout(fn, 1000); timer.cancel();"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "let timer = setTimeout(fn, 1000); clearTimeout(timer);",
      "explanation": "დაგეგმილი ფუნქციის გასაუქმებლად, ჩვენ უნდა შევინახოთ ტაიმერის ID-ი და იგი უნდა გადავცეთ clearTimeout() ფუნქციას."
    },
    "152": {
      "question": "როგორ გავიგოთ 1970 წლის 1 იანვრიდან გასული მილიწამების რაოდენობა?",
      "options": [
        "new Date().getTime()",
        "Date.now()",
        "ორივე Date().getTime() და Date.now() მუშაობს",
        "არცერთი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ორივე Date().getTime() და Date.now() მუშაობს",
      "explanation": "Date.now() აბრუნებს დროის ნიშნულს მილიწამებში. getTime() იგივეს აკეთებს Date ობიექტიდან."
    },
    "153": {
      "question": "როგორ შევქმნათ ფუნქცია, რომელიც ყოველ 2 წამში გამეორდება?",
      "options": [
        "setTimeout(fn, 2000)",
        "setInterval(fn, 2000)",
        "while(true) fn()",
        "setRepeat(fn, 2000)"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "setInterval(fn, 2000)",
      "explanation": "setInterval ფუნქციას განსაზღვრული ინტერვალით განმეორებით გასაშვებად ადგენს გრაფიკს."
    },
    "154": {
      "question": "როგორ შევაჩეროთ setInterval ციკლი რაიმე პირობის დაკმაყოფილების შემდეგ?",
      "options": [
        "clearInterval(intervalId)",
        "stopInterval(intervalId)",
        "intervalId.cancel()",
        "setTimeout(intervalId, 0)"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "clearInterval(intervalId)",
      "explanation": "შეინახეთ setInterval-ის მიერ დაბრუნებული ID და გადაეცით ის clearInterval()-ს ციკლის შესაჩერებლად."
    },
    "155": {
      "question": "რატომ შეიძლება გამოვიყენოთ setTimeout გადახვევის მოვლენის მსმენელში(scroll event listener)?",
      "options": [
        "კოდის შესრულების დაყოვნებისა და წარმადობის გასაუმჯობესებლად",
        "გადახვევის დასაჩქარებლად",
        "გადახვევის ანიმაციების დაუყოვნებლივ გასაშვებად",
        "მომხმარებლის შეყვანის დასაბლოკად"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "კოდის შესრულების დაყოვნებისა და წარმადობის გასაუმჯობესებლად",
      "explanation": "React-სა და vanilla JS-ში, ძვირადღირებული გამოთვლების შეფუთვა setTimeout-ში, სქროლ events-ების დროს ამცირებს შესრულების სიხშირეს და აუმჯობესებს შესრულებას."
    },
    "156": {
      "question": "რას ნიშნავს ტერმინი - „Vanilla JavaScript“?",
      "options": [
        "იგი არის ჯავასკრიპტის ერთ-ერთი ბიბლიოთეკა, მაგალითად როგორებიცაა: React-ი და Vue.",
        "უბრალო ჯავასკრიპტი ყოველგვარი ბიბლიოთეიკს და framework-ების გარეშე.",
        "უბრალო ჯავასკრიპტი რომელიც აქცენტირებულია მობილურის კოდირებებზე.",
        "გამარტივებული TypeScript-ის ვერსია."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "უბრალო ჯავასკრიპტი ყოველგვარი ბიბლიოთეიკს და framework-ების გარეშე.",
      "explanation": "Vanilla JavaScript-ი მარტივი სიტყვებით რომ ვთქვათ ნიშნავს  სტანდარტული ჯავასკრიპტის გამოყენებას(ძირითადი ენა), მესამე მხარის ბიბლიოთეკებზე ან ჩარჩოებზე დაყრდნობის გარეშე, როგორებიცაა: jQuery, React ან Angular."
    },
    "157": {
      "question": "ჩვეულებრივ სად გამოიყენება Vanilla JavaScript-ი?",
      "options": [
        "იგი გამოიყენება მხოლოდ Back-End აპლიკაციებში.",
        "გამოიყენება იშვიათ შემთხვევებში, და გამოიყენება მხოლოდ DOM მანიპულაციებისთვის.",
        "გამოიყენება ბრაუზერში, DOM-მანიპულაციებისთვის, ლოგიკებში და ბიბლიოთეკების გარეშე ფუნქციების ჩამოყალიბებისთვის.",
        "მისი გამოყენება შეუძლებელია რეალურ პროექტებში."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "გამოიყენება ბრაუზერში, DOM-მანიპულაციებისთვის, ლოგიკებში და ბიბლიოთეკების გარეშე ფუნქციების ჩამოყალიბებისთვის.",
      "explanation": "Vanilla JavaScript გამოიყენება ბრაუზერებში DOM-ის მანიპულირებისთვის, მოვლენების დასამუშავებლად, ლოგიკის შესასრულებლად და ინტერაქტიული ფუნქციების შესაქმნელად გარე ხელსაწყოების ან ჩარჩოების საჭიროების გარეშე."
    },
    "158": {
      "question": "რამდენ არგუმენტს იყენებს addEventListener-ი და რას წარმოადგენს თითოეული მათგანი?",
      "options": [
        "2 არგუმენტი: მოვლენის ტიპი და callback ფუნქცია",
        "3 არგუმენტი: მოვლენის ტიპი, callback ფუნქცია, options (მაგ: capture, once, passive)",
        "5 არგუმენტი: მოვლენის ტიპი, callback, capture, once, passive",
        "მხოლოდ 1 არგუმენტი: მოვლენის ტიპი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "3 არგუმენტი: მოვლენის ტიპი, callback ფუნქცია, options (მაგ: capture, once, passive)",
      "explanation": "addEventListener(type, callback, options) იღებს მოვლენის ტიპს (string), callback ფუნქციას და არჩევით options ობიექტს ან ლოგიკურ მნიშვნელობას."
    },
    "159": {
      "question": "addEventListener('scroll', handleScroll)-ში, რას წარმოადგენენ პირველი და მეორე არგუმენტები?",
      "options": [
        "პირველი არგუმენტი: მოვლენის ტიპი; მეორე არგუმენტი: ფუნქცია, რომელიც შესრულდება მოვლენისას",
        "პირველი არგუმენტი: callback ფუნქცია; მეორე არგუმენტი: მოვლენის ტიპი",
        "პირველი არგუმენტი: გაშვების რაოდენობა; მეორე არგუმენტი: ფუნქციის სახელი",
        "ორივე არგუმენტი არჩევითია"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "პირველი არგუმენტი: მოვლენის ტიპი; მეორე არგუმენტი: ფუნქცია, რომელიც შესრულდება მოვლენისას",
      "explanation": "პირველი არგუმენტი არის სტრიქონი, რომელიც წარმოადგენს მოვლენის ტიპს (მაგ., „გადახვევა“, „დაწკაპუნება“), ხოლო მეორე არის ფუნქცია, რომელიც სრულდება მოვლენის გააქტიურებისას."
    },
    "160": {
      "question": "რას აკეთებს addEventListener-ში „once“ პარამეტრი?",
      "options": [
        "მოვლენის მსმენელს ასრულებს მხოლოდ ერთხელ და შემდეგ შლის",
        "მოვლენის მსმენელს უსასრულოდ იმეორებს",
        "აჩერებს სხვა event listener-ების გაშვებას",
        "მოვლენის ტიპს ავტომატურად ცვლის"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "მოვლენის მსმენელს ასრულებს მხოლოდ ერთხელ და შემდეგ შლის",
      "explanation": "პარამეტრებში { once: true }-ის დაყენება უზრუნველყოფს, რომ მსმენელი ერთხელ გაშვებული იქნება, შემდეგ კი ავტომატურად წაიშლება."
    },
    "161": {
      "question": "რას აკეთებს addEventListener-ში „passive“ პარამეტრი, გადახვევის მოვლენებისთვის?",
      "options": [
        "ბრაუზერს ეუბნება, რომ listener არ გამოიძახებს preventDefault(), რაც აუმჯობესებს scroll-ის შესრულებას",
        "აჩერებს listener-ის გაშვებას",
        "აგვიანებს მოვლენას 1 წამით",
        "საშუალებას აძლევს ერთდროულად რამდენიმე listener-ს გაეშვას"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ბრაუზერს ეუბნება, რომ listener არ გამოიძახებს preventDefault(), რაც აუმჯობესებს scroll-ის შესრულებას",
      "explanation": "პასიური მსმენელები აუმჯობესებენ შესრულებას ისეთ მოვლენებზე, როგორიცაა გადახვევა ან შეხება, იმის სიგნალიზებით, რომ ისინი ბრაუზერს არ დაბლოკავენ."
    },
    "162": {
      "question": "რას აკეთებს 'capture' პარამეტრი, addEventListener-ში?",
      "options": [
        "აიძულებს მოვლენას გაეშვას capture ფაზაში, bubbling-ის ფაზის ნაცვლად",
        "სრულიად აჩერებს მოვლენას",
        "აგვიანებს მოვლენას",
        "ავტომატურად ცვლის მოვლენის ტიპს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "აიძულებს მოვლენას გაეშვას capture ფაზაში, bubbling-ის ფაზის ნაცვლად",
      "explanation": "capture: true აიძულებს listener-ს შეასრულოს მოქმედება, როდესაც მოვლენა DOM ხეზე გადავა, სამიზნემდე მიღწევამდე."
    },
    "163": {
      "question": "როდის იქნა გამოგონებული JavaScript-ი, და ვინ გამოიგონა იგი?",
      "options": [
        "1995 წელი, ბრენდან აიხი",
        "2000 წელი, ტიმ ბერნერს-ლი",
        "1992 წელი, დენის რიტჩი",
        "1998 წელი, გაიდო ვან როსუმი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "1995 წელი, ბრენდან აიხი",
      "explanation": "JavaScript შეიქმნა 1995 წელს ბრენდან აიხის მიერ Netscape-ში მუშაობის დროს. თავდაპირველად მას Mocha ერქვა, შემდეგ LiveScript და ბოლოს სახელი შეიცვალა და JavaScript დაერქვა."
    },
    "164": {
      "question": "რა დრო დასჭირდა ჯავასკრიპტის პირველი ვერსიის შექმნას და რატომ ეწოდა მას ჯავასკრიპტი?",
      "options": [
        "10 დღე, მარკეტინგული მიზეზების გამო, რომ სარგებლობა მოეტანა Java-ს პოპულარობით",
        "1 წელი, რადგან აშენდა Java-ზე",
        "6 თვე, ბრენდან აიხის საპატივსაცემოდ",
        "3 კვირა, სახელწოდება შემთხვევით შეირჩა"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "10 დღე, მარკეტინგული მიზეზების გამო, რომ სარგებლობა მოეტანა Java-ს პოპულარობით",
      "explanation": "ბრენდან აიჩმა JavaScript-ის პირველი ვერსია სულ რაღაც 10 დღეში, 1995 წელს შეიმუშავა. Netscape-მა მას JavaScript უწოდა მარკეტინგული სტრატეგიის სახით, რათა ისარგებლა Java-ს იმ დროს აჟიოტაჟით, მიუხედავად იმისა, რომ ეს ორი ენა ერთმანეთთან კავშირში არ არის."
    },
    "165": {
      "question": "რატომ სწავლობენ დეველოპერები ხშირად უფრო სწრაფად პროექტების შექმნით, ვიდრე ონლაინ გაკვეთილების ყურებით?",
      "options": [
        "პროექტები გვაიძულებს გამოვიყენოთ კონცეფციები და მოვაგვაროთ რეალური პრობლემები",
        "YouTube გაკვეთილები ყოველთვის მცდარია",
        "პროექტები მხოლოდ HTML-ს ასწავლის",
        "YouTube ვიდეოები ძალიან მოკლეა"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "პროექტები გვაიძულებს გამოვიყენოთ კონცეფციები და მოვაგვაროთ რეალურიProblemebi",
      "explanation": "პროექტების აქტიური შექმნა აძლიერებს ცოდნას, ავლენს ხარვეზებს და იძლევა პრაქტიკულ გამოცდილებას, რასაც მხოლოდ ვიდეოები ვერ უზრუნველყოფენ."
    },
    "166": {
      "question": "რა იყო ჯავასკრიპტის შექმნის მთავარი მიზანი?",
      "options": [
        "ვებსაიტების ინტერაქტიულობისა და დინამიკურობის შექმნა ბრაუზერებში",
        "Java-ს სრულად შეცვლა",
        "ოპერაციული სისტემების შექმნა",
        "მხოლოდ მობილური აპლიკაციებისთვის"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ვებსაიტების ინტერაქტიულობისა და დინამიკურობის შექმნა ბრაუზერებში",
      "explanation": "JavaScript შეიქმნა დეველოპერებისთვის, რათა მათ საშუალება მისცემოდათ დაემატებინათ ინტერაქტიულობა, ემართათ მომხმარებლის მოქმედებები და გაეხადათ ვებგვერდები დინამიური — რისი მიღწევაც მხოლოდ HTML-ით და CSS-ით შეუძლებელი იყო."
    },
    "167": {
      "question": "რატომ არის ჯავასკრიპტი ასე ცნობილი, ვებ პროგრამირებაში?",
      "options": [
        "ის მუშაობს ყველა ბრაუზერში და უზრუნველყოფს ინტერაქტიულ front-end განვითარებას",
        "ის გამოიყენება მხოლოდ Node.js-ში",
        "ის უფრო სწრაფია ვიდრე C++",
        "ის სწავლას საერთოდ არ საჭიროებს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის მუშაობს ყველა ბრაუზერში და უზრუნველყოფს ინტერაქტიულ front-end განვითარებას",
      "explanation": "JavaScript-ის ყველგანმყოფობა, მრავალფეროვნება (front-end + back-end) და ეკოსისტემა მას უკიდურესად პოპულარულს ხდის."
    },
    "168": {
      "question": "რომელ ენაზე დაიწერა ჯავასკრიპტის პირველი ვერსია?",
      "options": [
        "C",
        "Java",
        "Assembly",
        "Python"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "C",
      "explanation": "JavaScript-ის პირველი იმპლემენტაცია, სახელწოდებით Mocha (მოგვიანებით LiveScript, შემდეგ JavaScript), C ენაზე დაწერა ბრენდან აიხმა Netscape-ში 1995 წელს."
    },
    "169": {
      "question": "ჩამოთვლილთაგან რომელია ჯავასკრიპტის ახალი კონცეფციების დამახსოვრებისა და გაგების ყველაზე ეფექტური გზა?",
      "options": [
        "პრაქტიკა პატარა პროექტებში და რეალურ პრობლემებში",
        "მხოლოდ დოკუმენტაციის კითხვა კოდის გარეშე",
        "ბევრი ტუტორიალის ყურება კოდის გარეშე",
        "კოდის დამახსოვრება მის გაგების გარეშე"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "პრაქტიკა პატარა პროექტებში და რეალურ პრობლემებში",
      "explanation": "აქტიური პრაქტიკა და კონცეფციების პროექტებში გამოყენება აძლიერებს ცოდნას და აუმჯობესებს ინფორმაციის ხანგრძლივად შენახვას."
    },
    "170": {
      "question": "რას დააბრუნებს ჯავასკრიპტის ეს მასივი შედეგად: [3, 1, 4, 2].sort()?",
      "options": [
        "[1, 2, 3, 4]",
        "[3, 1, 4, 2]",
        "[1, 2, 3, 4] (რიცხვები სტრიქონებად)",
        "Error"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "[1, 2, 3, 4] (რიცხვები სტრიქონებად)",
      "explanation": "sort() გარდაქმნის რიცხვებს სტრიქონებად და ახარისხებს მათ ლექსიკოგრაფიულად. რიცხვითი დახარისხებისთვის საჭიროა compare ფუნქცია."
    },
    "171": {
      "question": "რომელია სწორი ჩანაწერი მასივის ელემენტების ზრდადობით დასალაგებლად, sort მეთოდის გამოყენებით?",
      "options": [
        "[3,1,4,2].sort((a,b)=>a-b)",
        "[3,1,4,2].sort()",
        "[3,1,4,2].sort((a,b)=>b-a)",
        "გამოიყენე reverse()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "[3,1,4,2].sort((a,b)=>a-b)",
      "explanation": "შედარების ფუნქციის უზრუნველყოფა უზრუნველყოფს რიცხვით დახარისხებას სტრიქონებზე დაფუძნებული ლექსიკოგრაფიული დახარისხების ნაცვლად."
    },
    "172": {
      "question": "რომელი მეთოდი აბრუნებს Date ობიექტის სრულ წელს?",
      "options": [
        "getFullYear()",
        "getYear()",
        "getMonth()",
        "toString()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "getFullYear()",
      "explanation": "getFullYear() აბრუნებს ოთხნიშნა წელს, მაგ: 2025. getYear() მოძველებულია."
    },
    "173": {
      "question": "როგორ მივიღოთ მიმდინარე თვე (0-11), Date ობიექტიდან?",
      "options": [
        "date.getMonth()",
        "date.getFullMonth()",
        "date.getMonthNumber()",
        "date.getMonthName()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "date.getMonth()",
      "explanation": "getMonth() იანვრისთვის აბრუნებს 0-ს, დეკემბრისთვის კი 11-ს."
    },
    "174": {
      "question": "რას აკეთებს setTimeout-ი ჯავასკრიპტში?",
      "options": [
        "აგზავნის ფუნქციას დაგვიანებით შესასრულებლად",
        "რეგულარულად უშვებს ფუნქციას განმეორებით",
        "აჩერებს კოდის შესრულებას",
        "მალევე იძახებს ფუნქციას"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "აგზავნის ფუნქციას დაგვიანებით შესასრულებლად",
      "explanation": "setTimeout ფუნქციის გაშვებას განსაზღვრული მილიწამების შემდეგ გეგმავს."
    },
    "175": {
      "question": "რომელი მეთოდი ასრულებს ფუნქციას განმეორებით ფიქსირებული ინტერვალებით?",
      "options": [
        "setTimeout()",
        "setInterval()",
        "clearTimeout()",
        "requestAnimationFrame()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "setInterval()",
      "explanation": "setInterval() ფუნქციას მოცემული დროის ინტერვალში განმეორებით ასრულებს, სანამ არ გაიწმინდება."
    },
    "176": {
      "question": "როგორ გავაუქმოთ setTimeout?",
      "options": [
        "clearTimeout(timeoutID)",
        "clearInterval(timeoutID)",
        "stopTimeout(timeoutID)",
        "setTimeout(null)"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "clearTimeout(timeoutID)",
      "explanation": "clearTimeout() თავისი ID-ის გამოყენებით აუქმებს მომლოდინე setTimeout-ს."
    },
    "177": {
      "question": "რომელი საკვანძო სიტყვა გამოიყენება მოდულიდან ფუნქციების ან ცვლადების ექსპორტისთვის?",
      "options": [
        "export",
        "import",
        "module",
        "require"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "export",
      "explanation": "ექსპორტი საშუალებას გაძლევთ, ფუნქციები, ობიექტები ან ცვლადები სხვა მოდულებისთვის ხელმისაწვდომი გახადოთ."
    },
    "178": {
      "question": "როგორ ხდება მოდულიდან დასახელებული ექსპორტის იმპორტი?",
      "options": [
        "import {name} from './module.js'",
        "import name from './module.js'",
        "require('./module.js')",
        "include('./module.js')"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "import {name} from './module.js'",
      "explanation": "მოდულიდან დასახელებული ექსპორტის იმპორტისთვის გამოიყენება ხვეული ფრჩხილები {}."
    },
    "179": {
      "question": "რა განსხვავებაა ნაგულისხმევ ექსპორტსა და დასახელებულ ექსპორტს შორის?",
      "options": [
        "ნაგულისხმევი ექსპორტი თითო ფაილში მხოლოდ ერთია; დასახელებულ ექსპორტებს შეიძლება მრავალი ჰქონდეს",
        "ნაგულისხმევი ექსპორტი მხოლოდ ფუნქციებს ექსპორტირებს; დასახელებული კი ნებისმიერ რამეს",
        "დასახელებული ექსპორტი ძველი სინტაქსია",
        "არანაირი განსხვავება"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ნაგულისხმევი ექსპორტი თითო ფაილში მხოლოდ ერთია; დასახელებულ ექსპორტებს შეიძლება მრავალი ჰქონდეს",
      "explanation": "ნაგულისხმევი ექსპორტი იმპორტირებულია {}-ის გარეშე, ხოლო დასახელებული ექსპორტი უნდა იმპორტირებული იყოს {}-ში მოცემული მათი ზუსტი სახელის გამოყენებით."
    },
    "180": {
      "question": "რას წარმოადგენს დახურვა(Closure), ჯავასკრიპტში?",
      "options": [
        "ფუნქცია, რომელიც იმახსოვრებს გარე სკოპის ცვლადებს",
        "პირადი ცვლადი",
        "Arrow ფუნქცია",
        "ციკლი, რომელიც პირობაზე ჩერდება"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ფუნქცია, რომელიც იმახსოვრებს გარე სკოპის ცვლადებს",
      "explanation": "დახურვები შიდა ფუნქციებს საშუალებას აძლევს, წვდომა ჰქონდეთ ცვლადებზე გარე ფუნქციებიდან, მაშინაც კი, როდესაც გარე ფუნქცია ასრულებს თავის ფუნქციას."
    },
    "181": {
      "question": "რომელი სცენარია ყველაზე ხშირად გამოყენებული დახურვისთვის(Closure)?",
      "options": [
        "პირადი ცვლადების და ფუნქციების შექმნა",
        "მასივის სორტირება",
        "DOM-ის მანიპულირება",
        "ლუპის გაჩქარება"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "პირადი ცვლადების და ფუნქციების შექმნა",
      "explanation": "Closure-ებს შეუძლიათ ცვლადების გლობალური მასშტაბიდან დამალვა, ამავდროულად, ფუნქციების შიგნით მათი ხელმისაწვდომობა კვლავ შესაძლებელია."
    },
    "182": {
      "question": "ჯავასკრიპტში, კონკრეტულად რას აკეთებს async/await-ი?",
      "options": [
        "მას საშუალებას აძლევს ასინქრონული კოდი დაწეროთ სინქრონული სტილით",
        "ფუნქციებს სინქრონულს ხდის",
        "მთავარ ნაკადს ბლოკავს",
        "ავტომატურად თავიდან აწყობს Network შეცდომებს"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მას საშუალებას აძლევს ასინქრონული კოდი დაწეროთ სინქრონული სტილით",
      "explanation": "async/await ამარტივებს დაპირებების დამუშავებას, საშუალებას გაძლევთ დაწეროთ ასინქრონული კოდი, რომელიც ჩვეულებრივი თანმიმდევრული კოდის მსგავსი იქნება."
    },
    "183": {
      "question": "ჩამოთვლილთაგან რომელი ფაქტია ჭეშმარიტი Promise-ებზე დაყრდნობით?",
      "options": [
        "წარმოადგენს მნიშვნელობას, რომელიც შეიძლება იყოს ხელმისაწვდომი ახლა, მოგვიანებით ან არასდროს",
        "ყოველთვის დაუყოვნებლივ იხსნება",
        "კოდის შესრულებას ბლოკავს",
        "მხოლოდ მასივებისთვის გამოიყენება"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "წარმოადგენს მნიშვნელობას, რომელიც შეიძლება იყოს ხელმისაწვდომი ახლა, მოგვიანებით ან არასდროს",
      "explanation": "დაპირება არის ობიექტი, რომელიც წარმოადგენს ასინქრონული ოპერაციის საბოლოო დასრულებას (ან წარუმატებლობას)."
    },
    "184": {
      "question": "როგორ უნდა გავუმკლავდეთ შეცდომებს async/await-ის ფუნქციებში?",
      "options": [
        "try/catch ბლოკების გამოყენებით",
        "if/else გამოყენებით",
        "for ლუპის გამოყენებით",
        "switch-ის გამოყენებით"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "try/catch ბლოკების გამოყენებით",
      "explanation": "try/catch საშუალებას გაძლევთ დაიჭიროთ უარყოფილი დაპირებები ან გამონაკლისები ასინქრონულ ფუნქციებში."
    },
    "185": {
      "question": "fetch()-ის რომელი მეთოდი აბრუნებს დაპირებას?",
      "options": [
        "fetch('url')",
        "XMLHttpRequest.send()",
        "console.log()",
        "setTimeout()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "fetch('url')",
      "explanation": "fetch() არის თანამედროვე API ქსელური მოთხოვნების განსახორციელებლად და აბრუნებს დაპირებას, რომელიც წყდება Response ობიექტით."
    },
    "186": {
      "question": "რას დაბეჭდავს ეს მოკლე კოდი: async function test(){ console.log(1); await Promise.resolve(); console.log(2);} test(); console.log(3);.?",
      "options": [
        "1 3 2",
        "1 2 3",
        "3 1 2",
        "1 2 3 3"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "1 3 2",
      "explanation": "კოდი აღრიცხავს 1-ს, შემდეგ დაელოდება გაგრძელებას მიკროდავალების სახით, აღრიცხავს 3-ს და შემდეგ აგრძელებს 2-ით."
    },
    "187": {
      "question": "ჩამოთვლილთაგან რომელია სწორი ჯავასკრიპტ მოვლენათა ციკლის შესახებ?",
      "options": [
        "მას უწევს ზარების დასტასა და ტასკ/მიკროტასკ რიგების გადამუშავება",
        "ასინქრონულ ფუნქციებს ბლოკავს",
        "კოდს უკუპროცესად ასრულებს",
        "მხოლოდ Node.js-ზე მუშაობს"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მას უწევს ზარების დასტასა და ტასკ/მიკროტასკ რიგების გადამუშავება",
      "explanation": "მოვლენების ციკლი განუწყვეტლივ ამოწმებს ზარების დასტას და ასინქრონულად ასრულებს რიგში მყოფ დავალებებსა და მიკროდავალებებს."
    },
    "188": {
      "question": "ჩამოთვლილთაგან რომელი შეიძლება იყოს microtask-ი?",
      "options": [
        "Promise.then-ის უკუკავშირები",
        "setTimeout callback",
        "for loop",
        "console.log()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "Promise.then-ის უკუკავშირები",
      "explanation": "Promise.then უკუკავშირები რიგშია მიკროდავალებების სახით და სრულდება მიმდინარე შესრულების კონტექსტის შემდეგ, მაგრამ შემდეგ მაკროდავალებამდე."
    },
    "189": {
      "question": "როგორ უნდა გავაუქმოთ fetch-ინგის მოთხოვნა?",
      "options": [
        "AbortController-ის გამოყენებით",
        "clearTimeout-ის გამოყენებით",
        "try/catch-ის გამოყენებით",
        "finally-ის გამოყენებით"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "AbortController-ის გამოყენებით",
      "explanation": "AbortController საშუალებას გაძლევთ გააუქმოთ fetch მოთხოვნები მისი signal თვისების fetch()-ზე გადაცემით და საჭიროების შემთხვევაში abort()-ის გამოძახებით."
    },
    "190": {
      "question": "რომელია სწორი ჩანაწერი მასივის ელემენტების ზრდადობით დასალაგებლად, sort მეთოდის გამოყენებით?",
      "options": [
        "[3,1,4,2].sort((a,b)=>a-b)",
        "[3,1,4,2].sort()",
        "[3,1,4,2].sort((a,b)=>b-a)",
        "გამოიყენეთ reverse()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "[3,1,4,2].sort((a,b)=>a-b)",
      "explanation": "შედარების ფუნქციის უზრუნველყოფა უზრუნველყოფს რიცხვით დახარისხებას სტრიქონებზე დაფუძნებული ლექსიკოგრაფიული დახარისხების ნაცვლად."
    },
    "191": {
      "question": "ჩამოთვლილთაგან რომელი მოვლენა(event) აქტიურდება, როცა მომხმარებელი დააწკაპუნებს ელემენტზე?",
      "options": [
        "click",
        "dblclick",
        "mouseover",
        "keydown"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "click",
      "explanation": "„დაწკაპუნების“ მოვლენა(Event) აქტიურდება, როდესაც მომხმარებელი ელემენტზე აჭერს და ათავისუფლებს მაუსის ღილაკს."
    },
    "192": {
      "question": "რომელი მოვლენა(event) აქტიურდება, მაშინ როცა მომხმარებელი ორჯერ დააწკაპუნებს ელემენტზე?",
      "options": [
        "dblclick",
        "click",
        "mousedown",
        "mouseup"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "dblclick",
      "explanation": "„dblclick“ აქტიურდება ერთსა და იმავე ელემენტზე მოკლე დროში ზედიზედ ორი დაწკაპუნების შემდეგ."
    },
    "193": {
      "question": "რომელი მოვლენა(event) აქტიურდება მაშინ, როდესაც მაუსით გადავივლით ელემენტზე?",
      "options": [
        "mouseover",
        "mouseout",
        "mouseenter",
        "mousemove"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "mouseover",
      "explanation": "„მაუსის გადატანა“ აქტიურდება, როდესაც მაჩვენებელი შედის ელემენტში ან მის შვილობილ ელემენტებში."
    },
    "194": {
      "question": "რომელი მოვლენა(event) აქტიურდება მაშინ, როდესაც მაუსის მაჩვენებელი დატოვებს ელემენტს?",
      "options": [
        "mouseout",
        "mouseleave",
        "mouseover",
        "mousemove"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "mouseout",
      "explanation": "„mouseout“ აქტიურდება, როდესაც მაჩვენებელი ტოვებს ელემენტს ან მის რომელიმე შვილობილ ელემენტს."
    },
    "195": {
      "question": "რომელი მოვლენა აქტიურდება ღილაკზე დაჭერისას?",
      "options": [
        "keydown",
        "keyup",
        "keypress",
        "input"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "keydown",
      "explanation": "„keydown“ აქტიურდება ღილაკზე პირველად დაჭერისას. ის მეორდება, თუ ღილაკზე დაჭერა შეგეძლებათ."
    },
    "196": {
      "question": "რომელი მოვლენა აქტიურდება გასაღების გაშვებისას?",
      "options": [
        "keyup",
        "keydown",
        "keypress",
        "change"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "keyup",
      "explanation": "„keyup“ აქტიურდება დაჭერილი კლავიშის გაშვებისას."
    },
    "197": {
      "question": "რომელი მოვლენაა მოძველებული და გამოიყენება მხოლოდ სიმბოლოების გასაღებებისთვის?",
      "options": [
        "keypress",
        "keydown",
        "keyup",
        "input"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "keypress",
      "explanation": "„keypress“ გამოიყენებოდა მხოლოდ დასაბეჭდი სიმბოლოებისთვის და ახლა მოძველებულია „keydown“-ისა და „keyup“-ის სასარგებლოდ."
    },
    "198": {
      "question": "როგორ ავიცილოთ თავიდან მოვლენის ნაგულისხმევი მოქმედება?",
      "options": [
        "event.preventDefault()",
        "event.stopPropagation()",
        "return false",
        "event.block()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "event.preventDefault()",
      "explanation": "preventDefault() აუქმებს მოვლენის ნაგულისხმევ ქცევას, მაგალითად, ბმულზე ნავიგაციის აკრძალვას."
    },
    "199": {
      "question": "რომელი მეთოდის საშუალებით შეგვიძლია შევაჩეროთ DOM ხეზე ბუშტების(bubbling) წარმოქმნა?",
      "options": [
        "event.stopPropagation()",
        "event.preventDefault()",
        "return false",
        "event.block()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "event.stopPropagation()",
      "explanation": "stopPropagation() ხელს უშლის მოვლენას მშობელ ელემენტებამდე მიღწევაში(მაგ: გვაქვს ერთი ხუთი რომელშიც მოთავსებულია მეორე ყუთი, ჩვენ გვინდა რომ მხოლოდ გარე ყუთზე დაწკაპუნებისას გაითიშოს ორივე ყუთი, და არგვინდა რომ მსგავსი მოხდეს შიდა ყუთზე)."
    },
    "200": {
      "question": "რა არის Event დელეგაცია?",
      "options": [
        "მშობელ ელემენტზე ერთი მსმენელის დამაგრება, რომელიც მართავს შვილობილ ელემენტებზე მოვლენებს",
        "მრავალჯერადი მსმენელის დამატება თითოეულ შვილობილ ელემენტზე",
        "setTimeout-ის გამოყენება მოვლენების დასაგვიანებლად",
        "Arrow ფუნქციების გამოყენება მოვლენებისთვის"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მშობელ ელემენტზე ერთი მსმენელის დამაგრება, რომელიც მართავს შვილობილ ელემენტებზე მოვლენებს",
      "explanation": "მოვლენების(event) დელეგაცია აუმჯობესებს მუშაობას, ერთი მსმენელის გამოყენებით, მრავალი შვილობილი ელემენტისთვის და მოვლენების ბუშტუკებზე დაყრდნობით."
    },
    "201": {
      "question": "რომელი მეთოდი ირჩევს პირველ ელემენტს, რომელიც შეესაბამება CSS სელექტორს?",
      "options": [
        "document.querySelector()",
        "document.getElementById()",
        "document.getElementsByClassName()",
        "document.querySelectorAll()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "document.querySelector()",
      "explanation": "querySelector() აბრუნებს პირველ ელემენტს, რომელიც შეესაბამება CSS სელექტორის სტრიქონს."
    },
    "202": {
      "question": "რომელი მეთოდი ირჩევს ყველა ელემენტს, რომელიც შეესაბამება CSS სელექტორს?",
      "options": [
        "document.querySelectorAll()",
        "document.querySelector()",
        "document.getElementById()",
        "document.getElementsByTagName()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "document.querySelectorAll()",
      "explanation": "querySelectorAll() აბრუნებს სელექტორთან შესაბამისი ყველა ელემენტის NodeList-ს."
    },
    "203": {
      "question": "როგორ უნდა შევქმნათ ახალი ელემენტი DOM-ში?",
      "options": [
        "document.createElement('tagName')",
        "document.newElement('tagName')",
        "document.appendChild('tagName')",
        "document.makeElement('tagName')"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "document.createElement('tagName')",
      "explanation": "createElement() ქმნის ახალ ელემენტს, რომლის დამატებაც შემდეგ შესაძლებელია DOM-ში."
    },
    "204": {
      "question": "რომელი მეთოდი ამატებს შვილობილ ელემენტს მშობელ ელემენტს?",
      "options": [
        "parent.appendChild(child)",
        "parent.addChild(child)",
        "parent.insert(child)",
        "parent.createChild(child)"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "parent.appendChild(child)",
      "explanation": "appendChild() მითითებულ შვილობილ ელემენტს მშობელი ელემენტის შვილობილი ელემენტების ბოლოს უმატებს."
    },
    "205": {
      "question": "როგორ უნდა ამოვშალოთ ელემენტი DOM(Document object model)-იდან?",
      "options": [
        "მხოლოდ element.remove()-ით",
        "მხოლოდ element.delete()-ით",
        "მხოლოდ parent.removeChild()-ით",
        "ორივე .remove() და .removeChild() მუშაობს."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ორივე .remove() და .removeChild() მუშაობს.",
      "explanation": "element.remove() პირდაპირ შლის ელემენტს, ან parent.removeChild(element)-ს შეუძლია მისი წაშლა მშობლის მეშვეობით."
    },
    "206": {
      "question": "როგორ მივიღოთ წვდომა შეყვანის ელემენტის მნიშვნელობაზე id 'name'-ის გამოყენებით?",
      "options": [
        "document.getElementById('name').value",
        "document.getElementById('name').text",
        "document.querySelector('#name').innerText",
        "document.querySelector('#name').val"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "document.getElementById('name').value",
      "explanation": "value თვისება ინახავს შეყვანის ელემენტების მიმდინარე შინაარსს."
    },
    "207": {
      "question": "კონკრეტულად რომელი event-ი აქტიურდება როდესაც ხდება input-ტეგის ღირებულების(value) შეცვლა?",
      "options": [
        "input",
        "change",
        "keyup",
        "keydown"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "input",
      "explanation": "შეყვანის(Input) მოვლენა აქტიურდება ყოველ ჯერზე, როდესაც მნიშვნელობა იცვლება, ხოლო „ცვლილება“ აქტიურდება, როდესაც ფოკუსი ტოვებს შეყვანის ადგილს."
    },
    "208": {
      "question": "როგორ უნდა მივაერთოთ მოვლენების მსმენელი ეფექტურად, ბევრ დინამიურ ელემენტზე?",
      "options": [
        "გამოყენება Event დელეგაციის მშობელ ელემენტზე",
        "მთელი ელემენტისთვის ინდივიდუალური მსმენელების დაერთება",
        "setTimeout-ის გამოყენება თითოეულ ელემენტზე",
        "document.write-ის გამოყენება"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "გამოყენება Event დელეგაციის მშობელ ელემენტზე",
      "explanation": "მოვლენების დელეგირება მშობელს საშუალებას აძლევს, შვილებისგან მოვლენები ბუშტუკების მეშვეობით მართოს, რაც დინამიური ელემენტების მუშაობას აუმჯობესებს."
    },
    "209": {
      "question": "მოვლენის ობიექტის რომელი თვისება გვაძლევს ელემენტს, რომელმაც გამოიწვია მოვლენა(Event)?",
      "options": [
        "event.target",
        "event.currentTarget",
        "event.srcElement",
        "event.origin"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "event.target",
      "explanation": "event.target ეხება ელემენტს, საიდანაც მოვლენა წარმოიშვა, ხოლო currentTarget არის ელემენტი, რომელზეც მიმაგრებულია listener."
    },
    "210": {
      "question": "როგორ უნდა ავიცილოთ თავიდან ფორმის ნორმალურად წარდგენა?",
      "options": [
        "event.preventDefault() submit ჰენდლერის შიგნით",
        "return false submit ჰენდლერში",
        "ორივე: .preventDefault() და return false submit ჰენდლერში",
        "ფორმის წარდგენა არ შეიძლება აიკრძალოს"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ორივე: .preventDefault() და return false submit ჰენდლერში",
      "explanation": "event.preventDefault()-ის გამოძახება ან დამმუშავებელში false-ის დაბრუნება ხელს უშლის ფორმის გაგზავნის ნაგულისხმევ ქცევას."
    },
    "211": {
      "question": "რომელი მეთოდი ინახავს მონაცემებს ბრაუზერის localStorage-ში?",
      "options": [
        "localStorage.setItem('key', 'value')",
        "localStorage.store('key', 'value')",
        "sessionStorage.setItem('key', 'value')",
        "document.store('key', 'value')"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "localStorage.setItem('key', 'value')",
      "explanation": "setItem() localStorage-ში ინახავს გასაღები-მნიშვნელობის წყვილს, რომელიც ბრაუზერის სესიების განმავლობაში შენარჩუნდება."
    },
    "212": {
      "question": "როგორ უნდა აღვადგინოთ მონაცემები ლოკალური მეხსიერებიდან(localStorage)?",
      "options": [
        "localStorage.getItem('key')",
        "localStorage.fetch('key')",
        "sessionStorage.get('key')",
        "document.get('key')"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "localStorage.getItem('key')",
      "explanation": "getItem() აბრუნებს მითითებულ გასაღებთან დაკავშირებულ მნიშვნელობას, ან null-ს, თუ გასაღები არ არსებობს."
    },
    "213": {
      "question": "როგორ ხდება ელემენტის ამოშლა ლოკალური მეხსიერებიდან(localStorage)?",
      "options": [
        "localStorage.removeItem('key')",
        "localStorage.delete('key')",
        "sessionStorage.remove('key')",
        "localStorage.clearItem('key')"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "localStorage.removeItem('key')",
      "explanation": "removeItem() შლის მითითებულ გასაღებს და მის მნიშვნელობას localStorage-დან."
    },
    "214": {
      "question": "როგორ ხდება ყველანაირი მონაცემების ამოშლა ლოკალური მეხსიერებიდან(localStorage)?",
      "options": [
        "localStorage.clear()",
        "localStorage.removeAll()",
        "sessionStorage.clear()",
        "document.clearStorage()"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "localStorage.clear()",
      "explanation": "clear() ფუნქცია localStorage-დან შლის ყველა გასაღები-მნიშვნელობის წყვილს."
    },
    "215": {
      "question": "რატომ ვიყენებთ JSON.stringify()-ს ობიექტის localStorage-ში შენახვამდე?",
      "options": [
        "რადგან localStorage მხოლოდ სტრიქონებს ინახავს",
        "ზომის შესამცირებლად",
        "ობიექტის დაშიფრვისთვის",
        "ეს ვალდებულება არ არის"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "რადგან localStorage მხოლოდ სტრიქონებს ინახავს",
      "explanation": "ობიექტები localStorage-ში შესანახად JSON.stringify() ფუნქციის გამოყენებით უნდა გარდაიქმნას სტრიქონად."
    },
    "216": {
      "question": "როგორ უნდა დავაბრუნოთ JSON string-ი უკან, ჯავასკრიპტის ობიექტად?",
      "options": [
        "JSON.parse(jsonString)",
        "JSON.stringify(jsonString)",
        "Object.fromJSON(jsonString)",
        "JSON.objectify(jsonString)"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "JSON.parse(jsonString)",
      "explanation": "JSON.parse() ვალიდურ JSON სტრიქონს ისევ JavaScript ობიექტად გარდაქმნის."
    },
    "217": {
      "question": "რა მოხდება, თუ მასივს პირდაპირ localStorage-ში შევინახავთ, JSON.stringify() ფუნქციის გამოყენების გარეშე?",
      "options": [
        "მას სტრიქონად გადააკეთებს მძიმით გამოყოფით",
        "შეცდომას გამოაგდებს",
        "ობიექტად შეინახება",
        "გაურკვევლად იგნორირდება"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მას სტრიქონად გადააკეთებს მძიმით გამოყოფით",
      "explanation": "მასივები ავტომატურად გარდაიქმნება მძიმით გამოყოფილ სტრიქონად, რაც შეიძლება არ იყოს სასარგებლო მოძიებისას."
    },
    "218": {
      "question": "რომელი მეხსიერება იწმინდება ბრაუზერის ან ჩანართის დახურვისას?",
      "options": [
        "sessionStorage",
        "localStorage",
        "Cookies",
        "IndexedDB"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "sessionStorage",
      "explanation": "sessionStorage რჩება მხოლოდ გვერდის სესიის განმავლობაში და იწმინდება ჩანართის ან ბრაუზერის დახურვისას."
    },
    "219": {
      "question": "როგორ შევამოწმოთ, არსებობს თუ არა გასაღები localStorage-ში?",
      "options": [
        "'key' in localStorage",
        "localStorage.hasKey('key')",
        "localStorage.exists('key')",
        "localStorage.getItem('key') !== null"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "localStorage.getItem('key') !== null",
      "explanation": "getItem() აბრუნებს null-ს, თუ გასაღები არ არსებობს; null-თან შედარება ადასტურებს არსებობას."
    },
    "220": {
      "question": "ჩამოთვლილთაგან რომელი ინახავს სწორად ობიექტს localStorage-ში და იღებს მას უკან?",
      "options": [
        "localStorage.setItem('user', JSON.stringify(obj)); let user = JSON.parse(localStorage.getItem('user'));",
        "localStorage.setItem('user', obj); let user = localStorage.getItem('user');",
        "localStorage.save('user', obj); let user = JSON.load('user');",
        "localStorage.store('user', obj); let user = localStorage.retrieve('user');"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "localStorage.setItem('user', JSON.stringify(obj)); let user = JSON.parse(localStorage.getItem('user'));",
      "explanation": "ობიექტები შენახვამდე უნდა დაიყოს სტრიქონებად და მათი სტრუქტურის შესანარჩუნებლად უნდა დამუშავდეს უკან მოძიებისას."
    },
    "221": {
      "question": "ჯავასკრიპტში, რომელია ფუნქციის გამოცხადების სწორი გზა?",
      "options": [
        "function car() { console.log('მანქანა'); }",
        "func car() { console.log('მანქანა'); }",
        "function: car() { console.log('მანქანა'); }",
        "def car() { console.log('მანქანა'); }"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "function car() { console.log('მანქანა'); }",
      "explanation": "ფუნქციის დეკლარაციის სწორი დაწერის მანერაა:'function name() { ... }'."
    },
    "222": {
      "question": "როგორ უნდა გამოვაცხადოთ სწორად ცვლადი, რომლის ხელახალი მინიჭება შესაძლებელია?",
      "options": [
        "let age = 25;",
        "const age = 25;",
        "var age;",
        "variable age = 25;"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "let age = 25;",
      "explanation": "'let'-გასაღები სიტყვა გვაძლევს ცვლადის განსაზღვრის საშუალებას, რომლის შეცვლაც დასაშვები იქნება, 'const'-ისგან განსხვავებით, რომლის გარდაქმნა არაა დაშვებული."
    },
    "223": {
      "question": "ჩამოთვლილთაგან რომელია რიცხვების მასივად გადაყვანის სწორი ჩანაწერი?",
      "options": [
        "let nums = [1, 2, 3];",
        "let nums = (1, 2, 3);",
        "let nums = {1, 2, 3};",
        "let nums = 1,2,3;"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "let nums = [1, 2, 3];",
      "explanation": "ჯავასკრიპტში მასივები იქმნება ოთხკუთხა ფრჩხილებში [], რომელშიც შეიცავს ელემენტთა ერთობლიობას."
    },
    "224": {
      "question": "როგორ უნდა დავამატოთ ღირებულება მასივის ბოლოსკენ?",
      "options": [
        "nums.push(4);",
        "nums.add(4);",
        "nums.append(4);",
        "nums.insert(4);"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "nums.push(4);",
      "explanation": "push()-მეთოდი ამატებს ერთ ან მეტ ელემენტს, მასივის სიის ბოლოში."
    },
    "225": {
      "question": "რომელია if ოპერატორის დაწერის სწორი გზა, რომელიც შეამოწმებს, არის თუ არა x-ი 10-ზე მეტი?",
      "options": [
        "if (x > 10) { console.log('Yes'); }",
        "if x > 10 { console.log('Yes'); }",
        "if x > 10 then { console.log('Yes'); }",
        "if (x => 10) { console.log('Yes'); }"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "if (x > 10) { console.log('Yes'); }",
      "explanation": "If ოპერატორებში პირობის გარშემო ფრჩხილები უნდა იყოს გამოყენებული, ბლოკისთვის კი - ხვეული ფრჩხილები."
    },
    "226": {
      "question": "როგორ დავწეროთ for ციკლი, რომელიც გამოიტანს ციფრებს 0-დან 4-მდე?",
      "options": [
        "for (let i = 0; i < 5; i++) { console.log(i); }",
        "for (i = 0; i < 5; i++) { console.log(i); }",
        "for i = 0; i < 5; i++ { console.log(i); }",
        "for (let i = 0; i <= 5; i++) console.log(i);"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "for (let i = 0; i < 5; i++) { console.log(i); }",
      "explanation": "proper for ციკლი ფრჩხილებში იყენებს ინიციალიზაციას, პირობას, ინკრემენტს. ბლოკისთვის კი ფრჩხილებს."
    },
    "227": {
      "question": "რომელი გზით ხდება '123'-სტრიქონის რიცხვად გადაყვანა?",
      "options": [
        "Number('123')",
        "parseInt('123')",
        "+'123'",
        "სამივე მეთოდი სწორია"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "სამივე მეთოდი სწორია",
      "explanation": "ჯავასკრიპტში: Number(), parseInt(), და unary +, ყველა ამ მეთოდს შეუძლია სტრინგ ტიპი გარდაქმნას ციფრის ტიპად."
    },
    "228": {
      "question": "რომელი ჩაშენებული წვდომის მეთოდით შეგვიძლია გავიგოთ ჩანაწერის სიგრძის შესახებ(თუ რამდენი ასოა მასში)?",
      "options": [
        "'Hello'.length",
        "'Hello'.size",
        "'Hello'.count",
        "length('Hello')"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "'Hello'.length",
      "explanation": "length პარამეტრი აბრუნებს სტრიქონში სიმბოლოების რაოდენობას, მაგ: 'Hello'.length დააბრნებს შედეგად 5-ს"
    },
    "229": {
      "question": "როგორ გამოვიძახოთ greet სახელით ცნობილი ფუნქცია?",
      "options": [
        "greet();",
        "call greet();",
        "greet.call();",
        "function.greet();"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "greet();",
      "explanation": "ფუნქციები გამოიძახება მათი სახელის გამოყენებით, რომელსაც მოჰყვება ფრჩხილები."
    },
    "230": {
      "question": "რომელია ფუნქციის გამოსახულების(function expression) ჩაწერის სწორი გზა?",
      "options": [
        "const greet = function() { console.log('Hi'); };",
        "function greet = () { console.log('Hi'); };",
        "greet() = function { console.log('Hi'); };",
        "const function greet() { console.log('Hi'); };"
      ],
      "level": "<easy>მარტივი</easy>+",
      "correct": "const greet = function() { console.log('Hi'); };",
      "explanation": "ფუნქციის გამოსახულება(Function Expressions) ფუნქციას ცვლადს ანიჭებს: const/let/var-ის გამოყენებით."
    }
  },
  "react": {
    "1": {
      "question": "რა არის React-ის გამოყენების მთავარი მიზანი?",
      "options": [
        "სერვერის ბაზების მართვა",
        "მომხმარებლისთვის დინამიური ინტერფეისების შექმნა",
        "ოპერაციული სისტემების შექმნა",
        "HTML ელემენტების სტილიზება"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "მომხმარებლისთვის დინამიური ინტერფეისების შექმნა",
      "explanation": "რეაქტი არის ჯავასკრიპტის ბიბლიოთეკა, ინტერაქტიული და დინამიური UI კომპონენტების ეფექტურად ასაწყობად."
    },
    "2": {
      "question": "რას აკეთებს `useState` ჰუკი React-ში?",
      "options": [
        "ინახავს კომპონენტის მდგომარეობას და განაახლებს მას",
        "აკავშირებს API-ებთან",
        "უსმენს მოვლენებს",
        "ხელით ახდენს DOM-ის განახლებას"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ინახავს კომპონენტის მდგომარეობას და განაახლებს მას",
      "explanation": "`useState` ჰუკი ნებას გვაძლევს რომ შევმქნათ მდგომარეობის ცვლადები ფუნქციონალურ კომპონენტებში და მოვახდინოთ მათი განახლება როცა საჭირო იქნება ეს, განახლება შეგვიძლია გავაკეთოთ useState-ის მეორე არგუმენტით[..., setState]."
    },
    "3": {
      "question": "რას ემსახურება `onChange` მოვლენების დამმუშავებელი React-ის ფორმებში?",
      "options": [
        "ის თვალს ადევნებს კომპონენტების გადატვირთვებს",
        "ის თვალს ადევნებს input-ში მომხდარ ცვლილებებს",
        "ის თვალყურს ადევნებს კომპონენტის ჩართვას",
        "ის ცვლის Css-ში სტილებს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ის თვალს ადევნებს input-ში მომხდარ ცვლილებებს",
      "explanation": "`onChange` აფიქსირებს ცვლილებებს input ველში, როგორიცაა ტექსტის აკრეფა, და შესაბამისად ანახლებს მდგომარეობას."
    },
    "4": {
      "question": "რომელი React-ის ჰუკი ასრულებს კოდს კომპონენტის რენდერის შემდეგ?",
      "options": [
        "useEffect",
        "useState",
        "useRef",
        "useContext"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "useEffect",
      "explanation": "`useEffect` გაძლევთ საშუალებას გაუშვათ გვერდითი ეფექტები, როგორებიცაა მონაცემების წამოღება ან DOM-ის განახლება, რენდერის შემდეგ."
    },
    "5": {
      "question": "რისთვის გამოიყენება ძირითადად `useRef`?",
      "options": [
        "კომპონენტის მდგომარეობის შესაქმნელად",
        "იგი გამოიყენება რომ მოხდეს მნიშვნელობის შენახვა თუმცა არ მოხდეს მისი ხელახალი რენდერინგი",
        "API მონაცემების მისაღებად",
        "კომპონენტების გასასტილად"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "იგი გამოიყენება რომ მოხდეს მნიშვნელობის შენახვა თუმცა არ მოხდეს მისი ხელახალი რენდერინგი",
      "explanation": "useRef() - `მითითების გამოყენება` არ იწვევს ახალ რენდერირებას, როდესაც მისი მნიშვნელობა იცვლება. გამოიყენეთ ის როდესაც გსურთ, რომ კომპონენტმა დაიმახსოვროს გარკვეული ინფორმაცია, მაგრამ არ გსურთ, რომ ამ ინფორმაციამ გამოიწვიოს ახალი რენდერები."
    },
    "6": {
      "question": "როგორ განაახლებთ `useState`-ით შექმნილ state-ს?",
      "options": [
        "ცვლადზე პირდაპირი მინიჭებით",
        "useState-ის მეორე არგუმენტის(setter) ფუნქციის გამოყენებით",
        "DOM ელემენტის შეცვლით",
        "useRef()-ის გამოძახებით"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "useState-ის მეორე არგუმენტის(setter) ფუნქციის გამოყენებით",
      "explanation": "`useState`-ის მიერ დაბრუნებული setter ფუნქცია განაახლებს state-ს და გამოიწვევს კომპონენტის ხელახალ რენდერს."
    },
    "7": {
      "question": "ჩამოთვლილთაგან რომელი ჩანაწერია სწორი `onChange`-ის გამოყენებისთვის React-ის input-ში?",
      "options": [
        "<input onChange='handleChange' />",
        "<input onChange={handleChange} />",
        "<input onchange='handleChange()' />",
        "<input change={handleChange} />"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "<input onChange={handleChange} />",
      "explanation": "JSX(react)-ში, მოვლენების დამმუშავებლები(რომელთა ტიპიც არის ფუნქცია) იწერებიან ფიგურულ ფრჩხილებში და არა სტრინგებში - ('Hello World')."
    },
    "8": {
      "question": "რა არის `useState` ჰუკის საწყისი მნიშვნელობა, თუ არ დავწერთ მის საწყის მდგომარეობას?",
      "options": [
        "null",
        "განუსაზღვრელი(undefined)",
        "0",
        "ცარიელი სტრინგი"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "განუსაზღვრელი(undefined)",
      "explanation": "თუ საწყის მნიშვნელობას არ გადასცემთ `useState`-ს, ის იქნება `undefined`."
    },
    "9": {
      "question": "როდის გაეშვება `useEffect`, თუ მას არ აქვს dependency array?",
      "options": [
        "ერთხელ mount-ის დროს",
        "ყოველ ჯერზე როცა მოხდება რაიმის განახლება",
        "როცა state იცვლება",
        "არასდროს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ყოველ ჯერზე როცა მოხდება რაიმის განახლება",
      "explanation": "რეაქტის useEffect ჰუკში თუ dependency array არ არსებობს(useEffect(() => {}, [dependency array])), `useEffect` გაეშვება ყოველი რენდერის შემდეგ."
    },
    "10": {
      "question": "როგორ შევინახოთ DOM ელემენტზე მითითება React-ში?",
      "options": [
        "querySelector-ის გამოყენებით",
        "document.getElementById-ით",
        "useRef-ის გამოყენებით და მისი ელემენტის ref ატრიბუტისთვის მინიჭებით",
        "`useEffect`-ით"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "`useRef-ის გამოყენებით და მისი ელემენტის ref ატრიბუტისთვის მინიჭებით",
      "explanation": "`useRef`-ს შეუძლია DOM მითითებების შენახვა მისი ცვლადის `ref` ატრიბუტისთვის გადაცემით, ეს `ref` გამოიყენება html-ტეგებთან(div, section, main...)"
    },
    "11": {
      "question": "რატომ ეძახიან React-ს „დეკლარატიულს“?",
      "options": [
        "იმიტომ, რომ მალავს DOM-ის მანიპულაციის დეტალებს",
        "იმიტომ, რომ საჭიროებს კლას კომპონენტებს",
        "იმიტომ, რომ იყენებს HTML სინტაქსს",
        "იმიტომ, რომ არ იყენებს JavaScript-ს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "იმიტომ, რომ იგი მალავს DOM-ის მანიპულაციის დეტალებს",
      "explanation": "React გაძლევთ საშუალებას აღწეროთ UI-ის სასურველი მდგომარეობა და თვითონ მართავს DOM-ის განახლებას."
    },
    "12": {
      "question": "რას აბრუნებს `useState`?",
      "options": [
        "ერთ state ცვლადს",
        "მასივს საწყისი მდგომარეობით(state) და setter ფუნქციას რომელიც არის მეორე არგუმენტად",
        "ობიექტს state-ის თვისებებით",
        "ფუნქციას, რომელიც განაახლებს DOM-ს"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "მასივს საწყისი მდგომარეობით(state) და setter ფუნქციას რომელიც არის მეორე არგუმენტად",
      "explanation": "`useState` აბრუნებს ორ ელემენტიან მასივს: საწყის მდგომარეობას(state) და მის განმაახლებელ ფუნქციას."
    },
    "13": {
      "question": "მოცემულთაგან რომელი არაა ვალიდური dependency-ი `useEffect` ჰუკისთვის?",
      "options": [
        "state ცვლადი",
        "prop",
        "კონსტანტა",
        "ფუნქცია setInterval-დან"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "კონსტანტა",
      "explanation": "კონსტანტას მნიშვნელობა არ იცვლება რენდერის დროს, ამიტომ მათი dependencies-ად დამატება არაა რეკომენდირებული."
    },
    "14": {
      "question": "რა მოხდება თუ state-ს იგივე მნიშვნელობით განაახლებთ?",
      "options": [
        "React მაინც გააახლებს რენდერს",
        "React გამოტოვებს რენდერს",
        "React გვესვრის შეცდომას",
        "კომპონენტი წაიშლება"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "React გამოტოვებს რენდერს",
      "explanation": "თუ ახალი მდგომარეობა მკაცრად ტოლია ძველი მდგომარეობის(`===`), მაშინ რეაქტი არ გამოიწვევს ხელახლა რენდერირებას."
    },
    "15": {
      "question": "როგორ შეგვიძლია დავამატოთ icon-ები რეატქში?",
      "options": [
        "შეგვიძლია დავაკოპიროთ/ჩავსვათ ის რაიმე წყაროდან.",
        "შეგვიძლია ჩამოვიწეროთ სურათი icon-ის ტიპით.",
        "შეგვიძლია იმპორტირება გავუკეთოთ სპეციალური ვებგვერდიდან და შემდეგ ჩავსვათ icon-ი კოდში ამგვარი სახით:<icon/>",
        "ჩვენ არ შეგვიძლია icon-ების გამოყენება რეაქტში"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "we can import it and then use them <icon/>",
      "explanation": "ინტერნეტში შეგიძლიათ ჩაწეროთ ეს ბმული: https://react-icons.github.io/react-icons და აირჩიოთ სასურველი icon-ი, რის შემდეგაც გამოიყენებთ მას თქვენს პროექტში"
    },
    "16": {
      "question": "როგორ გავუშვათ `useEffect`-ი მხოლოდ ერთხელ, როდესაც კომპონენტები იტვირთებიან ეკრანზე?",
      "options": [
        "ცარიელი მასივის ფრჩხილებით(dependency array) useEffect-ის მეორე არგუმენტად",
        "არ გადავცეთ dependency array",
        "`useState`-ში გამოძახებით",
        "ფუნქციაში მოთავსებით"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ცარიელი მასივის ფრჩხილებით(dependency array) useEffect-ის მეორე არგუმენტად",
      "explanation": "ცარიელი დამოკიდებულების მასივი:useEffect(() => {...}, []) `[]` კომპონენტების (საწყისი რენდერის) ჩატვირთვისას `useEffect`-ს მხოლოდ ერთხელ გაუშვებს."
    },
    "17": {
      "question": "რომელია `useState`-ის არასწორი გამოყენება?",
      "options": [
        "const [count, setCount] = useState(0)",
        "const [time, setTime]= useState(() => {setTimeOut(...)})",
        "const count = useState(0)",
        "const [value, setValue] = useState()"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "const count = useState(0)",
      "explanation": "`useState` აბრუნებს მასივს, ამიტომ მდგომარეობისა და განახლების ცალ-ცალკე მისაღებად საჭიროა დესტრუქტურიზაცია."
    },
    "18": {
      "question": "რა მოხდება თუ dependency array არ გადავცემთ `useEffect`-ს?",
      "options": [
        "არასდროს გაეშვება",
        "მაშინ useEffect-ში ჩაწერილი კოდი გაეშვება ყოველ განახლებაზე, ყოველჯერზე",
        "შეცდომაზე შეგვატყობინებს",
        "გაეშვება მხოლოდ მონაცემების ჩატვირთვისას ეკრანზე"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "მაშინ useEffect-ში ჩაწერილი კოდი გაეშვება ყოველ განახლებაზე, ყოველჯერზე",
      "explanation": "თუ dependency array არ არსებობს, `useEffect` გაეშვება ყოველი რენდერის შემდეგ, რამაც შეიძლება გამოიწვიოს ხარვეზები."
    },
    "19": {
      "question": "რატომ არის ასე მნიშვნელოვანი უნიკალური გასაღებების მინიჭება სიებში როცა ვიყენებთ map() მეთდს?",
      "options": [
        "რომ დავეხმაროთ რეაქტს რომ მან თვალყური ადევნოს ნივთებსა და განაახლოს ისინი ეფექტურად.",
        "რომ გასტილოს სიის ნივთები სწრაფად.",
        "რომ შეინახოს ინფორმაცია DOM-ში.",
        "რომ ნება დართოს ანიმაციების შემოტანას."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "რომ დავეხმაროთ რეაქტს რომ მან თვალყური ადევნოს ნივთებსა და განაახლოს ისინი ეფექტურად.",
      "explanation": "გასაღებები(Keys) ეხმარება რეაქტს რომ მან იდენტიფიცირება გაუკეთოს იმას თუ რომელი ნივთი შეიცვალა, დაემატა ან წაიშალა(რენდერინგის მუშაობის გაუმჯობესება მოკლედ)."
    },
    "20": {
      "question": "როგორ უნდა გავაკეთოთ პირობითი რენდერინგი React-ში?",
      "options": [
        "if/else ან ტერნარი ოპერატორის გამოყენებით JSX ფაილში",
        "პირობების დამატებით CSS-ში",
        "HTML ტეგების შეცვლით",
        "index.html-ის მოდიფიცირებით"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "if/else ან ტერნარი ოპერატორის გამოყენებით JSX ფაილში",
      "explanation": "პირობითი რენდერინგი ჩვეულებრივ ხორციელდება სამმაგი ოპერატორებით ან JSX-ში არსებული ლოგიკური && ოპერატორებით."
    },
    "21": {
      "question": "მოცემულთაგან რომელია conditional rendering-ის სწორი ჩანაწერი რეაქტისთვის?",
      "options": [
        "Import {Render} from 'react-icons';",
        "const 1 = {conditional rendering}",
        "{burgerMenu && (<div>{burgerMenu ? `...` : `...`}</div>)}",
        "<div>Render</div>"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "{burgerMenu && (<div>{burgerMenu ? `...` : `...`}</div>)}",
      "explanation": "ჩვენ შეგვიძლია გამოვიყენოთ conditional rendering-ი: &&, if/else ან ternary operator-ით ჩვენს JSX ფაილში."
    },
    "22": {
      "question": "როგორ უნდა დააინსტალირო რეაქტის Icon-ებში?",
      "options": [
        "npm install react-icons",
        "npm install icons-react",
        "npm create react-icons",
        "yarn add react-icons-pack"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "npm install react-icons",
      "explanation": "React-ის Icon-ების დასაინსტალირებლად, ჩვენს კონსოლ უჯრაში უნდა ჩავწეროთ `npm install react-icons` ან `yarn add react-icons`."
    },
    "23": {
      "question": "როგორ შეგვიძლია დავამატოთ რეაქტის Icon-ები კომპონენტებში?",
      "options": [
        "Import {icon} from 'react-icons' და გამოვიყენოთ ის ჩვენს JSX-ში",
        "შეგვიძლია დავაკოპიროთ ისინი HTML-იდან",
        "გამოვიყენოთ document.createElement",
        "შეგვიძლია შევქმნათ იგი CSS-ში და გამოვიყენოთ ჩვენს JSX-ში"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "Import {icon} from 'react-icons' და გამოვიყენოთ ის ჩვენს JSX-ში",
      "explanation": "აიკონების იმპორტირება ხდება შემდეგნაირად:`import { FaHome } from 'react-icons/fa';` იმპორტირების შემდეგ ვიყენებთ ჩვენს return-ში ამგვარად: `<FaHome />`."
    },
    "24": {
      "question": "რატომ ვიყენებთ რეაქტს JS/HTML/CSS-ის ნაცვლად?",
      "options": [
        "იმიტომ რომ რეაქტი UI-ს ანახლებს უფრო სწრაფად და მარტივად.",
        "იმიტომ რომ HTML-ი არ არის მხარდაჭერილი ბევრი ბრაუზერისგან",
        "იმიტომ რომ CSS-ს არ შეუძლია ელემენტების გასტილვა",
        "იმიტომ რომ ჯავასკრიფტი არ მუშაობს API-სთან"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "იმიტომ რომ რეაქტი UI-ს ანახლებს უფრო სწრაფად და მარტივად.",
      "explanation": "რეაქტი ამარტივებს UI-ს განახლებებს და იგი იყენებს ისეთ ჰუკებს რომლებიც ხელს უწყობენ განახლებების კონტროლს და სხვა ბევრ მრავალს, რისი გამეორებაც საკმაოდ რთულია JS/HTML/CSS-ში"
    },
    "25": {
      "question": "რა არის პროპელერის ბურღვა(props)?",
      "options": [
        "props-ების ჩასმა ბევრ კომპონენტში, საჭიროების გარეშე.",
        "მდგომარეობის პირდაპირ განახლება",
        "props-ების გამოყენება CSS-ში",
        "მდგომარეობის შექმნა ბევრ ადგილზე"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "props-ების ჩასმა ბევრ კომპონენტში, საჭიროების გარეშე.",
      "explanation": "Prop drilling მონაცემებს მრავალი შუალედური კომპონენტის მეშვეობით გადასცემს, რამაც შეიძლება კოდი გაართულოს."
    },
    "26": {
      "question": "როგორ ავიცილოთ თავიდან prop drilling-ი?",
      "options": [
        "React კონტექსტის გამოყენებით",
        "უფრო მეტი props-ების გამოყენებით",
        "გამოვიყენოთ მხოლოდ CSS-ი",
        "მდგომარეობის თავიდან აცილებით"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "React კონტექსტის გამოყენებით",
      "explanation": "React კონტექსტი საშუალებას იძლევა მონაცემების გაზიარებაში კომპონენტებს შორის prop-ების ხელით გადაცემის გარეშე."
    },
    "27": {
      "question": "რომელია პირობითი რენდერინგი სწორი მაგალითი რეაქტში?",
      "options": [
        "{isLoggedIn ? <Dashboard/> : <Login/>}",
        "if(isLoggedIn) <Dashboard/> else <Login/>",
        "<Dashboard/> && <Login/>",
        "<Dashboard/> || <Login/>"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "{isLoggedIn ? <Dashboard/> : <Login/>}",
      "explanation": "პირობითი რენდერინგი ხშირად იყენებს ternary ოპერატორს JSX-ფაილში."
    },
    "28": {
      "question": "ჩვეულებრივ სად გამოიყენება useRef() რეაქტის ჰუკი?",
      "options": [
        "იგი არის Vue-ს ხელსაწყო და არ გამოიყენება რეაქტში.",
        "ისეთ ადგილებში სადაც გვჭირდება რაც შეიძლება უფრო მეტი რენდერინგი.",
        "useRef() ჰუკს ვიყენებთ მხოლოდ კრიტიკულ შემთხვევაში, როდესაც useState() ვერ ფუნქციონირებს.",
        "ისეთ ადგილებში რომლებიც იწვევენ ზედმეტ რენდერინგს, როგორებიცაა input-ები ან window listener-ები."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ისეთ ადგილებში რომლებიც იწვევენ ზედმეტ რენდერინგს, როგორებიცაა input-ები ან window listener-ები.",
      "explanation": "useRef გამოიყენება იმ მნიშვნელობების შესანახად, რომლებიც რენდერების დროს ხელახალი რენდერინგის გამოწვევის გარეშე რჩება. ის ხშირად გამოიყენება შეყვანის მითითებებისთვის, DOM ელემენტებისთვის ან მოვლენების მსმენელებისთვის, რათა თავიდან იქნას აცილებული ზედმეტი ხელახალი რენდერინგი."
    },
    "29": {
      "question": "როგორ დავაყენოთ React Icons?",
      "options": [
        "npm install react-icons",
        "npm install icons-react",
        "npm create react-icons",
        "yarn add react-icons-pack"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "npm install react-icons",
      "explanation": "React Icons-ის დასაყენებლად გამოიყენება ბრძანება `npm install react-icons` ან `yarn add react-icons`."
    },
    "30": {
      "question": "რისთვის გამოიყენება React-ის Router-ები რეაქტში?",
      "options": [
        "ნავიგაციისა და მარშრუტების სამართვად React-ის აპლიკაციებში",
        "კომპონენტების გასასტილად",
        "მონაცემების მოძიებისთვის",
        "form-ებზე თავის გასართმევად"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "ნავიგაციისა და მარშრუტების სამართვად React-ის აპლიკაციებში",
      "explanation": "React Router საშუალებას გვაძლევს შემოვიტანოთ routes და მათი წყალობით გადავვადგილდეთ ფაილებს შორის, ღილაკზე დაჭერის დროს(ძირითადად გამოიყენება დიდ პროექტებში)."
    },
    "31": {
      "question": "React Router-ის რომელი კომპონენტი გამოიყენება ინდივიდუალური მარშრუტების განსაზღვრისთვის?",
      "options": [
        "<Route>",
        "<Link>",
        "<Switch>",
        "<Router>"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "<Route>",
      "explanation": "<Route> კომპონენტი განსაზღვრავს, თუ რომელი ინტერფეისი უნდა იყოს რენდერირებული მიმდინარე URL-ის მიხედვით."
    },
    "32": {
      "question": "რას აკეთებს <BrowserRouter> კომპონენტი?",
      "options": [
        "ის ინარჩუნებს მომხმარებლის ინტერფეისს URL-თან სინქრონიზაციაში.",
        "ის სტილავს სანავიგაციო ღილაკს.",
        "ის იღებს მონაცემებს API-დან.",
        "ის მართავს ფორმების წარდგენას"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის ინარჩუნებს მომხმარებლის ინტერფეისს URL-თან სინქრონიზაციაში",
      "explanation": "<BrowserRouter> იყენებს HTML5-ის API ისტორიას რომ თავი გაართვას როუტინგს React-ის აპლიკაციებში(იგი არაა რეკომენდირებული რადგან იწვევს არასასურველ ხარვეზებს github-ზე ატვირთვის დროს)."
    },
    "33": {
      "question": "რომელია საუკეთესო არჩევანი github-ისთვის როცა ვიყენებთ routing-ს, <BrowserRouter> თუ <HashRouter>?",
      "options": [
        "<HashRouter>",
        "ორივე",
        "არცერთი",
        "<BrowserRouter>"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "<HashRouter>",
      "explanation": "GitHub Pages არის სტატიკური ფაილების ჰოსტი და არ უჭერს მხარს სერვერის მხარეს მარშრუტიზაციას. <BrowserRouter> ცდილობს მარშრუტების დამუშავებას რეალური ფაილების მსგავსად, რაც იწვევს შეცდომებს. <HashRouter> მუშაობს, რადგან ის იყენებს URL-ის # ნაწილს, რომელსაც GitHub უგულებელყოფს, ამიტომ React Router-ს შეუძლია მარშრუტიზაციის სწორად დამუშავება."
    },
    "34": {
      "question": "რატომ არის უკეთესი <HashRouter>-ის არჩევა <BrowserRouter>-ის ნაცვლად?",
      "options": [
        "რადგან GitHub გვერდები არ უჭერს მხარს სერვერის მხარეს მარშრუტიზაციას",
        "რადგან HashRouter უფრო სწრაფად იტვირთება, ვიდრე BrowserRouter",
        "რადგან BrowserRouter მხოლოდ მობილური აპლიკაციებისთვისაა",
        "რადგან HashRouter ავტომატურად აუმჯობესებს SEO-ს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "რადგან GitHub გვერდები არ უჭერს მხარს სერვერის მხარეს მარშრუტიზაციას",
      "explanation": "<BrowserRouter> ეყრდნობა HTML5 History API-ს და „pretty“ URL-ებს (მაგ., /about). ამასობაში <HashRouter> იყენებს URL ჰეშს (მაგ., /#/about). რადგან #-ის შემდეგ ყველაფერი სერვერზე არ იგზავნება, GitHub Pages მხოლოდ თქვენს index.html-ს ემსახურება, ხოლო React Router ამუშავებს ჰეშ მარშრუტიზაციას, რაც მას საიმედოს ხდის GitHub Pages-ის ჰოსტინგისთვის."
    },
    "35": {
      "question": "რატომ არის მნიშვნელოვანი რომ მივუთითოთ საწყისი ფაილი(homepage) route-ინგის დროს <Route path='/' element={...} /> როცა ვტვირთავთ ჩვენს რეაქტ აპს GitHub-ზე?",
      "options": [
        "მის გარეშე, GitHub Pages-ს არ შეუძლია საწყისი კომპონენტის რენდერირება რის შედეგადაც ვიღებთ ცარიელ ეკრანს.",
        "ეს აპლიკაციას უფრო სწრაფად ამუშავებს root მარშრუტის ქეშირებით",
        "ეს მხოლოდ მობილური მოწყობილობებისთვისაა საჭირო",
        "ის აუმჯობესებს SEO-ს მთავარი გვერდის მეტატეგის დაყენებით"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "მის გარეშე, GitHub Pages-ს არ შეუძლია საწყისი კომპონენტის რენდერირება რის შედეგადაც ვიღებთ ცარიელ ეკრანს.",
      "explanation": "როცა ვიყენებთ Router-ს, '/'-ეს არის საწყისი ფაილი ჩვენი გვერდისთვის, თუ ჩვენ ის არ გვაქვს, GitHub-ის გვერდი ვერ გაიგებს თუ რომელი კომპონენტი გაუშვას პირველი, რაც ხშირად იწვევს თეთრ ეკრანს, ვებგვერდის რენდერირების მაგივრად. გზის მითითება: path='/' უზრუნველყოფს JSX-ფაილის ჩვენებას."
    },
    "36": {
      "question": "რა არის i18n-ის გამოყენების მთავარი მიზანი, როდესაც ვმუშაობთ პროექტზე?",
      "options": [
        "მისი წყალობით ვაუმჯობესებთ SEO-ს რეიტინგს",
        "მრავალი ენისა და ლოკალული ფაილების მხარდასაჭერად",
        "შესრულების ოპტიმიზაციისთვის",
        "დაამატოს ანიმაციები კომპონენტებზე"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "მრავალი ენისა და ლოკალული ფაილების მხარდასაჭერად",
      "explanation": "i18n (ინტერნაციონალიზაცია), გულისხმობს შენი ვებგვერდის მომზადებას რომ მან მხარი დაუჭიროს(გახდეს) მრავალი ენის გამოყენებას ვებგვერდზე, (გამოიყენება დროის ფორმატირებაზეც)."
    },
    "37": {
      "question": "ყველაზე ხშირად რეაქტის რომელი ბიბლიოთეკა გამოიყენება ინტერნაციონალიზაციისთვის?",
      "options": [
        "react-router-dom",
        "redux-toolkit",
        "react-i18next",
        "axios"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "react-i18next",
      "explanation": "i18n-ისთვის ყველაზე პოპულარული ბიბლიოთეკა არის react-i18next, რომელიც უზრუნველყოფს თარგმანის კაუჭების გამოყენებას და კომპონენტების დამუშავებას."
    },
    "38": {
      "question": "ჩვეულებრივ სად ვინახავთ თარგმნებს როდესაც ვიყენებთ react-i18next?",
      "options": [
        "package.json-ის შიგნით ინახება",
        "განცალკევებულ JSON-ის ფაილებში, ყოველ ენაზე თითო ფაილით.",
        "index.html-ის შიგნით ვათავსებთ",
        ".env ფაილებში ვათავსებთ ყველაფერს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "განცალკევებულ JSON-ის ფაილებში, ყოველ ენაზე თითო ფაილით.",
      "explanation": "ჩვეულებრივ თარგმნები თავსდება JSON-ფორმატის ფაილებში(მაგ: en.json-ინგლისური, ka.json-ქართული), ვარქმევთ მისახვედრ სახელებს მარტივი ორგანიზებისა და გამოყენებისთვის."
    },
    "39": {
      "question": "რომელ ჰუკი გვთავაზობს react-i18next-ში გამოვიყენოთ თარგმნა კომპონენტს შიგნით?",
      "options": [
        "useState",
        "useEffect",
        "useTranslation",
        "useContext"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "useTranslation",
      "explanation": "react-i18next უზრუნველყოფს useTranslation კაუჭს ფუნქციურ კომპონენტებში t ფუნქციასა და i18n ინსტანციაზე წვდომისთვის."
    },
    "40": {
      "question": "ზუსტად რას აკეთებს 't' ფუნქცია react-i18next-ში?",
      "options": [
        "თარგმნის გასაღებ სიტყვებს აქტიურ ენაზე",
        "აკვირდება მომხმარებლის მაუსზე დაწკაპუნებებს",
        "რთავს light და dark რეჟიმებს",
        "იღებს API მონაცემებს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "თარგმნის გასაღებ სიტყვებს აქტიურ ენაზე",
      "explanation": "t ფუნქცია ეძებს გასაღებს თქვენი თარგმანის JSON ფაილში და აბრუნებს შედეგს სტრიქონში, მიმდინარე ენაზე."
    },
    "41": {
      "question": "როგორ უნდა შევცვალოთ აქტიური ენა სხვა ენაზე react-i18next-ში?",
      "options": [
        "index.html-ის რედაქტირებით",
        "i18n.changeLanguage('xx')-ის გამოძახებით",
        "App.js-ში setState-ის გამოყენებით",
        "ბრაუზერის გადატვირთვის გზით"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "i18n.changeLanguage('xx')-ის გამოძახებით",
      "explanation": "i18n-ს აქვს changeLanguage მეთოდი, რასაც გადავცემთ ენის კოდს (მაგ., 'en', 'fr' ან: i18n.language === `ka` ?)."
    },
    "42": {
      "question": "რატომ არის გამოსადეგი ენის შემცვლელი კომპონენტი რეაქტში?",
      "options": [
        "ის აუმჯობესებს ვებგვერდის სისწრაფეს",
        "ის საშუალებას აძლევს მომხმარებელს აირჩიოს მისთვის სასურველი ენა",
        "ის თავიდან გვაცილებს 404 error-ების გამოჩენას თავიდან",
        "ის ამატებს მორგებულ CSS თემებს ვებგვერდზე"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის საშუალებას აძლევს მომხმარებელს აირჩიოს მისთვის სასურველი ენა",
      "explanation": "ენის გადამრთველი საშუალებას აძლევს მომხმარებელს აირჩიოს სასურველი ენა, რაც თქვენს აპლიკაციას გლობალურად დონეზე უფრო სასურველს და მოთხოვნადს გახდის!."
    },
    "43": {
      "question": "react-i18next-ის რომელი კომპონენტი იძლევა თარგმანების პირდაპირ JSX-ში ჩასმის საშუალებას ფორმატირებით?",
      "options": [
        "<Provider>",
        "<Trans>",
        "<Switch>",
        "<Translate>"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "<Trans>",
      "explanation": "<Trans>-ი გამოიყენება JSX-ში სტრიქონების უნიკალური სტილების მისაცემად(მაგ:გვაქვს დიდი ტექსტი, რომელიც როგორც უნდა ვთარგმნოთ ასევე უნდა გამოვყოთ წინადადებები წითლად, აქ გამოიყენება ეს ხესაწყო), იგი მხარს უჭერს ჩაშენებულ HTML და React კომპონენტებს."
    },
    "44": {
      "question": "რა უპირატესობით სარგებლობს <Trans>-ფუნქცია, t ფუნქციასთან შედარებით?",
      "options": [
        "ის მუშაობს JSON ფაილების გარეშე",
        "ის მხარს უჭერს დიდი მოცულობის ტექსტის დინამიურ თარგმნას.",
        "ის უფრო მარტივი გამოსაყენებელია დიდ პროექტებში.",
        "ის ავტომატურად აგენერირებს ნათარგმნ ტექსტს."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის მხარს უჭერს დიდი მოცულობის ტექსტის დინამიურ თარგმნას.",
      "explanation": "<Trans> allows you to insert components, styling, and formatting tags inside translated text."
    },
    "45": {
      "question": "მოდის თუ არა i18n-ი ნაგულისხმევი ჩაშენებული საწყისი ენით?",
      "options": [
        "კი, ინგლისური ენა გამოიყენება როგორც ნაგულისხმევი ენა i18n-ში.",
        "არა, რადგან ყველაფერი დამოკიდებულია ბიბლიოთეკებზე.",
        "არა, დეველოპერმა უნდა დააყენოს საწყისი ენა, ან სარეზერვო ენა.",
        "კი, ენა იცვლება მომხმარებლის ქვეყნის მიხედვით."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "არა, დეველოპერმა უნდა დააყენოს საწყისი ენა, ან სარეზერვო ენა.",
      "explanation": "i18next არ იყენებს ნაგულისხმევ ენას, როგორიცაა ინგლისური. რაც იმას ნიშნავს რომ ენა ჩვენვე უნდა შემოვიტანოთ `lng` ან `fallbackLng` პარამეტრებში, წინააღმდეგ შემთხვევაში ჩვენ ვიხილავთ მხოლოდ გასაღებებს."
    },
    "46": {
      "question": "რა დანიშნულება აქვს i18n-ში სარეზერვო ენას?",
      "options": [
        "ის ავტომატურად თარგმნის ტექსტს ყველა ენაზე",
        "ის მთლიანად მალავს თარგმნილ ტექსტს",
        "თარგმანის წარუმატებლობის შემთხვევაში, აპლიკაცია ახდენს ავტომატურ გადატვირთვას.",
        "ის გვთავაზობს ნაგულისხმევ ენას, თუ მიმდინარე ენას რაიმე(გასაღები სიტყვა) აკლია."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის გვთავაზობს ნაგულისხმევ ენას, თუ მიმდინარე ენას რაიმე(გასაღები სიტყვა) აკლია.",
      "explanation": "სარეზერვო ენა უზრუნველყოფს, რომ აპლიკაციამ აჩვენოს წასაკითხი ტექსტი, თუ მიმდინარე ენას აკლია რაიმე ნაწილი მაგ: თარგმანი, ხელსაწყო და ა.შ, (ნედლი კლავიშების ჩვენების ნაცვლად)."
    },
    "47": {
      "question": "როგორ უნდა მოვახდინოთ i18n-ის ინიციალიზირება რეაქტის აპლიკაციაში?",
      "options": [
        "i18n არ საჭიროებს ინიციალიზირებას, პირდაპირ ვაკეთებთ თარგმნებს JSON-ფაილში",
        "CSS-ში თარგმანების განთავსებით",
        "i18next.init-ის გამოყენებით და i18n.js ფაილის შექმნით",
        "i18n-ის იმპორტით react-router-dom-დან"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "i18next.init-ის გამოყენებით და i18n.js ფაილის შექმნით",
      "explanation": "i18n-ისთვის როგორც წესი ვქმნით js-ის ფაილს(მაგ., i18n.js), რომელსაც ვუშვებთ იმპორტზე და შეგვაქვს სასურველ JSX-ის ფაილში, თარგმნების განსახორციელებლად."
    },
    "48": {
      "question": "რეაქტში რომელი ფაილი ახდენს i18n.js-ის იმპორტირებას, ჩვეულებრივი თარგმნების გლობალური გამოყენებისთვის?",
      "options": [
        "index.js",
        "App.css",
        "package.json",
        "reportWebVitals.js"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "index.js",
      "explanation": "თუ i18n.js-ს დავაიმპორტირებთ index.js-ში (საწყისი წერტილი), ამით თარგმნები ხელმისაწვდომი ხდება მთლიან ვებგვერდზე."
    },
    "49": {
      "question": "რა განსხვავებაა ლოკალურ (l10n)-სა და ინტერნაციონალურ (i18n)-ს შორის?",
      "options": [
        "მათ შორის არანაირი სხვაობა არარის.",
        "i18n აპლიკაციას რამდენიმე ენაზე ამზადებს, l10n კი კონკრეტულ ენას ეგუება.",
        "i18n მხოლოდ რეაქტისთვისაა, ხოლო l10n კი Vue-სთვის.",
        "i18n გამოიყენება სტილების შესაქმნელად ხოლო l10n კი გამოიყენება მარშუტირებისთვის(გადასამისამართებლად)."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "i18n აპლიკაციას რამდენიმე ენაზე ამზადებს, l10n კი კონკრეტულ ენას ეგუება.",
      "explanation": "ინტერნაციონალური (i18n)-ი არის აპლიკაციის ენობრივი ადაპტაციის პროცესი. ლოკალური (l10n)-ი იყენებს კონკრეტული კულტურის ან ენისათვის განკუთვნილ თარგმნებს."
    },
    "50": {
      "question": "ქვემოთ ჩამოთვლილთაგან რომელი მოსაზრებაა მცდარი react-i18next-ის შესახებ?",
      "options": [
        "იგი მხარს უჭერს მრავალ ენას.",
        "იგი მხარს უჭერს პლურალიზაციას და ინტერპოლაციას.",
        "იგი უზრუნველყოფს თარგმნის ქეშირებებს.",
        "იგი ავტომატურად თარგმნის სურათებს."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "იგი ავტომატურად თარგმნის სურათებს.",
      "explanation": "react-i18next მხარს უჭერს თარგმანებს, პლურალიზაციას და ინტერპოლაციას, თუმცა მას არ შეუძლია სურათების ავტომატური თარგმნა."
    },
    "51": {
      "question": "რა განსხვავებაა useRef-სა და useState-ს შორის?",
      "options": [
        "useRef-ი იწვევს განახლებებს(re-renders), როცა useState-ი არ იწვევს არანაირი რენდერინგს.",
        "useState-ი იწვევს განახლებებს(re-renders), როცა useRef-ი არ იწვევს არანაირი რენდერინგს.",
        "ორივე ხელსაწყო იწვევს რენდერირებას თანაბარძალოვნად.",
        "არცერთს არ შეუძლია რენდერებს შორის მნიშვნელობების შენახვა."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "useState-ი იწვევს განახლებებს(re-renders), როცა useRef-ი არ იწვევს არანაირი რენდერინგს.",
      "explanation": "მდგომარეობის useState-ით განახლება იწვევს ხელახალ რენდერირებას, თუმცა, useRef მნიშვნელობის განახლება კომპონენტის ხელახალ რენდერირებას არ იწვევს."
    },
    "52": {
      "question": "ნაგულისხმევად რა აქვს useRef-ს საწყის ღირებულებად, თუ არ მივუთითებთ ამას?",
      "options": [
        "null",
        "განუსაზღვრელი",
        "0",
        "მცდარობა"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "განუსაზღვრელი",
      "explanation": "თუ ჩვენ არ ჩავსვამთ საწყის ღირებულებას, მაშინ ნაგულისხმევად useRef(undefined)-იქმნება."
    },
    "53": {
      "question": "useRef-ის რომელი თვისება ინახავს რეალურ მნიშვნელობას?",
      "options": [
        "ღირებულება",
        "თარიღი",
        "მიმდინარე(current)",
        "ref"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "მიმდინარე(current)",
      "explanation": "useRef-ი აბრუნებს ობიექტს ერთი თვისებით, რომელსაც ეწოდება-'current', სადაც ინახება ღირებულება."
    },
    "54": {
      "question": "რომელი სიტუაცია არ წარმოადგენს useRef-ის გამოყენების გავრცელებულ შემთხვევას?",
      "options": [
        "DOM ელემენტის მითითებების შენახვა",
        "რენდერებს შორის წინა მნიშვნელობების თვალყურის დევნება",
        "ზედმეტი ხელახალი რენდერინგის თავიდან აცილება",
        "გლობალური მდგომარეობის მართვა მრავალი კომპონენტის მეშვეობით"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "გლობალური მდგომარეობის მართვა მრავალი კომპონენტის მეშვეობით",
      "explanation": "useRef კომპონენტი ლოკალურია, იგი არაა შექმნილი გლობალური მიზნებისთვის. გლობალური მდგომარეობის მართვა კონტექსტური ან მდგომარეობის მართვის ბიბლიოთეკებით უნდა მოხდეს."
    },
   "55": {
      "question": "თუ შევქმნით ref-ს, const inputRef = useRef(null)-ით, მაშინ როგორ მოვახდენთ input-ის ფოკუსირებას ელემენტზე ამ ref-ერენსის გამოყენებით?",
      "options": [
        "inputRef.focus()",
        "inputRef.current.focus()",
        "focus(inputRef)",
        "useFocus(inputRef)"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "inputRef.current.focus()",
      "explanation": "Ref-ები თავიანთ საწყის მნიშვნელობას .current თვისებაში ინახავს. და რომ გამოვიძახოთ მეთოდი DOM ელემენტში (მაგალითად focus-ი), მაშინ უნდა გამოვიყენოთ useRef-ის current მეთოდი ამგვარად: inputRef.current.focus()."
    },
    "56": {
      "question": "ვინ არის React-ის შემქმნელი?",
      "options": [
        "მარკ ცუკერბერგი",
        "ჯორდან უოკი",
        "დენ აბრამოვი",
        "ლევან საგინაშვილი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ჯორდან უოკი",
      "explanation": "React-ი შექმნა ჯორდან უოკმა, რომელიც არის პროგრამული უზრუნველყოფის ინჟინერი ფეიქბუქში."
    },
    "57": {
      "question": "რა დრო დასჭირდა ჯორდან უოკს React-ის პირველი ვერსიის შესაქმნელად?",
      "options": [
        "ერთი კვირა",
        "ორი კვირა",
        "რამდენიმე თვე",
        "თითქმის ერთი წელი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ერთი კვირა",
      "explanation": "ჯორდან უოლკმა React-ის პირველი მოქმედი პროტოტიპი სულ რაღაც ერთ კვირაში შექმნა, Facebook-ში ექსპერიმენტების ჩატარების დროს."
    },
    "58": {
      "question": "რომელ წელს გახდა React-ი პირველად საჯარო?",
      "options": [
        "2009",
        "2011",
        "2013",
        "2015"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "2013",
      "explanation": "React ღია კოდის იყო და Facebook-მა იგი საჯარო JSConf US-ზე 2013 წლის მაისში გახადა."
    },
    "59": {
      "question": "რატომ გადაწყვიტა ჯორდან უოკმა React-ის შექმნა?",
      "options": [
        "Facebook-ის სიახლეების არხის მუშაობის გასაუმჯობესებლად.",
        "რომ ჩაენაცვლებინა jQuery-ი.",
        "მობილური აპლიკაციების შესაქმნელად.",
        "Angular-ისთვის კონკურენციის გასაწევად."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "Facebook-ის სიახლეების არხის მუშაობის გასაუმჯობესებლად.",
      "explanation": "React დაიბადა Facebook-ის დინამიური სიახლეების არხის უფრო სწრაფი და ეფექტური გახდომის საჭიროებიდან გამომდინარე."
    },
    "60": {
      "question": "დღესდღეისობით რომელი კომპანია ინარჩუნებს React-ს ოფიციალურად?",
      "options": [
        "გუგლი",
        "Meta (ფეიქბუქი)",
        "Microsoft-ი",
        "Airbnb-ი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "Meta (ფეიქბუქი)",
      "explanation": "React-ს ოფიციალურად Meta (ყოფილი Facebook) ინარჩუნებს, ღია კოდის საზოგადოების წვლილით."
    },
    "61": {
      "question": "თავდაპირველად რა ერქვა React-ს, სანამ იგი გახდებოდა ყველასათვის ხელმისაწვდომი?",
      "options": [
        "JSX Engine",
        "FaxJS",
        "XHP",
        "FaxDOM"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "FaxJS",
      "explanation": "React თავდაპირველად Facebook-ში FaxJS-ის სახელით იყო ცნობილი, სანამ მას სახელი არ შეეცვალა და ღია კოდის პროგრამად არ გადაკეთდა."
    },
    "62": {
      "question": "რას ნიშნავს JSX React-ში?",
      "options": [
        "ჯავასკრიპტ XML-ი.",
        "ჯავა სინტაქსური გაფართოება.",
        "ჯავასკრიპტის გაფართოება.",
        "JSON XML-ი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ჯავასკრიპტ XML-ი.",
      "explanation": "JSX ნიშნავს JavaScript XML-ს, რაც ნიშნავს რომ იგი დეველოპერებს საშუალებას აძლევს დაწერონ html-ის მსგავსი სინტაქსი პირდაპირ ჯავასკრიპტში."
    },
    "63": {
      "question": "რატომ ვიყენებთ JSX-ს React-ში?",
      "options": [
        "Because browsers can read JSX directly",
        "To make React code more readable and expressive",
        "Because it replaces JavaScript",
        "To speed up CSS rendering"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "To make React code more readable and expressive",
      "explanation": "JSX makes writing UI easier by combining markup with JavaScript logic, though browsers compile it into regular JavaScript."
    },
    "64": {
      "question": "რეაქტის ბაზაზე რას წარმოადგენს Framer Motion?",
      "options": [
        "ის არის CSS-ის წინასწარი პროცესორი.",
        "ის არის რეაქტის ანიმაციების ბიბლიოთეკა.",
        "არის სატესტო ინსტრუმენტი.",
        "ის არის სახელმწიფო მართვის ბიბლიოთეკა"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის არის რეაქტის ანიმაციების ბიბლიოთეკა.",
      "explanation": "Framer Motion არის პოპულარული ბიბლიოთეკა რეაქტში რომ შეცქმნათ ანიმაციები."
    },
    "65": {
      "question": "როგორ უნდა გავდარქმნათ ჩვეულებრივი HTML ტეგი ანიმაციურ ტეგად (მაგალითად div-ი ან section-ი) Framer Motion-ის გამოყენებით?",
      "options": [
        "ტეგის <AnimatePresence>-სში მოთავსებით",
        "ჩვეულებრივი ტეგის გარდაქმნით ამგვარად: motion.div ან motion.section",
        "'motion' class-ის დამატებით",
        "CSS transitions-ის ნების დართვის მინიჭებით"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ჩვეულებრივი ტეგის გარდაქმნით ამგვარად: motion.div ან motion.section",
      "explanation": "Framer Motion უზრუნველყოფს მოძრაობის კომპონენტებს(motion.div, motion.section, და ასშ.) რომლებიც HTML ანალოგების მსგავსად მუშაობენ, თუმცა ისინი მხარს უჭერენ ანიმაციებს."
    },
    "66": {
      "question": "რა დანიშნულება აქვს AnimatePresence-ს Framer Motion-ში?",
      "options": [
        "რომ მან გასტილოს ელემენტები",
        "რომ მოახდინონ ანიმაციების შემოტანა როცა ისინი შედიან და გამოდიან რეაქტის ხიდან.",
        "რომ შექმნან გლობალური სახელმწიფო",
        "რომ მოახდინოს სურათების გადატვირთვები"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "რომ მოახდინონ ანიმაციების შემოტანა როცა ისინი შედიან და გამოდიან რეაქტის ხიდან.",
      "explanation": "AnimatePresence საშუალებას იძლევა გამოვიდეთ ანიმაციებიდან კომპონენტების წაშლისას და შევიდეს ანიმაციები მათი დამატებისას."
    },
    "67": {
      "question": "როგორ შემოგვაქვს Motion-ის ანიმაციები ჩვენს JSX-ის ფაილში?",
      "options": [
        "import { motion } from 'framer-motion';",
        "import [ Motions ] from 'motion';",
        "import 'framer-motion' from motion ;",
        "{ motion }"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "import { motion } from 'framer-motion';",
      "explanation": "რომ გავხადოთ ნებადართული motion ბიბლიოთეკის ანიმაციები, შემოგვაქვს იგი ჩვეულებრივ ისე როგორც სხვა ბიბლიოთეკები"
    },
    "68": {
      "question": "<motion.section>-ის ტეგის ამგვარად განახლებით, როგორ უნდა მოვახდინოთ მასში ანიმაციების დამატება?",
      "options": [
        "<motion.section initial={{...}} animate={{...}} transition={{...}}",
        "<motion.section>-ის შემოტანა უკვე ქმნის ავტმატურად მორგებულ ანიმაციებს",
        "<motion.section initial=[...] animate=[...] transition=[...]",
        "<motion.section createAnimation={{...}}"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "<motion.section initial={{...}} animate={{...}} transition={{...}}",
      "explanation": "როდესაც ტეგს ანიმაციურად გარდავქმნით, მასში უნდა მივუთითოთ საწყისი მდგომარეობა(initial) და თუ რა უნდა გააკეთოს მან(animate), საბოლოოდ კი დრო და სტილი(transition)"
    },
    "69": {
      "question": "რას წარმოადგენს `exit`-ი Framer Motion-ში, და როგორ გამოიყენება?",
      "options": [
        "ის განსაზღვრავს, თუ როგორი ანიმაცია მოხდება როცა ელემენტი React ხეს დატოვებს.",
        "ის ეგრევე იწყებს ანიმაციის შექმნას ეკრანზე ჩატვირთვის დროს(on mount)",
        "ის ანიმაციას საწყის მდგომარეობას უბრუნებს",
        "ის ანიმაციას სამუდამო ციკლში ტოვებს"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის განსაზღვრავს, თუ როგორი ანიმაცია მოხდება როცა ელემენტი React ხეს დატოვებს.",
      "explanation": "`exit`-ის გამოიყენება <AnimatePresence>-თან ერთად, გვაძლევს ანიმაციას იმისთვის რომ გაკონტროლდეს კომპონენტის ანიმაცია DOM-დან მისი ამოღების შემდეგ. მაგალითად: `<motion.div exit={{ opacity: 0 }} />` ელემენტს აფერმკრთალებს როცა ხდება გასვლა ანიმაციიდან."
    },
    "70": {
      "question": "რა არის custom hook-ი, რეაქტში?",
      "options": [
        "ისაა მეთოდი რომლითაც იქმნება ახალი საციცოცხლო ციკლი.",
        "ფუნქცია, რომელიც იწყება „use“-ით და ხელახლა იყენებს რამდენიმე ჰუკის ლოგიკას.",
        "ფუნქცია, რომელიც იყენებს ჯავასკრიპტის რამდენიმე ბიბლიოთეკას ერთდროულად.",
        "ისაა მეთოდი რომლითაც ხდება ახალი DOM API-ს შექმნა."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ფუნქცია, რომელიც იწყება „use“-ით და ხელახლა იყენებს რამდენიმე ჰუკის ლოგიკას.",
      "explanation": "Custom hooks are regular JavaScript functions that start with 'use' and allow reusing stateful logic across components."
    },
    "71": {
      "question": "როდისაა რეკომენდირებული custom hook-ის გამოყენება?",
      "options": [
        "როდესაც ერთი და იგივე ლოგიკა მრავალ კომპონენტში მეორდება",
        "მხოლოდ კლასის კომპონენტების გამოყენებისას",
        "როცა უფრო სწრაფი აპლიკაციის შექმნა გვსურს",
        "CSS ანიმაციების დამატებისას"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "როდესაც ერთი და იგივე ლოგიკა მრავალ კომპონენტში მეორდება",
      "explanation": "მორგებული ჰუკები იდეალურია, როდესაც გვჭირდება ლოგიკის ხელახალი გამოყენება, მაგალითად, მონაცემების მოძიება, ან გამოწერები რამდენიმე ადგილას, მორგებულ ჰუკს შეუძლია გამოიყენოს როგორც useState, ასევე useEffect და useRef ერთდროულად."
    },
    "72": {
      "question": "რაში გვჭირდება custom hook-ების შექმნა?",
      "options": [
        "დუბლირებული ლოგიკის თავიდან ასაცილებლად და კოდის გასამარტივებლად.",
        "რეაქტის კომპონენტების შესაცვლელად.",
        "CSS სტილებზე თავის უკეთესად გასართმევად.",
        "მხოლოდ სერვერის რენდერინგის ოპტიმიზაციისთვის"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "დუბლირებული ლოგიკის თავიდან ასაცილებლად და კოდის გასამარტივებლად.",
      "explanation": "Custom hook-ები ამოცნობას უკეთებენ მრავალჯერადად გამოსაყენებ ლოგიკას, რაც გვიმცირებს კოდის მრავალჯერადად გამეორების საჭიროებას და ის ხდის კომპონენტებს უფრო მარტივად წასაკითხს და მოსავლელს."
    },
    "73": {
      "question": "რომელი წესები უნდა იყოს დაცული custom hooks-ების გამოყენებისას?",
      "options": [
        "მათ პირობითად შეიძლება ვუწოდოთ.",
        "ისინი უნდა იწყებოდნენ მაგიური სიტყვა 'use'-ით.",
        "ისინი აუცილებლად უნდა აბრუნებდნენ JSX-ს.",
        "ისინი გამოყენებული უნდა იქნან მხოლოდ App.js-ებში"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ისინი უნდა იწყებოდნენ მაგიური სიტყვა 'use'-ით.",
      "explanation": "Custom hook-ები აუცილებლად უნდა იწყებოდნენ მაგიური სიტყვა 'use'-ით, ამგვარად, React-ს შეუძლია სწორად გამოიყენოს თავისი ჰუკების წესები."
    },
    "74": {
      "question": "ქვემოთ ჩამოთვლილთაგან რომელია მორგებული კაუჭის კარგი მაგალითი?",
      "options": [
        "useFetch-ინგის გამოყენება API მოთხოვნების დასამუშავებლად.",
        "useStyles რომ ნებართვები მიეცეს CSS-ს.",
        "useDOM ელემენტების ხელით შესაქმნელად.",
        "პირობითი ფრაზებისთვის If/Else-ების გამოყენება."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "useFetch-ინგის გამოყენება API მოთხოვნების დასამუშავებლად",
      "explanation": "useFetch-ის მსგავსი მორგებული ჰუკები მრავალჯერადი გამოყენების ლოგიკას აერთიანებს, როგორიცაა მონაცემების მოძიება API-დან."
    },
    "75": {
      "question": "JSX ნიშნავს JavaScript XML-ს, მაგრამ რას ნიშნავს ეს რეალურად React-ში?",
      "options": [
        "ის საშუალებას გვაძლევს HTML პირდაპირ JavaScript-ში ჩავწეროთ,",
        "ის სრულიად ცვლის ჯავასკრიპტს თავიდან ბოლომდე,",
        "ის HTML კოდს პირდაპირ ბრაუზერში ამუშავებს",
        "ის ჯავასკრიპტს გარდაქმნის CSS-ის კომპილატორად."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ის საშუალებას გვაძლევს HTML პირდაპირ JavaScript-ში ჩავწეროთ",
      "explanation": "JSX არის სინტაქსის გაფართოება, რომელიც საშუალებას იძლევა HTML-ის მსგავსი კოდი JavaScript-ში დავწეროთ(გავმიქსოთ, მაგალითად როგორც კვერცხი და ფქვილის მიქსი რაც გვაძლევს ბლინებს). ის თავად HTML არ არის, იგი კომპილირდება React.createElement გამოძახებებში."
    },
    "76": {
      "question": "როგორ შეიძლება რეაქტის აღწერა ყველაზე მარტივად გასაგებ ენაზე?",
      "options": [
        "იგი გავს ცხობის პროცესს როცა კვერცხს და ფქვილს ვურევთ რომ მივიღოთ ბლინები",
        "იგი გავს ატომს რადგან ყველაფერი მასში მუშაობს ატომური სისწრაფით",
        "იგი არის რეაქტიული თვითმფრინავივით, მისი ბიბლიოთეკების წყალობით",
        "მისი აღწერა შეუძლებელია ადამიანისთვის გასაგებ ენაზე"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "იგი გავს ცხობის პროცესს როცა კვერცხს და ფქვილს ვურევთ რომ მივიღოთ ბლინები",
      "explanation": "რეაქტი ნამდვილად წააგავს ცხობის პროცესს, ვინაიდან ჩვენ ვაბლენდერებთ HTML/Javascript-ს ერთ ქვაბში, და ვიღებთ უგემრიელეს შედეგს."
    },
    "77": {
      "question": "React-ის გუნდის რომელმა წევრმა შემოიღო Hooks-ის კონცეფცია 2018 წელს?",
      "options": [
        "ჯორდან უოკი",
        "დენ აბრამოვი",
        "ენდრიუ კლარკი",
        "სებასტიან მარკბოგე"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "დენ აბრამოვი",
      "explanation": "დენ აბრამოვმა React Conf 2018-ში წარადგინა Hook-ების გამოყენების შესაძლებლობის შესახებ, რამაც მდგომარეობა და ეფექტები კლასის კომპონენტების გამოყენების გარეშე შესაძლებელი გახადა."
    },
    "78": {
      "question": "რა არის React Fiber-ის (React-ის გადაწერის) შექმნის საიდუმლო მიზეზი?",
      "options": [
        "სერვერის მხარეს რენდერინგის გასაუმჯობესებლად",
        "ასინქრონული რენდერინგი და დაგეგმვების მხარდაჭერა",
        "რომ JSX-ი გამხდარიყო უფრო სწრაფი",
        "Redux-ის შესაცვლელად შეიქმნა"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ასინქრონული რენდერინგი და დაგეგმვების მხარდაჭერა",
      "explanation": "React Fiber-ი წარმოადგენდა React-ის ძირითადი ალგორითმის სრულ გადაწერას, რათა უზრუნველყოფილიყო შეფერხებული რენდერინგი, პრიორიტეტების მინიჭება და შეუფერხებელი ასინქრონული განახლებები."
    },
    "79": {
      "question": "React-ის რომელი ფუნქცია იყო შთაგონებული Facebook-ში გამოყენებული PHP ბიბლიოთეკით?",
      "options": [
        "JSX",
        "ჰუკები",
        "კონტექსტური API",
        "კონკურენტული რეჟიმი"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "JSX",
      "explanation": "JSX-ის შთაგონება Facebook-ის PHP ბიბლიოთეკა XHP-ით იყო მიღებული, რომელიც XML-ის მსგავსი სინტაქსის PHP კოდთან შერევის საშუალებას იძლეოდა."
    }
  },
  "custom": {
    "1": {
    "question": "Tailwind CSS-ში, ქვემოთ ჩამოთვლილთაგან რომელი ქმნის ორი ფერის(წითელი და ცისფერი) ნაზავს დიაგონალურად?",
    "options": [
      "bg-gradient-to-r from-red-500 to-blue-500",
      "bg-gradient-to-tr from-red-500 to-blue-500",
      "bg-diagonal from-red-500 to-blue-500",
      "bg-gradient-diagonal from-red-500 to-blue-500"
    ],
    "level": "<easy>მარტივი</easy>",
    "correct": "bg-gradient-to-t from-red-500 to-blue-500",
    "explanation": "Tailwind-ში, ზემოთ(`to-t`) ქმნის ფერების გრადიენტს ქვემოდან ზემოთ(დიაგონალზე). სხვა მიმართულებები ან ზუსტი ხაზისაა ან საერთოდ არ ჩანან."
    },
    "2": {
      "question": "რომელი React-ის ჰუკი გვაძლევს საშუალებას რომ შევინახოთ მნიშვნელობა, რომელიც რენდერების განმავლობაში რჩება, მაგრამ ცვლილებისას ხელახლა რენდერირებას არ იწვევს?",
      "options": [
        "useState()",
        "useEffect()",
        "useRef()",
        "useMemo()"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "useRef()",
      "explanation": "`useRef` ინახავს მრავალნაირ ღირებულებას თავში, რომლებიც ახერხებენ გადარჩენას რენდერინგის დროს, ანუ ისინი ახდენენ განახლებას კომპონენტის განახლების გარეშე."
    },
    "3": {
      "question": "რას დააბრუნებს ეს ჩანაწერი: `console.log([] + {});` ჩვენი ჯავასკრიპტის კონსოლში?",
      "options": [
        "[object Object]",
        "0",
        "NaN",
        "''" 
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "[object Object]",
      "explanation": "ჯავასკრიპტში, მასივის ობიექტზე დამატება გარდაქმნის ორივეს string-ად : ანუ მასივის ფრჩხილები გარდაიქმნება []-იდან ''-მდე, ხოლო `{}`-ი გარდაიქმნება: '[object Object]', რაც საბოლოოდ გვაძლევს: '[object Object]'."
    },
    "4": {
      "question": "HTML-ში რომელი თეგი არ არის სტანდარტული, მაგრამ ზოგჯერ გამოიყენება დასაკეცი კონტენტის შესაქმნელად?",
      "options": [
        "<details>",
        "<summary>",
        "<collapse>",
        "<dialog>"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "<collapse>",
      "explanation": "`<collapse>` არ არის სტანდარტული HTML ტეგი; `<details>` და `<summary>` სტანდარტული დასაკეცი ელემენტებია."
    },
    "5": {
      "question": "რომელი React ხატულების ბიბლიოთეკა გაძლევთ საშუალებას იმპორტიროთ მხოლოდ ინდივიდუალური ხატულები პაკეტის ზომის შესამცირებლად?",
      "options": [
        "react-icons",
        "font-awesome",
        "ionicons",
        "material-icons"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "react-icons",
      "explanation": "`react-icons` supports tree-shaking so you can import only the icons you need."
    },
    "6": {
      "question": "რას გამოიტანს `console.log([] * 2);` JavaScript-ში?",
      "options": [
        "[]",
        "0",
        "NaN",
        "[,]"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "0",
      "explanation": "ცარიელი მასივი რიცხვითი ოპერაციების დროს `0`-ად გარდაიქმნება, ამიტომ 2-ზე გამრავლება 0-ს გვაძლევს შედეგად."
    },
    "7": {
      "question": "რომელი Tailwind კლასი შექმნის ფონს **მრავალი ფერის შერევით 50%-იანი გამჭვირვალობით**?",
      "options": [
        "bg-gradient-to-r from-red-500/50 to-blue-500/50",
        "bg-mix-red-blue",
        "bg-opacity-50",
        "bg-blend-multiply"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "bg-gradient-to-r from-red-500/50 to-blue-500/50",
      "explanation": "Tailwind საშუალებას აძლევს `/50` სინტაქსს დააყენოს 50%-იანი გამჭვირვალობა გრადიენტულ ფერებზე, რაც ქმნის ნახევრად გამჭვირვალე ნაზავს."
    },
    "8": {
      "question": "React-ში, რომელ მორგებულ ჰუკს შექმნიდით სავარაუდოდ მონაცემების მოძიების და მდგომარეობის რეჟიმში შენახვისთვის?",
      "options": [
        "useDataFetch",
        "useEffectFetch",
        "useCustomState",
        "useFetchHook"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "useDataFetch",
      "explanation": "მორგებული ჰუკები, როგორც წესი, იწყება `use`-ით და მოიცავს ლოგიკას, როგორიცაა მონაცემთა მოძიება, მაგ., `useDataFetch`."
    },
    "9": {
      "question": "ამ CSS ერთეულებიდან რომელია ფარდობითი root ელემენტის შრიფტის ზომა?",
      "options": [
        "em",
        "rem",
        "vh",
        "vw"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "rem",
      "explanation": "`rem` ნიშნავს 'root em'-ს და მასშტაბირდება root ელემენტის შრიფტის ზომასთან, `em`-სგან განსხვავებით, რომელიც მშობელ ელემენტთან მაშტაბირდება მხოლოდ."
    },
    "10": {
      "question": "ჯავასკრიპტში, რა მოხდება თუ გავუშვებთ: `const a = b = 5;`?",
      "options": [
        "a and b are both local variables",
        "b becomes global, a is local",
        "Both throw an error",
        "a becomes global, b is local"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "b becomes global, a is local",
      "explanation": "`var`-ის, `let`-ის ან `const`-ის გარეშე, `b = 5` ქმნის გლობალურ ცვლადს; `const a = ...` აცხადებს ლოკალურ მუდმივას."
    },
    "11": {
      "question": "HTML-ში, რომელი ტეგის გამოყენება შეიძლება მიმდინარე გვერდზე სხვა HTML გვერდის ჩასასმელად?",
      "options": [
        "<iframe>",
        "<embed-page>",
        "<include>",
        "<frame>"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "<iframe>",
      "explanation": "`<iframe>` ტეგი საშუალებას იძლევა მიმდინარე გვერდზე სხვა HTML დოკუმენტის ჩასმა. სხვა ტეგები ამ მიზანს არ ემსახურება."
    },
    "12": {
      "question": "რას გამოიტანს ეს JavaScript გამოსახულება: `[] + []`?",
      "options": [
        "0",
        "undefined",
        "' ' (empty string)",
        "[]"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "' ' (empty string)",
      "explanation": "JavaScript-ში, მასივებთან ერთად `+` ოპერატორის გამოყენება მათ სტრიქონებად გარდაქმნის, ამიტომ `[] + []` ცარიელ სტრიქონს იძლევა შედეგად."
    },
    "13": {
      "question": "რომელი Tailwind პროგრამა ქმნის ლურჯიდან მწვანემდე გრადიენტულ ფონს?",
      "options": [
        "bg-gradient-to-r from-blue-500 to-green-500",
        "gradient-blue-green",
        "bg-blue-green-gradient",
        "bg-gradient-blue-to-green"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "bg-gradient-to-r from-blue-500 to-green-500",
      "explanation": "Tailwind იყენებს `bg-gradient-to-{direction}`-ს `from-{color}`-თან და `to-{color}`-თან ერთად, გრადიენტული ფონის შესაქმნელად."
    },
    "14": {
      "question": "React-ში, რაში გვეხმარება `key` prop, სიებში?",
      "options": [
        "Changing the component's style",
        "Tracking elements for efficient re-rendering",
        "Assigning unique IDs for CSS",
        "Animating components automatically"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "Tracking elements for efficient re-rendering",
      "explanation": "React იყენებს `გასაღებს` რენდერებს შორის ელემენტების იდენტიფიცირებისთვის, რათა მას ეფექტურად განაახლოს მხოლოდ შეცვლილი ელემენტები."
    },
    "15": {
      "question": "რას მივიღებთ შედეგად: `console.log([] * 2);`?",
      "options": [
        "[]",
        "0",
        "NaN",
        "TypeError"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "0",
      "explanation": "JavaScript ცარიელ მასივს რიცხვად გარდაქმნის, რომელიც 0-ის ტოლი ხდება. 0-ის 2-ზე გამრავლებით მიიღება 0."
    },
    "16": {
      "question": "რომელი HTML ატრიბუტი გაძლევთ საშუალებას, სურათებისთვის ალტერნატიული ტექსტი მოგვაწოდოთ?",
      "options": [
        "alt",
        "title",
        "src-alt",
        "description"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "alt",
      "explanation": "`alt` ატრიბუტი უზრუნველყოფს სურათების ალტერნატიულ ტექსტს, თუ მათი ჩვენება შეუძლებელია და აუმჯობესებს ხელმისაწვდომობას."
    },
    "17": {
      "question": "React-ში, რომელი კაუჭი(Hook) გამოიყენება ფუნქციურ კომპონენტებში მდგომარეობის სამართავად?",
      "options": [
        "useState",
        "useEffect",
        "useContext",
        "useReducer"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "useState",
      "explanation": "`useState` არის სტანდარტული React ჰუკი ფუნქციურ კომპონენტებზე მდგომარეობის დასამატებლად."
    },
    "18": {
      "question": "რომელი CSS თვისება გამოიყენება ასოებს შორის მანძილის გასაკონტროლებლად?",
      "options": [
        "letter-spacing",
        "word-spacing",
        "text-indent",
        "line-height"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "letter-spacing",
      "explanation": "`ასოების ინტერვალი` არეგულირებს ტექსტში სიმბოლოებს შორის მანძილს."
    },
    "19": {
      "question": "ჯავასკრიპტში, რა არის `typeof null`-ის შედეგი?",
      "options": [
        "'null'",
        "'object'",
        "'undefined'",
        "'number'"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "'object'",
      "explanation": "ისტორიული შეცდომის გამო, `typeof null` აბრუნებს 'object'-ს, მიუხედავად იმისა, რომ null ობიექტი არ არის."
    },
    "20": {
      "question": "როგორ შეგვიძლია შევქმნათ ელეგანტური გრადიენტული ტექსტი Tailwind CSS-ის გამოყენებით?",
      "options": [
        "მხოლოდ ტექსტის ფერის კლასების გამოყენებით",
        "ინტერნეტიდან გრადიენტის ტექსტის ჩამოტვირთვით",
        "`text-transparent`-ის, `bg-clip-text`-ის და ფონის გრადიენტის გამოყენებით",
        "კერძო CSS ბიბლიოთეკების გამოყენებით"
      ],
      "level": "<easy>easy</easy>",
      "correct": "`text-transparent`-ის, `bg-clip-text`-ის და ფონის გრადიენტის გამოყენებით",
      "explanation": "თანამედროვე გრადიენტის ტექსტის შესაქმნელად, გახადეთ ტექსტი გამჭვირვალე, გამოიყენეთ `bg-clip-text` და დააყენეთ ფონის გრადიენტი. შემდეგ ტექსტში გამოჩნდება გრადიენტის ფერები."
    },
    "21": {
      "question": "რომელი HTML თეგი გამოიყენება დამოუკიდებელი კონტენტის განსაზღვრისთვის, რომელსაც ხშირად საკუთარი სათაური აქვს?",
      "options": [
        "<section>",
        "<div>",
        "<article>",
        "<span>"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "<article>",
      "explanation": "`<article>` ტეგი წარმოადგენს დამოუკიდებელ კონტენტს, რომელსაც შეიძლება ჰქონდეს საკუთარი სათაური და გავრცელდეს დამოუკიდებლად."
    },
    "22": {
      "question": "რას გამოიტანს `console.log([] == ![]);` JavaScript-ში?",
      "options": [
        "true",
        "false",
        "undefined",
        "TypeError"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "true",
      "explanation": "ტიპის იძულების გამო: `![]` ხდება false, `[] == false` JavaScript-ში ფასდება როგორც true."
    },
    "23": {
      "question": "რომელი Tailwind კლასი ამატებს ჩრდილის ეფექტს ელემენტებს?",
      "options": [
        "shadow",
        "box-shadow",
        "shadow-effect",
        "drop-shadow"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "shadow",
      "explanation": "Tailwind იყენებს `shadow`-ს (და ვარიაციებს, როგორიცაა `shadow-md`) ელემენტებზე, box-shadow ეფექტების გამოსაყენებლად."
    },
    "24": {
      "question": "React-ში, რა არის მორგებული ჰუკის შექმნის ძირითადი მიზეზი?",
      "options": [
        "კომპონენტების სტილიზაცია",
        "მრავალჯერადი გამოყენების ლოგიკის გაზიარება",
        "DOM-ის პირდაპირი მანიპულირებისთვის",
        "კომპონენტების შესაცვლელად"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "მრავალჯერადი გამოყენების ლოგიკის გაზიარება",
      "explanation": "მორგებული ჰუკები დეველოპერებს საშუალებას აძლევს, მოახდინონ მდგომარეობის ლოგიკის ინკაფსულაცია და ხელახლა გამოყენება მრავალ კომპონენტში."
    },
    "25": {
      "question": "რომელი CSS თვისება იძლევა საშუალებას რომ ვაკონტროლოთ გადავსებული კონტენტის დამუშავება?",
      "options": [
        "overflow",
        "text-overflow",
        "clip",
        "content-overflow"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "overflow",
      "explanation": "`overflow` განსაზღვრავს, თუ როგორ გამოჩნდება ელემენტის ველის მიღმა არსებული კონტენტი (დამალული, გადახვევადი, ავტომატური თუ ხილული)."
    },
    "26": {
      "question": "რას აკეთებს React-ში `useEffect` კაუჭი ცარიელი დამოკიდებულების მასივით (`[]`)?",
      "options": [
        "გაეშვება ყოველ განახლებაზე.",
        "გაეშვება ერთხელ, პირველი რენდერის დროს.",
        "არასოდეს არ გაეშვება.",
        "გაეშვება მხოლოდ მაშინ როცა მდგომარეობა შეიცვლება."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "გაეშვება ერთხელ, პირველი რენდერის დროს.",
      "explanation": "ცარიელი დამოკიდებულების მასივი`useEffect`-ს აიძულებს რომ მასში ჩაწერილი კოდი გაეშვას ერთხელ(componentDidMount ქცევის იმიტაცია)."
    },
    "27": {
      "question": "რომელი Tailwind CSS კლასი გამოიყენება პირდაპირ ტელეფონის (მობილურის) ეკრანებზე?",
      "options": [
        "max-w-3xl",
        "sm:max-w-3xl",
        "md:max-w-3xl",
        "lg:max-w-3xl"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "max-w-3xl",
      "explanation": "Tailwind CSS-ში, პრეფიქსების გარეშე კლასები სტანდარტულად გამოიყენება ყველა ზომის ეკრანისთვის, მათ შორის ტელეფონებისთვისაც. პრეფიქსები, როგორიცაა sm:, md: და lg:, გამოიყენება სტილების გამოყენებით, ტელეფონზე ოდნავ დიდი გაჯეტებიდან ზემოთ."
    },
    "28": {
      "question": "რომელი HTML ატრიბუტის გამოყენება შეიძლება ფორმის გაგზავნამდე აუცილებელი შეყვანის ველის შესაქმნელად?",
      "options": [
        "required",
        "validate",
        "mandatory",
        "check"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "required",
      "explanation": "`required` ატრიბუტი უზრუნველყოფს, რომ ფორმის ცარიელად დატოვება აკრძალული იქნას და ხდის მათ აუცილებლად შესავსებს."
    },
    "29": {
      "question": "Tailwind-ში, როგორ გამოვიყენოთ გრადიენტიანი ფონი ზემოდან ქვემოდან?",
      "options": [
        "bg-gradient-to-b",
        "bg-gradient-top-bottom",
        "gradient-vertical",
        "bg-top-bottom-gradient"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "bg-gradient-to-b",
      "explanation": "`bg-gradient-to-b` Tailwind-ში იყენებს გრადიენტს ზემოდან ქვემოთ; `from-{color}` და `to-{color}` განსაზღვრავენ ფერებს."
    },
    "30": {
      "question": "რომელი HTML თეგია შესაფერისი ვებსაიტისთვის ნავიგაციის ბმულების დასადგენად?",
      "options": [
        "<nav>",
        "<menu>",
        "<section>",
        "<header>"
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "<nav>",
      "explanation": "`<nav>` ტეგი განსაზღვრავს ვებსაიტის ან აპლიკაციის ნავიგაციის ბმულების ერთობლიობას."
    },
    "31": {
      "question": "როდესაც ვებ პროექტს ვტვირთავთ Github-ზე და თუ ამ პროექტში ვიყენებთ Routing-სისტემას, რა ფაქტს უნდა ვაცნობიერებდეთ?:",
      "options": [
        "რომ path='/'(საწყისი ფაილი), დახრილი ხაზის გამოუყენებლობა გამოიწვევს არასასურველ ხარვეზს.",
        "რომ github-ზე routing-ი არაა ნებადართული.",
        "რომ შესაძლებელია ვებგვერდი სრულიად წაიშსალოს.",
        "რომ არანაირი საშიშროება არ არსებობს, რადგან routing-ი სრულიად უსაფრთხოა."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "რომ path='/'(საწყისი ფაილი), დახრილი ხაზის გამოუყენებლობა გამოიწვევს არასასურველ ხარვეზს.",
      "explanation": "როდესაც პროექტს ვტვირთავთ გლობალურ სერვერზე და ვიყენებთ როუტინგს, რამდენიმე ფაილის დასაკავშირებლად, აუცილებელია საწყისი ფაილის მითითება დახრილი ხაზით: path='/'."
    },
    "32": {
      "question": "React-ში, რომელი ჰუკი საშუალებას გაძლევთ შეინარჩუნოთ მნიშვნელობები რენდერებს შორის ხელახალი რენდერინგის გარეშე?",
      "options": [
        "useState",
        "useEffect",
        "useRef",
        "useMemo"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "useRef",
      "explanation": "`useRef`-ს შეუძლია შეინახოს ცვალებადი მნიშვნელობა, რომელიც რენდერების განმავლობაში შენარჩუნდება კომპონენტის განახლების გააქტიურების გარეშე."
    },
    "33": {
      "question": "რომელი CSS თვისება გამოიყენება პოზიციონირებული ელემენტების თანმიმდევრობის შესაცვლელად?",
      "options": [
        "z-index",
        "order",
        "stack-order",
        "position-level"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "z-index",
      "explanation": "`z-index` განსაზღვრავს ელემენტების თანმიმდევრობას, პოზიციის მახასიათებლით (relative, absolute, fixed, or sticky)."
    },
    "34": {
      "question": "რა მოხდება, თუ ჯავასკრიპტში გამოვიყენებთ `const arr = [...null];`-ს?",
      "options": [
        "იგი შექმნის ცარიელ მასივს",
        "გვესვრის TypeError-ს",
        "შეიქმნება მასივი null-ით როგორც მისი ელემენტი.",
        "მოხდება განუსაზღვრელი ქმედება."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "გვესვრის TypeError-ს",
      "explanation": "ჩვენ არ შეგვიძლია `null`-ის გავრცელება, რადგან ის არ არის განმეორებადი, რაც იწვევს TypeError-ს."
    },
    "35": {
      "question": "Tailwind-ში, რომელ კლასს შეუძლია ერთ ელემენტში რამდენიმე გრადიენტის ფერის შერევა?",
      "options": [
        "bg-gradient-to-r from-red-500 via-yellow-300 to-green-500",
        "bg-mix-gradient-red-yellow-green",
        "gradient-colors-red-yellow-green",
        "bg-multi-gradient"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "bg-gradient-to-r from-red-500 via-yellow-300 to-green-500",
      "explanation": "Tailwind მხარს უჭერს მრავალფეროვან გრადიენტებს `from-{color} via-{color} to-{color}` სინტაქსის გამოყენებით."
    },
    "36": {
      "question": "რომელი React ხატულების ბიბლიოთეკა გამოიყენება ძირითადად მასშტაბირებადი ვექტორული ხატულებისთვის?",
      "options": [
        "react-fontawesome",
        "react-icons",
        "react-vectors",
        "react-svg-icons"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "react-icons",
      "explanation": "`react-icons` გთავაზობთ SVG ხატულების მრავალფეროვნებას React პროექტების პოპულარული ბიბლიოთეკებიდან."
    },
    "37": {
      "question": "რა განსხვავებაა `<output>`-სა და `<progress>`-ს შორის HTML-ში?",
      "options": [
        "<output> მოძველებულია როგორც var, <progress> შედარებით ახალი მეთოდია",
        "<output>-ი ინტერაქტიულია, <progress>-ი კი არაა.",
        "არანაირი სხვაობა არაა, ისინი ერთნაირად მუშაობენ.",
        "<output> აჩვენებს შედეგს, <progress> კი პროგრესს."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "<output> აჩვენებს შედეგს, <progress> კი პროგრესს.",
      "explanation": "`<output>` გამოიყენება სკრიპტების ან გამოთვლების შედეგების საჩვენებლად, ხოლო `<progress>` აჩვენებს დასრულების სტატუსს."
    },
    "38": {
      "question": "რას დაბეჭდავს `console.log({} == {});` ჯავასკრიპტში?",
      "options": [
        "true",
        "false",
        "undefined",
        "TypeError"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "false",
      "explanation": "ობიექტები შედარებულია მითითებით და არა მნიშვნელობით, ამიტომ ორი განსხვავებული ცარიელი ობიექტი არ იქნება ტოლი."
    },
    "39": {
      "question": "CSS-ში, რას ირჩევს `:nth-child(odd)`?",
      "options": [
        "მხოლოდ პირველ შვილს.",
        "ყველა ლუწი რიცხვის მქონე შვილობილ ელემენტს",
        "ყველა კენტი რიცხვის მქონე შვილობილ ელემენტს.",
        "მხოლოდ უცნაური ID-ების მქონე ელემენტებს."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ყველა კენტი რიცხვის მქონე შვილობილ ელემენტს.",
      "explanation": "`:nth-child(odd)` მიმართავს მშობლის შიგნით კენტ პოზიციეზე (1-ლი, მე-3, მე-5 და ა.შ.) მყოფ შვილობილ ელემენტებს."
    },
    "40": {
      "question": "React-ის რომელი ფუნქცია იძლევა ლოგიკის კომპონენტებისთვის უფრო პატარა, მრავალჯერად ფუნქციებად დაყოფის საშუალებას?",
      "options": [
        "უმაღლესი რიგის კომპონენტები.",
        "Custom Hook-ები.",
        "JSX ფრაგმენტები.",
        "Prop drilling-ი."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "Custom Hook-ები.",
      "explanation": "Custom Hook-ები საშუალებას იძლევა ხელახლა გამოვიყენოთ კომპონენტების ლოგიკა, კომპონენტების იერარქიის შეცვლის გარეშე."
    },
    "41": {
      "question": "როგორ შეგვიძლია რომ დავწეროთ სრულად ფუნქციონალური ჯავასკრიპტის კოდი ერთ ხაზზე, წაკითხვის სიმარტივის შენარჩუნებით?",
      "options": [
        "დავწერეთ რამდენიმე განცხადება, რომლებიც გამოყოფილია წერტილ-მძიმით.",
        "ამის განხორციელება შეუძლებელია.",
        "გამოვიყენოთ მხოლოდ გლობალური ცვლადები.",
        "ჭკვიანურად გამოიყენეთ ისრის ფუნქციები და Ternary ოპერატორები."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ჭკვიანურად გამოიყენეთ ისრის ფუნქციები და Ternary ოპერატორები.",
      "explanation": "ამგვარი რთული ინტერვიუს კითხვები ჩვენს სტრატეგიულად აზროვნების უნარს ამოწმებენ: შეგვიძლია ლოგიკა შევკუმშოთ ისრის ფუნქციების, Ternary ოპერატორების და ჯაჭვური მეთოდების გამოყენებით, კოდის ფუნქციონალურობის შენარჩუნებით."
    },
    "42": {
      "question": "მაქსიმუმ რამდენი ენის მხარდაჭერა შეუძლია i18n React-ის ბიბლიოთეკას?",
      "options": [
        "რამდენიმე",
        "მხოლოდ 1",
        "მხოლოდ 5",
        "მას არ აქვს შეზღუდვა"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "მას არ აქვს შეზღუდვა",
      "explanation": "i18n რეაქტის ბიბლიოთეკას არ აქვს შეზღუდვა ენების რაოდენობაზე. თქვენ შეგიძლიათ დაამატოთ რამდენიც გინდათ, მხოლოდ საჭიროა js ფაილის(i18n-ის თვის) და Json ფაილის შექმნა ყოველი ენისთვის."
    },
    "43": {
      "question": "youtube მეცადინეობებს გავლის შემდეგ, რით უნდა დაკავდეს ვებ დეველოპერი?",
      "options": [
        "მიზანშეწონილია რამდენიმე პროექტის შექმნა, შემდეგ კი მუშაობის დაწყება",
        "მიზანშეწონილია იმავე საკითხებზე გაჩერება და მათი დამუშავება",
        "მიზანშეწონილია რომ გააგძელოს სხვა ენების სწავლა(python, css, java)",
        "უნდა დაანებოს თავი სწავლას და დაიწყოს სამუშაოს ძებნა"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "მიზანშეწონილია რამდენიმე პროექტის შექმნა, შემდეგ კი მუშაობის დაწყება",
      "explanation": "თეორიული ცოდნის დასრულების შემდეგ საჭიროა პრაქტიკაზე მუშაობა, რაც დაგეხმარებათ გაანალიზოთ ხელსაწყოების შესახებ(თუ რა სად და როგორ გამოიყენება), და გამოიყენოთ ისინი უკეთესად."
    },
    "44": {
      "question": "როგორ შეგვიძლია ვალუტის კურსების შემოტანა, ენების მსგავსად, რეაქტში?",
      "options": [
        "API-ის გამოყენებით, მაგალითად fetch ან axios საშუალებით",
        "მხოლოდ ლოკალური ფაილიდან წაკითხვით",
        "მხოლოდ hardcoded კოდში ჩაწერით",
        "ვალუტის კურსები არ შეგვიძლია რეაქტში შემოვიტანოთ"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "API-ის გამოყენებით, მაგალითად fetch ან axios საშუალებით",
      "explanation": "რეაქტში ვალუტის კურსების ან ნებისმიერი დინამიური მონაცემის შემოტანა ხდება API-ებიდან, ძირითადად fetch() ან axios-ის გამოყენებით, და შედეგის შენახვა ხდება state-ში ან context-ში."
    },
    "45": {
      "question": "CSS-ში, რა მოხდება, თუ გადახვევადი მშობლის შიგნით არსებულ ელემენტზე `position: sticky`-ს გამოიყენებთ?",
      "options": [
        "ის ფიქსირებული დარჩება ხედვის არეალთან.",
        "ის მშობლის გადახვევის არეალში დარჩება.",
        "ის იმუშავებს როგორც Relative პოზიცია.",
        "ის დაიგნორებული დარჩება."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ის მშობლის გადახვევის არეალში დარჩება.",
      "explanation": "`პოზიცია: წებოვანი` საშუალებას აძლევს ელემენტს, ჩაეკრას თავის კონტეინერში და შეჩერდეს იქ."
    },
    "46": {
      "question": "რომელი შეიქმნა პირველი: HTML-ი თუ ჯავასკრიპტი?",
      "options": [
        "HTML",
        "ჯავასკრიპტი",
        "ორივე ერთდროულად",
        "არცერთი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "HTML",
      "explanation": "HTML შეიქმნა 1991 წელს ვებ გვერდების სტრუქტურისთვის, ხოლო პროგრამული ენა ჯავასკრიპტი გამოჩნდა 1995 წელს, დინამიკისა და ინტერაქტივობისთვის."
    },
    "47": {
      "question": "როდესაც ვიწყებთ პროექტზე მუშაობას, რომელი 3 მნიშვნელოვანი წესია გასათვალისწინებელი?:",
      "options": [
        "რომ იგი უნდა იყოს Responsive, უნდა იყოს აზრობრივად გამართული და საიმედო.",
        "რომ მთავარია გამოვიყენოთ ყველა ნასწავლი ხელსაწყო რომ ავაგოთ იგი.",
        "არ არსებობს 3 წესი და შეგვიძლია არ დავფიქრდეთ ასეთ საკითხებზე",
        "რომ იგი უნდა მოეწონოს ყველას, იყოს გაყიდვადი და მსუბუქი."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "რომ იგი უნდა იყოს Responsive, უნდა იყოს აზრობრივად გამართული და საიმედო.",
      "explanation": "კომპონენტები როგორებიცაა: აზრობრივი გამართულობა, ენების მხარდაჭერა, Responsive დიზაინი და სწორი წყობა კრიტიკულ როლს თამაშობს პროექტის კეთების დროს."
    },
    "48": {
      "question": "ჩამოთვლილთაგან, რომელი ვარიანტი წარმოქმნის შეცდომის რისკს?",
      "options": [
        "console.log(undefinedVar);",                   
        "const a = 5; let b = a;",     
        "function test(){ return a; } test();", 
        "const obj = {}; obj.key = 1;"                      
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "function test(){ return a; } test();",
      "explanation": "Function test(){ return a; } test(); გამოიწვევს ReferenceError-ს, რადგან a არსად არ არის განსაზღვრული."
    },
    "49": {
      "question": "გასაუბრებაზე ხარ და გეკითხებიან: როგორ ხდება dark & ligh თემებზე გადართვა React კომპონენტში Tailwind-ის გამოყენებით?:",
      "options": [
        "უნდა გამოვიყენოთ state-ის ცვლადი და class-ის სახელი(შაბლონური ლიტერალებით)",
        "ხელით უნდა გადავწეროთ CSS-ი, თითოეული თემისთვის",
        "უნდა შევქმნათ გამოყოფილი ფაილი ორივე(dark & light) თემისთვის.",
        "Tailwind კლასების გარეშე შეგვიძლია მხოლოდ გარე ბიბლიოთეკებზე დაყრდნობით მოვახდინოთ ეს."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "უნდა გამოვიყენოთ state-ის ცვლადი და class-ის სახელი(შაბლონური ლიტერალებით)",
      "explanation": "მიმდინარე თემის state-ში შენახვით და პირობითი Tailwind კლასების გამოყენებით (ან ბიბლიოთეკების გამოყენებით, როგორიცაა `clsx`), შეგვიძლია თემების ეფექტურად და დინამიურად გადართვა ერთ კომპონენტში."
    },
    "50": {
      "question": "რომელი სტრატეგია იძლევა მინიმალური, მაგრამ სრულად ფუნქციონალური HTML ფორმების ერთ ხაზზე დაწერის საშუალებას, ხელმისაწვდომობის შენარჩუნებით?",
      "options": [
        "სემანტიკური ელემენტების გამოყენება ჩასმული ატრიბუტებით.",
        "მხოლოდ div-ების და spans-ების გამოყენება.",
        "ყველა შეყვანის შეკუმშვით, `display:none`-ის გამოყენებით.",
        "iframe-ების გამოყენება თითოეული ველისთვის."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "სემანტიკური ელემენტების გამოყენება ჩასმული ატრიბუტებით.",
      "explanation": "თქვენ შეგიძლიათ შექმნათ კომპაქტური HTML ფორმები სემანტიკური ტეგების, როგორიცაა `<label>` და `<input>`, გამოყენებით შესაბამისი ჩასმული ატრიბუტებით, ფუნქციონალურობისა და ხელმისაწვდომობის შენარჩუნებით."
    },
    "51": {
      "question": "რა არის HTTP?",
      "options": [
        "იგივეა რაც პროგრამული ენა.",
        "ინტერნეტში მონაცემების გადაცემის პროტოკოლი.",
        "database სისტემა.",
        "ვებ ბრაუზერი."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ინტერნეტში მონაცემების გადაცემის პროტოკოლი.",
      "explanation": "HTTP (ჰიპერტექსტის გადაცემის პროტოკოლი) არის ვებ-სივრცეში მონაცემთა კომუნიკაციის საფუძველი, რომელიც გამოიყენება ვებ რესურსების მოთხოვნისა და გადაცემისთვის."
    },
    "52": {
      "question": "რისგან შედგება HTTP მოთხოვნა?",
      "options": [
        "მხოლოდ და მხოლოდ URL-ებისგან.",
        "მეთოდისგან, სათაურებისგან, ტექსტისგან (არასავალდებულო) და URL-ებისგან.",
        "მხოლოდ სათაურებისგან.",
        "მხოლოდ html ტანისგან."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მეთოდისგან, სათაურებისგან, ტექსტისგან (არასავალდებულო) და URL-ებისგან.",
      "explanation": "HTTP მოთხოვნები მოიცავს მეთოდს (GET, POST და ა.შ.), სათაურებს (მეტამონაცემებს), დამატებით ტექსტს (მონაცემებისთვის) და რესურსის URL-ს."
    },
    "53": {
      "question": "HTTP მოთხოვნის რა მეთოდები არსებობს?",
      "options": [
        "GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD",
        "ADD, REMOVE, UPDATE",
        "FETCH, SEND, RECEIVE",
        "CONNECT, LINK, UNLINK"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD",
      "explanation": "GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD არის ძირითადი HTTP მეთოდები, რომლებიც გამოიყენება ვებ კომუნიკაციაში რესურსების მოთხოვნის, შექმნის, განახლებისა და წაშლისთვის."
    },
    "54": {
      "question": "რა სემანტიკური განსხვავებაა PUT-სა და PATCH-ს შორის?",
      "options": [
        "PUT ცვლის მთელ რესურსს, PATCH აახლებს მხოლოდ ნაწილებს.",
        "PUT ნაწილებს აახლებს, PATCH ყველაფერს ცვლის.",
        "არანაირი სხვაობა არ არსებობს.",
        "PUT უფრო ნელია, ვიდრე PATCH."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "PUT ცვლის მთელ რესურსს, PATCH აახლებს მხოლოდ ნაწილებს.",
      "explanation": "PUT იდემპოტენტია და აგზავნის სრულ რესურსს; PATCH განკუთვნილია ნაწილობრივი განახლებისთვის.."
    },
    "55": {
      "question": "რა არის REST API?",
      "options": [
        "HTTP-ის გამოყენებით Back-end სერვისების დიზაინის ნიმუში.",
        "მონაცემთა ბაზის ტიპი.",
        "პროგრამირების ენა",
        "მისი განმარტება შეუძლებელია."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "HTTP-ის გამოყენებით Back-end სერვისების დიზაინის ნიმუში.",
      "explanation": "REST API-ები მიჰყვებიან ისეთ შეზღუდვებს, როგორიცაა უმდგომარეობა, კლიენტ-სერვერის გამოყოფა და ერთიანი ინტერფეისები იგი ხშირად გამოიყენება ვებ სერვისებისთვის."
    },
    "56": {
      "question": "რა არის Git?",
      "options": [
        "ტექსტების ედიტორი.",
        "ვერსიის კონტროლის სისტემა.",
        "პროგრამირების ენა.",
        "ვებ სერვერი."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ვერსიის კონტროლის სისტემა.",
      "explanation": "Git არის განაწილებული ვერსიის კონტროლის სისტემა, რომელიც პროგრამული უზრუნველყოფის შემუშავების დროს საწყისი კოდის ცვლილებების თვალყურის დევნებისთვისაა განკუთვნილი."
    },
    "57": {
      "question": "რა განსხვავებაა git შერწყმასა და git rebase-ს შორის?",
      "options": [
        "შერწყმა ქმნის commit-ს, რომელიც აერთიანებს ისტორიებს, rebase თანმიმდევრულად აწერს commit-ებს.",
        "შერწყმა შლის branche-ებს, ხოლო rebase აკოპირებს მათ.",
        "merge და rebase იდენტურები არიან.",
        "Rebase ქმნის ახალ branch-ს, merge-ი ამას ვერ აკეთებს."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "შერწყმა ქმნის commit-ს, რომელიც აერთიანებს ისტორიებს, rebase თანმიმდევრულად აწერს commit-ებს.",
      "explanation": "შერწყმა ინახავს ყველა ფილიალის ისტორიას და ქმნის შერწყმის კომიტს; rebase ხელახლა იყენებს კომიტებს სხვა ბაზაზე, რაც ქმნის წრფივ ისტორიას"
    },
    "58": {
      "question": "რა პრინციპებს ეფუძნება OOP?",
      "options": [
        "ინკაფსულაციას, მემკვიდრეობას, პოლიმორფიზმის, აბსტრაქციას",
        "ციკლებს, პირობებს, ფუნქციებს",
        "HTML-ს, CSS-ს და JS-ს",
        "REST-ს, HTTP-ს, API-ს"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ინკაფსულაციას, მემკვიდრეობას, პოლიმორფიზმის, აბსტრაქციას",
      "explanation": "ობიექტზე ორიენტირებული პროგრამირება სტრუქტურირებულია ამ ოთხი სვეტის გარშემო, რათა ორგანიზდეს კოდი და მოდელირდეს რეალური სამყაროს ერთეულები."
    },
    "59": {
      "question": "რისთვის არის package.json, Node.js-ის პროექტში?",
      "options": [
        "ინახავს HTML შაბლონებს",
        "მართავს პროექტის დამოკიდებულებებს, სკრიპტებს და მეტამონაცემებს.",
        "ჯავასკრიპტს გარდაქმნის CSS-ად.",
        "ინახავს Git commit-ებს"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მართავს პროექტის დამოკიდებულებებს, სკრიპტებს და მეტამონაცემებს.",
      "explanation": "package.json შეიცავს პროექტის ინფორმაციას, დამოკიდებულებებს, სკრიპტებს და სხვა კონფიგურაციებს, რომლებიც საჭიროა Node.js პროექტის გასაშვებად და შესანარჩუნებლად."
    },
    "60": {
      "question": "რა მონაცემთა ტიპები არსებობს ჯავასკრიპტში?",
      "options": [
        "String, Number, Boolean, Null, Undefined, Object, Symbol, BigInt",
        "String, Integer, Boolean, Object",
        "Number, Char, Boolean, Array",
        "Text, Number, Boolean, Function"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "String, Number, Boolean, Null, Undefined, Object, Symbol, BigInt",
      "explanation": "ჯავასკრიპტს აქვს 7 პრიმიტიული მონაცემთა ტიპი: String, Number, Boolean, Null, Undefined, Symbol და BigInt. ყველაფერი დანარჩენი (მაგალითად, მასივები, ფუნქციები და თარიღები) მიეკუთვნება ერთ არაპრიმიტიულ ტიპს: Object."
    },
    "61": {
      "question": "რა განსხვავებაა null-სა და undefined-ს შორის?",
      "options": [
        "null ანუ მნიშვნელობა არ არის მინიჭებული, undefined ანუ ცვლადი არსებობს, მაგრამ არაა შემოტანილი.",
        "ისინი ორივე იდენტურებია.",
        "undefined არის string-ი, null კი number ტიპის.",
        "null-ი გამოიყენება მხოლოდ Css სტილებში."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "null ანუ მნიშვნელობა არ არის მინიჭებული, undefined ანუ ცვლადი არსებობს, მაგრამ არაა შემოტანილი.",
      "explanation": "null არის მნიშვნელობის განზრახ არარსებობა; განუსაზღვრელი ხდება მაშინ, როდესაც ცვლადი გამოცხადებულია, მაგრამ არ არის მინიჭებული."
    },
    "62": {
      "question": "რა შედეგს მივიღებთ ამ კოდის გაშვებისას?: let funcs = []; for (var i = 0; i < 3; i++) { funcs.push(() => i); } console.log(funcs[0](), funcs[1](), funcs[2]());",
      "options": [
        "0, 1, 2",
        "3, 3, 3",
        "undefined, undefined, undefined",
        "Error: i is not defined"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "3, 3, 3",
      "explanation": "რადგან 'var' ფუნქციურად არის განსაზღვრული, ყველა ისრისებრი ფუნქცია იზიარებს ერთსა და იმავე 'i'-ს. მათი გაშვების დროისთვის ციკლი დასრულებულია და i = 3-ია, ამიტომ ყველა ფუნქცია აბრუნებს 3-ს."
    },
    "63": {
      "question": "შესაძლებელია თუ არა ისეთი JavaScript პროგრამის დაწერა, რომელიც გაანადგურებს ჩვენს მოწყობილობას?",
      "options": [
        "დიახ, უსასრულო ციკლით მას შეუძლია თქვენი აპარატურის დაწვა.",
        "არა, რადგან ჯავასკრიპტი მუშაობს sandbox-ში და ვერ აზიანებს აპარატურას.",
        "შესაძლოა, თუ ძალიან ბევრ setTimeout ფუნქციას გამოვიყენებთ.",
        "ეს ოპერაციულ სისტემაზეა დამოკიდებული."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "არა, რადგან ჯავასკრიპტი მუშაობს sandbox-ში და ვერ აზიანებს აპარატურას.",
      "explanation": "ჯავასკრიპტი sandbox-შია, ანუ მას შეუძლია ბრაუზერის გაყინვა ან მეხსიერების შეჭმა, მაგრამ ფიზიკურად მას არ შეუძლია კომპიუტერის დაზიანება. უარეს შემთხვევაში, უსასრულო ციკლმა ან მეხსიერების დიდმა გამოყენებამ შეიძლება კომპიუტერი გათიშოს, მაგრამ იგი ამით ვერ დააზიანებს აპარატურას."
    },
    "64": {
      "question": "სანამ რეაქტში მუშაობას ვიწყებთ, ტერმინალში ვწერთ: `cd my-app`. რას წარმოადგენს `cd`?",
      "options": [
        "cd - შექმენი მიმართულება, იგი ქმნის ახალ ფაილს.",
        "cd - შეცვალე მიმართულება, მას გადავყავართ სასურველ ფაილზე.",
        "cd - დახურე მიმართულება, ხდება პროცესების დასრულება.",
        "cd - დოკუმენტის გაწმენდა, ის ასუფთავებს დოკუმენტის ისტორიას."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "cd - შეცვალე მიმართულება, მას გადავყავართ სასურველ ფაილზე.",
      "explanation": "`cd` = change directory. ის ცვლის shell-ის სამუშაო გზას, რათა `npm run dev`-ის მსგავსმა ბრძანებებმა იცოდნენ, რომელ პროექტში (საქაღალდეში) უნდა შეასრულონ."
    },
    "65": {
      "question": "რა არის დაპირება(Promise), ჯავასკრიპტში?",
      "options": [
        "ობიექტი, რომელიც წარმოადგენს ასინქრონული ოპერაციის მომავალ მნიშვნელობას.",
        "ფუნქცია, რომელიც ყოველთვის აბრუნებს ჭეშმარიტ პასუხს.",
        "პირობა აბრუნებს ახალ ფაილს, რომელშიც დაწერილი ტექსტი JSON ფორმატისაა.",
        "იგი არის ჯავასკრიპტის საიდუმლო ხელსაწყო."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ობიექტი, რომელიც წარმოადგენს ასინქრონული ოპერაციის მომავალ მნიშვნელობას.",
      "explanation": "დაპირება არის ობიექტი, რომელიც ხელმისაწვდომი იქნება მომავალში. იგი ან გადაწყდება ან იქნება უარყოფილი, შედეგის მიხედვით ჩვენ დავამუშავებთ მას, იმ შემთხვევაში თუ გადაწყდა მოხდა ვიყენებთ `.then()`, შეცდომებისთვის ვიყენებთ `.catch()`-ს."
    },
    "66": {
      "question": "კონკრეტულად რას ელის კლიენტი დაქირავებული დეველოპერისგან?",
      "options": [
        "კოდის სისუფთავეს(სისწორეს).",
        "რომ დეველოპერი შეუძლებელს შეძლებს.",
        "კლიენტი ელის მხოლოდ სასურველ შედეგს.",
        "კლიენტი ელის სწრაფად შესრულებულ საქმეს."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "კლიენტი ელის მხოლოდ სასურველ შედეგს",
      "explanation": "მარტივად რომ ავხსნათ, კლიენტ დეველოპერის სიტუაცია წააგავს, მომხმარებლისა და ხელოვნური ინტელექტის მიმოწერას, მიუხედავად იმისა თუ რამდენად ბევს იწვალებს ხელოვნური ინტელექტი, რაც არავის არ ადარდებს, საბოლოოდ ხდება შედეგის შეფასება და არა შრომის."
    },
    "67": {
      "question": "რას ნიშნავს Hero Section-ი ვებ პროგრამირებაში?",
      "options": [
        "Hero Section არის მასივის ერთ ერთი ბიბლიოთეკა.",
        "Hero Section არ არსებობს ვებ პროგრამირებაში.",
        "Hero Section იგივეა რაც Footer-ი, მეორენაირად.",
        "Hero Section ანუ პირველი სექცია მთავარ გვერდზე."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "Hero Section ანუ პირველი სექცია მთავარ გვერდზე.",
      "explanation": "იგი აღწერს პირველ გვერდს პირველ სექციას ჩვენს ვებ პროექტში."
    },
    "68": {
      "question": "JavaScript-ში რა არის არასავალდებულო ჯაჭვური კავშირის ოპერატორი (`?`)?",
      "options": [
        "უსაფრთხოდ წვდება ჩადგმული ობიექტის თვისებებს შეცდომების გარეშე, თუ ის განუსაზღვრელი/ნულოვანია.",
        "ასრულებს არითმეტიკულ ოპერაციებს.",
        "ფუნქციის პირობითად გამოძახება.",
        "ქმნის ციკლს."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "უსაფრთხოდ წვდება ჩადგმული ობიექტის თვისებებს შეცდომების გარეშე, თუ ის განუსაზღვრელი/ნულოვანია.",
      "explanation": "არჩევითი ჯაჭვური დაყოფა ხელს უშლის გაშვების დროს შეცდომებს განუსაზღვრელი ღირებულების დაბრუნებით, თუ წვდომადი თვისება არ არსებობს."
    },
    "69": {
      "question": "რა არის Shadow DOM-ი?",
      "options": [
        "ცალკეული DOM-ის ხე, რომელიც ჩასმული ვებ კომპონენტში.",
        "ის არის დამალული CSS კლასი.",
        "DOM-ის საპირისპირო მექანიზმი.",
        "JavaScript ობიექტის ტიპი."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ცალკეული DOM-ის ხე, რომელიც ჩასმული ვებ კომპონენტში.",
      "explanation": "Shadow DOM საშუალებას აძლევს ვებ კომპონენტებს მოიცვან HTML, CSS და JS, რაც ხელს უშლის სტილისა და სკრიპტის კონფლიქტებს."
    },
    "70": {
      "question": "შესაძლებელია თუ არა რომ ჯავასკრიპტის გამოყენებით დაიწეროს ახალი პროგრამის ენა?",
      "options": [
        "დიახ, JavaScript-ში ტრანსპილერის ან ინტერპრეტატორის ჩაწერით.",
        "არა, JavaScript-ის ამ გზით გამოყენება შეუძლებელია.",
        "მხოლოდ C++-ის დამატების შემთხვევაში.",
        "ეს შესაძლებელია, მაგრამ მხოლოდ სტილისტური ენებისთვის, როგორიცაა CSS."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "დიახ, JavaScript-ში ტრანსპილერის ან ინტერპრეტატორის ჩაწერით.",
      "explanation": "ისეთი ენები, როგორიცაა TypeScript, CoffeeScript და Babel, დანერგილია JavaScript-ში — ისინი სტანდარტულ JavaScript-ად გარდაქმნიან მორგებულ სინტაქსს."
    },
    "71": {
      "question": "როგორ ხდება კლასის მემკვიდრეობითობა ES6-ში?",
      "options": [
        "`extends` საკვანძო სიტყვისა და `super()` გამოძახების გამოყენება.",
        "ყველა მეთოდის ხელით კოპირებით",
        "`პროტოტიპის` მხოლოდ ხელით გამოყენება",
        "`Object.assign`-ის გამოყენებით"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "`extends` საკვანძო სიტყვისა და `super()` გამოძახების გამოყენება.",
      "explanation": "ES6 კლასებს შეუძლიათ სხვა კლასების მემკვიდრეობით მიღება `class Child extends Parent`-ის გამოყენებით და კონსტრუქტორში `super()`-ის გამოძახებით."
    },
    "72": {
      "question": "რა განსხვავებაა sessionStorage-სა და localStorage-ს შორის?",
      "options": [
        "sessionStorage მოქმედებს ბრაუზერის დახურვამდე, localStorage კი სესიების განმავლობაში.",
        "მათ შორის არანაირი სხვაობა არაა.",
        "sessionStorage ინახავს ფაილებს, localStorage ინახავს ტექტსებს.",
        "sessionStorage გაცილებით სწრაფია localStorage-ზე"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "sessionStorage მოქმედებს ბრაუზერის დახურვამდე, localStorage კი სესიების განმავლობაში.",
      "explanation": "sessionStorage ინახავს დროებით მონაცემებს ერთი სესიისთვის, ხოლო localStorage-ი რჩება ბრაუზერის დახურვის შემდეგაც."
    },
    "73": {
      "question": "ძირითადად სად გამოიყენება Class/Super მეთოდები, რეალურ პროექტებში?",
      "options": [
        "ისინი ძირითადად გამოიყენება CSS-ში, წინასწარი დამუშავებისას.",
        "მას არ ვიყენებთ რეალურ პროექტებში, მხოლოდ გავდივართ ზედაპირულად.",
        "მრავალჯერადი გამოყენების UI კომპონენტების შექმნისთვის და საბაზისო კლასების გაფართოებაში.",
        "ისინი გამოიყენება მხოლოდ მონაცემთა ბაზებთან მუშაობისას."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მრავალჯერადი გამოყენების UI კომპონენტების შექმნისთვის და საბაზისო კლასების გაფართოებაში.",
      "explanation": "წარმოიდგინეთ შემთხვევა, როდესაც არ გსურთ ერთი და იგივე ლოგიკის ყველგან გამეორება. მაგალითად როდესაც ვმუშაობთ რეაქტში და ვქმნით კომპონენტს რომელიც მუშაობს ენის თარგმნებზე i18n-თან ერთად და გვიწევს ამ ფაილის ბევრგან დაკოპირება(სხვა ფაილებში), ან გვყავს მშობელი კლასი რომელიც ინახავს localStorage-ში მონაცემებს, ამ მონაცემების მისაღებად შვილ კლასებში თავიდან უნდა დავწეროთ იგივე კოდი(მაგრამ არგვინდა ყველაფრის თავიდან გადაწერა). სწორედ აქ ბრწყინავს მემკვიდრეობა და super() მეთოდები — ისინი საშუალებას გვაძლევენ გავუზიაროთ მშობლის ლოგიკა შვილებს ზედმეტი კოპირებების გარეშე."
    },
    "74": {
      "question": "Tailwind CSS-ში, როგორ იქმნება გრადიენტური ფონი, რომელიც შეურევს ორ ფერს ერთმანეთს?",
      "options": [
        "bg-gradient-to-{მიმართულება}-ის გამოყენება from-{color}-თან და to-{color}-სთან ერთად.",
        "იგი იქმნება CSS-ში უბრალოდ linear-gradient-ს მივუთითებთ სტილის სახელად.",
        "უნდა გამოვიყენოთ bg-color-1 + bg-color-2 კლასები.",
        "გამოვიყენოთ მხოლოდ bg-gradient."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "bg-gradient-to-{მიმართულება}-ის გამოყენება from-{color}-თან და to-{color}-სთან ერთად.",
      "explanation": "Tailwind-ი ნებართვას აძლევს gradient-ების შემოტანას ანუ ფერთა მიქსს შემდეგნაირად: `მიმართულება: bg-gradient-to-r` შემდეგ პირველი ფერი: `from-blue-500` და მეორე ფერი: `to-green-500`, ასე შეიქმნება ორი ფერის მიქსი."
    },
    "75": {
      "question": "რეაქტში, რას წარმოადგენს custom hook-ი?",
      "options": [
        "ფუნქცია, რომელიც იწყება „გამოყენებით“, რომელიც მოიცავს მრავალჯერადი გამოყენების მდგომარეობის ლოგიკას.",
        "იგია icon-ების ბიბლიოთეკა.",
        "იგია ჩაშენებული ჰუკი, useState-ის მსგავსი.",
        "იგია CSS-ის კაუჭი, რომელიც გვეხმარება უკეთესი სტილის შერჩევაში."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ფუნქცია, რომელიც იწყება „გამოყენებით“, რომელიც მოიცავს მრავალჯერადი გამოყენების მდგომარეობის ლოგიკას.",
      "explanation": "Custom ჰუკები ლოგიკის გამეორების თავიდან აცილებაში გვეხმარება, მაგალითად, Custom ჰუკის გამოყენებით შეგვიძლია შევქმნათ `useLocalStorage`, მომხმარებლის ქულების სხვადასხვა კომპონენტში შესანახად და ჩასატვირთად, ერთი და იგივე useEffect კოდის გამეორების გარეშე."
    },
    "76": {
      "question": "როგორ შეგვიძლია React icon-ების შემოტანა?",
      "options": [
        "რეაქტს არ შეუძლია Icon-ების გამოყენება.",
        "ჩვენ უნდა შევქმნათ იგი Css-ის გამოყენებით.",
        "უნდა გამოვიყენოთ HTML-ის <img> ტეგი.",
        "შეგვიძლია პირდაპირი იმპორტირება ან დინამიური, React.lazy-ის გამოყენებით."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "შეგვიძლია პირდაპირი იმპორტირება ან დინამიური, React.lazy-ის გამოყენებით.",
      "explanation": "React ხატულების იმპორტი შესაძლებელია სტატიკურად ან დინამიურად `React.lazy`-სა და `Suspense`-ის გამოყენებით, პაკეტის ზომის ოპტიმიზაციისთვის."
    },
    "77": {
      "question": "ჯავასკრიპტში, შეგვიძლია თუ არა რომ შევქმნათ HTML ელემენტი, რომელიც გასტილული იქნება CSS-ით.",
      "options": [
        "დიახ, მაგრამ თუ დავაინსტალირებთ დამატებით ბიბლიოთეკას.",
        "არა, ჯავასკრიპტს არ შეუძლია მსგავსი რამე.",
        "ეს დამოკიდებულია typeScript-ზე.",
        "დიახ, ჯავასკრიპტში ეს შესაძლებელია."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "დიახ, ჯავასკრიპტში ეს შესაძლებელია.",
      "explanation": "JavaScript-ს შეუძლია ელემენტების მომენტალურად შექმნა და სტილიზაცია. მაგალითად: `const box = document.createElement('div'); box.style.background = 'red'; document.body.appendChild(box);` ქმნის წითელ უჯრას HTML ან CSS ფაილებთან შეხების გარეშე."
    },
    "78": {
      "question": "HTML/CSS-ში რა განსხვავებაა Inline, Block და Inline-block-ურ ელემენტებს შორის?",
      "options": [
        "Inline-block მუშაობს X/Y ღერძზე, Inline X-ღერძზე, Block Y-ღერძზე.",
        "ყველა ერთნაირად მუშაობს.",
        "Inline-block კარგად ერგება სიგანესა და სიმაღლეს, რასაც დანარჩენი ორი ტიპი ვერ შვება.",
        "მხოლოდ block-ურ ელემენტებს შეუძლიათ padding-ის გამოყენება."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "Inline-block კარგად ერგება სიგანესა და სიმაღლეს, რასაც დანარჩენი ორი ტიპი ვერ შვება.",
      "explanation": "CSS-ის display-ს ტიპები აკონტროლებენ გამოტანის ტიპებს: inline-ი მიყვება ტექსტურ ნაკადს, block-ი წყვეტს ხაზებს და inline-block აერთიანებს ხაზოვან ნაკადს box sizing-თან."
    },
    "79": {
      "question": "ჯავასკრიპტში, რას მივიღებთ ამის შედეგად: `console.log([] + {})`?",
      "options": [
        "'0'",
        "'[object Object]'",
        "'[]{}'",
        "გვესვრის error-ს"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "'[object Object]'",
      "explanation": "როდესაც ვახდენთ მასივისა და ობიექტის შეკრებას, JS ახდენს მათ სტრინგ ტიპზე გადაყვანას: [] ხდება - '', {} ხდება - '[object Object]', ამიტომ შედეგად ვიღებთ: '[object Object]'."
    },
    "80": {
      "question": "ჯავასკრიპტში, რას მივიღებთ ამის შედეგად: `console.log([] * 2)`?",
      "options": [
        "NaN",
        "Throws an error",
        "0",
        "[]"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "0",
      "explanation": "JS რიცხვითი ოპერაციებისთვის []-ს 0-ზე აკონვერტირებს ანუ შედეგად: 0 * 2 = 0."
    },
    "81": {
      "question": "როგორ ხდება i18n-ის (ინტერნაციონალიზაციის) დანერგვა, React-ის პროექტში?",
      "options": [
        "რეაქტს არ შეუძლია i18n-ის გამოყენება.",
        "ბევრი if მდგომარეობის დაწერით.",
        "react-i18next ბიბლიოთეკისა და JSON მთარგმნელი ფაილების გამოყენებით.",
        "იგი იწერება მხოლოდ CSS-ში, და შემდეგ გამოიყენება."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "react-i18next ბიბლიოთეკისა და JSON მთარგმნელი ფაილების გამოყენებით.",
      "explanation": "react-i18next საშუალებას იძლევა ვმართოთ ენების შეცვლა, თარგმანის გასაღებები და დინამიური კონტენტი რეაქტის აპლიკაციებში."
    },
    "82": {
      "question": "CSS-ში, რას აკეთებს `clip-path` თვისება?",
      "options": [
        "განსაზღვრავს ელემენტის ხილულ ნაწილს ფორმების გამოყენებით.",
        "ცვლის ელემენტის გამჭვირვალობას.",
        "ამატებს ჩრდილის ეფექტებს.",
        "ცვლის ელემენტის გამოტანის ტიპს."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "განსაზღვრავს ელემენტის ხილულ ნაწილს ფორმების გამოყენებით.",
      "explanation": "`clip-path` საშუალებას იძლევა შეიქმნას რთული ფორმები ელემენტის ხილული ნაწილის განსაზღვრით და დანარჩენის დამალვით."
    },
    "83": {
      "question": "როგორ ავიცილოთ თავიდან React კომპონენტის არასაჭირო რენდერინგი?",
      "options": [
        "React.render, useFunction, და useState-ის გამოყენებით.",
        "ყოველთვის გამოვიძახოთ setState-ი",
        "React.memo, useCallback, და useMemo-ს გამოყენებით.",
        "გამოვიყენოთ მხოლოდ class კომპონენტები."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "React.memo, useCallback, და useMemo-ს გამოყენებით.",
      "explanation": "ეს ოპტიმიზაცია ხელს უწყობს ზედმეტი რენდერების თავიდან აცილებას კომპონენტების, ფუნქციების და გამოთვლილი მნიშვნელობების დამახსოვრების გზით."
    },
    "84": {
      "question": "როგორ შეგიძლიათ შექმნათ სრულად ფუნქციონალური კოდის ბლოკი ერთ ხაზზე JS-ში ინტერვიუს ხრიკისთვის?",
      "options": [
        "რამდენიმე ხაზის ერთში კოპირებით.",
        "ეს შეუძლებელია.",
        "მხოლოდ loop-ების გამოყენებით.",
        "ისრის ფუნქციების გამოყენება Ternary ოპერატორებით და დაუყოვნებლივ გამოძახებული გამოსახულებებით."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ისრის ფუნქციების გამოყენება Ternary ოპერატორებით და დაუყოვნებლივ გამოძახებული გამოსახულებებით.",
      "explanation": "ერთ ხაზზე მრავალსაფეხურიანი ოპერაციების შესასრულებლად, ლოგიკის შეკუმშვა შესაძლებელია IIFE `( () => { ... })()` და სამეტაპიანი გამოსახულებების გამოყენებით."
    },
    "85": {
      "question": "რა განსხვავებაა sticky-სა და fixed პოზიციებს შორის, Css-ში?",
      "options": [
        "ორივე ერთნაირად მუშაობს.",
        "Sticky მუშაობს მხოლოდ flexbox-თან",
        "Sticky მიდის ნებადართულ წერტილამდე, fixed რჩება ეკრანზე.",
        "Sticky ყოველთვის ზემოთაა, fixed ხანდახანაა ზემოთ."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "Sticky მიდის ნებადართულ წერტილამდე, fixed რჩება ეკრანზე.",
      "explanation": "Sticky პოზიცია იქცევა როგორც relative- სანამ იგი არ მიაღწევს ნებადართულ ზღვარს, შემდეგ კი ეწეპება იმ წერტილს და აღარ მოდის სქროლზე. Fixed პოზიცია ყოველთვის დაგვყვება ხედვის არეალში(არაქვს მნიშვნელობა როგორ სქროლავ)."
    },
    "86": {
      "question": "რა განსხვავებაა absolute-სა და fixed პოზიციებს შორის, Css-ში?",
      "options": [
        "Fixed მხოლოდ flexbox-თან მუშაობს.",
        "Absolute ყოველთვის ცენტრშია, fixed კი არაა",
        "ისენი იდენტურად მუშაობენ.",
        "Absolute ყოველთვის ნთავსდება ახლო მშობელთან, fixed კი ხედვის არეალთან."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "Absolute ყოველთვის ნთავსდება ახლო მშობელთან, fixed კი ხედვის არეალთან.",
      "explanation": "Absolute მითითებას უახლოესი წინაპრისგან იღებს, რომელსაც აქვს პოზიცია (Relative, Absolute, Sticky, Fixed). Fixed უგულებელყოფს მშობლებს და პირდაპირ ემაგრება ხედვის არეალს."
    },
    "87": {
      "question": "JavaScript-ში რა განსხვავებაა გამოძახებას, გამოყენებას და დაკავშირებას შორის?",
      "options": [
        "გამოძახება იწვევს ფუნქციას არგუმენტებით, გამოყენება მასივით, bind აბრუნებს ახალ ფუნქციას.",
        "სამივე იდენტურია",
        "გამოძახება ცვლის DOM-ს, გამოყენება ცვლის CSS-ს, bind ცვლის JS-ს",
        "bind მყისიერად სრულდება."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "გამოძახება იწვევს ფუნქციას არგუმენტებით, გამოყენება მასივით, bind აბრუნებს ახალ ფუნქციას.",
      "explanation": "ეს მეთოდები ფუნქციის გამოძახებისას აკონტროლებენ `This` კონტექსტს არგუმენტის გადაცემის სხვადასხვა მიდგომით."
    },
    "88": {
      "question": "React-ის Icon-ების იმპორტირების შემდეგ, როგორ უნდა მოვახდინოთ მისი ეკრანზე ასახვა?",
      "options": [
        "უნდა ჩავწეროთ Css-ში: .Icon{...}",
        "უნდა ჩავწეროთ ჯავასკრიპტში: {Icon}",
        "უნდა ჩავწეროთ ტეგში: <FaIcon />",
        "რეაქტი მხარს არ უჭერს მსგავს მეთოდებს."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "უნდა ჩავწეროთ ტეგში: <FaIcon />",
      "explanation": "სასურველი Icon-ის არჩევისა და JSX-ფაილში მისი იმპორტირების შემდეგ, ჩვენ Icon-ს ვათავსებთ ტეგში, გამოსატანად."
    },
    "89": {
      "question": "CSS-ში, რა განსხვავებაა ფარდობით ერთეულებს (%, rem) შორის?",
      "options": [
        "% აბსოლუტურია, rem მშობელ ელემენტთან ფარდობითდება.",
        "% და rem ორივე ერთნაირად იქცევიან, მასშტაბირდებიან მშობელი შრიფტის ზომით.",
        "% ფარდობითია მშობელი ელემენტის ზომასთან, rem ფარდობითია root (html) შრიფტის ზომასთან.",
        "% ფარდობითია ხედვის ფანჯრის სიგანესთან, rem კი ფარდობითია მშობელი შრიფტის ზომასთან."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "% ფარდობითია მშობელი ელემენტის ზომასთან, rem ფარდობითია root (html) შრიფტის ზომასთან.",
      "explanation": "% დამოკიდებულია მშობელი ელემენტის ზომაზე (მაგ., სიგანე: 50% ნიშნავს მშობელი ელემენტის სიგანის ნახევარს). მეორეს მხრივ, rem ყოველთვის იყენებს ძირეული ელემენტის შრიფტის ზომას (ბრაუზერებში ჩვეულებრივ 16 პიქსელია ნაგულისხმევად). ეს rem-ს მთელ დოკუმენტში უფრო პროგნოზირებადს ხდის."
    },
    "90": {
      "question": "CSS-ში, რა განსხვავებაა ფარდობით ერთეულებს (px, em) შორის?",
      "options": [
        "px არის ფიქსირებული აბსოლუტური ერთეული, em კი ფარდობითია მშობელი ელემენტის შრიფტის ზომასთან.",
        "px ფარდობითია ფესვეულ ელემენტებთან, em ფარდობითია viewport-ისთვის",
        "ორივე ფარდობითადაა მშობელის ფონტის ზომასთან.",
        "px არის %-ის მსგავსი გამოყენებისას, ხოლო em ფიქსირებული ერთეულია."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "px არის ფიქსირებული აბსოლუტური ერთეული, em ფარდობითია მშობელი ელემენტის შრიფტის ზომასთან.",
      "explanation": "px არის ფიქსირებული ზომა (1px ნიშნავს მოწყობილობის 1 პიქსელს, თუმცა მასშტაბირებულია მაღალი DPI ეკრანებზე). em ფარდობითია ელემენტის მშობლის შრიფტის ზომასთან. მაგალითად, თუ მშობელს აქვს შრიფტის ზომა: 20px, მაშინ 1em = 20px შვილობილი ელემენტისთვის. ეს em-ს სასარგებლოს ხდის, მაგრამ ასევე რთულს, თუ რამდენიმე ჩადგმული ელემენტი ერთმანეთს მასშტაბირდება."
    },
    "91": {
      "question": "როგორ შეიძლება HTML-ში სურათების ზარმაცად ჩატვირთვა?",
      "options": [
        "ტაილვინდის მეთოდების გამოყენებით.",
        "ჯავასკრიპტის ბიბლიოთეკის დახმარებით.",
        "`loading=\"lazy\"` ატრიბუტის გამოყენებით.",
        "Lazy-loading-ი არაა შესაძლებელი."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "`loading=\"lazy\"` ატრიბუტის გამოყენებით.",
      "explanation": "HTML5-ს შეუძლია გამოიყენოს `loading=\"lazy\" ატრიბუტს, რომელიც სურათების ჩატვირთვის გადადებას ახდენს მანამ, სანამ ისინი ხედვის არეალთან ახლოს არ მივლენ, რაც აუმჯობესებს მუშაობის გამართულობას სურათებთან.."
    },
    "92": {
      "question": "რა განსხვავებაა CSS Grid-სა და Flexbox-ს შორის?",
      "options": [
        "Flexbox-ს შეუძლია 2D განლაგების გაკეთება, Grid-ს არა.",
        "ისინი იდენტურები არიან.",
        "Grid არის 2D (რიგები + სვეტები), Flexbox არის 1D (რიგები ან სვეტი).",
        "Grid-ი უფრო ნელა მუშაობს ვიდრე Flexbox-ი"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "Grid არის 2D (რიგები + სვეტები), Flexbox არის 1D (რიგები ან სვეტი).",
      "explanation": "CSS Grid განკუთვნილია რთული ორგანზომილებიანი განლაგებებისთვის, Flexbox კი ამუშავებს ერთგანზომილებიან განლაგებას და მდგომარეობას."
    },
    "93": {
      "question": "flex-direction (row/col), justify-content, და align-items-ის გარდა კიდევ რა შეუძლია გააკეთოს Flexbox-მა?",
      "options": [
        "მას შეუძლია ნივთების შეფუთვა, მათი ზრდა/შეკუმშვის კონტროლი და სივრცის შექმნა gap-მეთოდის გამოყენებით.",
        "მას შეუძლია შექმნას რთული ბადეები დასახელებული ტერიტორიებით",
        "მას შეუძლია გამოიყენოს Grid მეთოდი, როგორც შვილი ელემენტი.",
        "მას შეუძლია შექმნას უნიკალური ანიმაციები ჩაშენებული ბიბლიოთეკებით."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მას შეუძლია ნივთების შეფუთვა, მათი ზრდა/შეკუმშვის კონტროლი და სივრცის შექმნა gap-მეთოდის გამოყენებით.",
      "explanation": "Flexbox-ს შეუძლია როგორც რიგების/სვეტების გასწორება, ასევე ელემენტების ახალ ხაზზე გადატანა, შეუძლია ელემენტების გაზდა დაპატარავება(flex-grow, flex-shrink, flex-basis) და gap თვისების გამოყენებით აშორებს ელემენტებს."
    },
    "94": {
      "question": "რა მოწინავე განლაგების მიღწევა შეუძლია CSS Grid-ს მწკრივებისა და სვეტების განსაზღვრის გარდა?",
      "options": [
        "მას არაფრის გაკეთება არ შეუძლია, გარდა რიგების/სვეტების განსაზღვრისა.",
        "მას შეუძლია შექმნას დამატებითი Z ხაზი, რიგში/სვეტში.",
        "ადგილები grid-ის სახელებით, ელემენტი რამდენიმე უჯრით და ზუსტი კონტროლი ხაზის ნომრებით.",
        "ის მხოლოდ 2x2 განლაგებებისთვის მუშაობს."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ადგილები grid-ის სახელებით, ელემენტი რამდენიმე უჯრით და ზუსტი კონტროლი ხაზის ნომრებით.",
      "explanation": "CSS Grid საშუალებას გვაძლევს განვსაზღვროთ არა მხოლოდ რიგების და სვეტები რაოდენობა. მისი გამოყენებით შესაძლებელია კონკრეტულ ადგილებს მივცეთ სახელები(მაგალითად 'header' ან 'sidebar'), ასევე შეგვიძლია გავწელოთ ერთი მონაცემი მთლიანს სიგრძეზე ან სიგანეზე და შეგვიძლია ასევე გამოვიყენოთ დანომრილი ხაზები ნივთების ზუსტად სასურველ ადგილას განსათავსებლად."
    },
    "95": {
      "question": "CSS-ში როგორ ვახდენთ გლობალური სტილების დაყენებას?",
      "options": [
        "შეუძლებელია გლობალური სტილების დაყენება.",
        "ეს შესაძლებელია :root ის გამოყენებით.",
        "უნივერსალური აღმნიშვნელის გამოყენებით: +.",
        "უნივერსალური აღმნიშვნელის გამოყენებით: *."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "უნივერსალური აღმნიშვნელის გამოყენებით: *.",
      "explanation": "The universal selector (*) applies styles to every element. It’s often used for resets (e.g., setting margin: 0, padding: 0) or to give a global base style across the whole document."
    },
    "96": {
      "question": "რა განსხვავებაა visibility:hidden-სა და display:none-ს შორის CSS-ში?",
      "options": [
        "ორივე მათგანი ტოვებს ტექსტს ხილვადს.",
        "ორივე მათგანი შლის ელემენტს სრულიად.",
        "visibility:hidden იმალება მაგრამ ტოვებს სივრცეს, display:none მთლიანად შლის ელემენტს.",
        "მხოლოდ display:none მუშაობს flexbox-თან."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "visibility:hidden იმალება მაგრამ ტოვებს სივრცეს, display:none მთლიანად შლის ელემენტს.",
      "explanation": "`visibility:hidden` keeps the element in the layout but makes it invisible; `display:none` removes it completely."
    },
    "97": {
      "question": "როგორ გავუმკლავდეთ JavaScript-ში async/await ფუნქციებში არსებულ შეცდომებს?",
      "options": [
        "შეცდომები ავტომატურად იგნორირდება.",
        "Then/catch ის გამოყენებით",
        "Do while loop-ის გამოყენებით.",
        "Try...catch ბლოკის გამოყენებით."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "Try...catch ბლოკის გამოყენებით.",
      "explanation": "Async/await ფუნქციებმა შესაძლოა გამოიწვიონ შეცდომები, მათი try/catch ბლოკში მოთავსება საშუალებას მოგვცემს თავი გავართვათ შეცდომებს."
    },
    "98": {
      "question": "რა ხდება მაშინ როდესაც ჩვენ ვშლით მასივის ელემენტს, ჯავასკრიპტში?",
      "options": [
        "ის ანახლებს მასივს ცარიელად.",
        "ის შლის ელემენტს და გადაადგილებს მასივს",
        "ის შლის მნიშვნელობას, მაგრამ ტოვებს ცარიელ ხვრელს.",
        "ჩვენ ვიღებთ შეცდომას."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ის შლის მნიშვნელობას, მაგრამ ტოვებს ცარიელ ხვრელს.",
      "explanation": "arr[index]-ის წაშლა ქმნის ცარიელ ხვრელს (განუსაზღვრელი მნიშვნელობით), მაგრამ მასივის სიგრძე არ იცვლება, ამიტომ უნდა გამოვიყენოთ splice() მეთოდი რომ სრულიად წავშალოთ და გადავაადგილოთ ელემენტი."
    },
    "99": {
      "question": "რა განსხვავებაა GET-სა და POST მოთხოვნებს შორის?",
      "options": [
        "GET იღებს მონაცემებს, POST აგზავნის მონაცემებს.",
        "GET ცვლის მონაცემებს, POST იღებს მონაცემებს",
        "GET და POST ორივე იდენტურია.",
        "GET აგზავნის მონაცემებს, POST იღებს მონაცემებს"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "GET იღებს მონაცემებს, POST აგზავნის მონაცემებს.",
      "explanation": "GET მოთხოვნა იღებს მონაცემებს შეკითხვის პარამეტრებით, POST აგზავნის მონაცემებს მოთხოვნის ტექსტში და შეუძლია შეცვალოს სერვერის მდგომარეობა."
    },
    "100": {
      "question": "რატომ არ უნდა შევადაროთ ობიექტები `==` ან `===`-ს JavaScript-ში?",
      "options": [
        "რადგან ობიექტები მიმთითებელი ტიპებია, შეიძლება მხოლოდ მისამართების შედარება.",
        "რადგან ობიექტების შედარება არ შეიძლება.",
        "რადგან == არამკაცრი ტოლობა მხოლოდ string ტიპისთვისაა.",
        "რადგან === მკაცრი ტოლობა მხოლოდ number ტიპისთვისაა."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "რადგან ობიექტები მიმთითებელი ტიპებია, მხოლოდ მეხსიერების მისამართების შედარება შეიძლება.",
      "explanation": "ობიექტები იდენტური მონაცემებითაც კი სხვადასხვა შედეგს იძლევიან, ამიტომ ობიექტებში თანასწორძალოვანი ტოლობაც კი მცდარს(false) აბრუნებს შედეგად."
    },
    "101": {
      "question": "რატომ ვიყენებთ რეაქტში ორმაგ ხვეულ ფრჩხილებს `{{}}` (მაგალითად, `style={{}}`)?",
      "options": [
        "რადგან ერთი წყვილი JSX გამოხატვისთვისაა, ხოლო მეორე ობიექტისთვის.",
        "რადგან React-ს ორი დონის მასშტაბირება სჭირდება",
        "რადგან ეს JSON-ის მხარდამჭერი ფრჩხილებია.",
        "რადგან სტილები მხოლოდ ორ ფრჩხილთან მუშაობს."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "რადგან ერთი წყვილი JSX გამოხატვისთვისაა, ხოლო მეორე ობიექტისთვის.",
      "explanation": "რეაქტში, `{}`-ფრჩხილებს JSX-ი ჯავასკრიპტის რეჟიმზე გადაჰყავს, რაც ნიშნავს რომ მასში შეიძლება ჯავასკრიპტ ლოგიკის გატარება, ანუ `{{}}` ნიშნავს JSX გამოსახულებაში შეფუთულ ობიექტს."
    },
    "102": {
      "question": "რა განსხვავებაა `<iframe>`-სა და `<video>`-ს შორის HTML-ში?",
      "options": [
        "ორივე გამოიყენება ვიდეოების გამოსატანად.",
        "<iframe> მხოლოდ სურათებისთვისაა, <video> კი ვიდეოებს ამუშავებს.",
        "<iframe> მუშაობს გარე ვიდეო ფაილებთან, <video> ამუშავებს ლოკალური ფაილის ვიდეოებს.",
        "<iframe>-ს შეუძლია ავტომატური დაკვრა, <video>-ს ეს არ შეუძლია."
      ],
      "level": "<easy>მარტივი</easy>",
      "correct": "<iframe> მუშაობს გარე ვიდეო ფაილებთან, <video> ამუშავებს ლოკალური ფაილის ვიდეოებს.",
      "explanation": "`<iframe>`-ში იტვირთება სხვა ვებგვერდი ან გარე კონტენტი(გლობალური ტეგი), ხოლო `<video>`-ში სპეციალური ვიდეოების ჩადება და გაკონტროლება ხდება(იგი არის ლოკალური)."
    },
    "103": {
      "question": "შეიძლება თუ არა ჩვეულებრივი URL-ების გამოყენება iframe-ის `src` ატრიბუტში?",
      "options": [
        "არა, iframe-ს მხოლოდ ლოკალური ფაილი სჭირდება.",
        "არა, ბევრი საიტი ბლოკავს პირდაპირ ჩანერგვას და მოითხოვს სპეციალური ჩასმის URL-ებს.",
        "დიახ, iframe-ში ნებისმიერი ვალიდური URL-ის ჩასმაა შესაძლებელი.",
        "კი, მაგრამ მხოლოდ იმ შემთხვევაში, თუ ეს ვიდეო ფაილია"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "არა, ბევრი საიტი ბლოკავს პირდაპირ ჩანერგვას და მოითხოვს სპეციალური ჩასმის URL-ებს.",
      "explanation": "მიუხედავად იმისა, რომ iframe-ები ტექნიკურად იღებენ ნებისმიერ URL-ს, საიტების უმეტესობა (მაგალითად, YouTube-ი) ბლოკავს პირდაპირ ჩანერგვას უსაფრთხოების მიზნით. ამის ნაცვლად, პლატფორმები უზრუნველყოფენ სპეციალურ ჩანერგვის ბმულებს (მაგ.src='https://www.youtube.com/embed/{...}?start=0', YouTube-ი იყენებს `/embed/` URL), ჩანერგილი ბმულები iframe-ებში მუშაობენ."
    },
    "104": {
      "question": "მისაღებია თუ არა სხვისი ვიდეოს გამოყენება თქვენს პროექტში?",
      "options": [
        "მხოლოდ იმ შემთხვევაში, თუ ვიდეოს ჩამოტვირთავთ და ხელახლა ატვირთავთ",
        "დიახ, ყველა ვიდეოს გამოყენება ნებადართულია",
        "არა, ვიდეოების გამოყენება არაა მისაღები.",
        "დიახ, თუმცა უნდა დავიცვათ საავტორო უფლებებს."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "დიახ, თუმცა უნდა დავიცვათ საავტორო უფლებებს.",
      "explanation": "ჩვენ უნდა დავიცვათ საავტორო უფლებები. ზოგი ვიდეო ჩამოტვირთვის ან ხელახლა გამოყენების საშუალებას იძლევა, თუმცა ბევრი მათგანი ნებართვას ან შესაბამის ლიცენზიას მოითხოვენ."
    },
    "105": {
      "question": "თანამედროვე რეაქტის პროექტებში, რატომ ვამჯობინებთ ფუნქციონალურ JSX-ური კომპონენტების გამოყენებას კლასებისა და მემკვიდრეობის გამოყენებას?",
      "options": [
        "hook-ების ფუნქციები ბევრად მარტივია გამოსაყენებლად, ბევრ ფაილთან მუშაობისას.",
        "კლასების გამოყენება აკრძალულია რეაქტში.",
        "კლასები მხარს არ უჭერენ JSX ფაილებს.",
        "იმპორტ/ექსპორტი მხოლოდ JSX-ურ ფაილის ფუნქციებთან მუშაობენ."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "hook-ების ფუნქციები ბევრად მარტივია გამოსაყენებლად, ბევრ ფაილთან მუშაობისას.",
      "explanation": "კლასის კომპონენტები ძველ რეაქტში გამოიყენებოდა, თანამედროვე რეაქტში ფუნქციური კომპონენტები უფრო სუფთაა, უფრო ადვილი შესასწავლი და უფრო მრავალჯერადი გამოყენებისთვისაა გათვლილი, სწორედ ამიტომ ანიჭებს უპირატესობას მას თანამედროვე რეაქტი."
    },
    "106": {
      "question": "i18n-ი მხარს უჭერს ბევრენოვან სისტემას აპლიკაციაში. თუმცა ჩამოთვლილთაგან, რომელია ასევე პოპულარული ბიბლიოთეკა რომელიც უჭერს მხარს მულტი ენოვან ვებგვერდების შექმნას?",
      "options": [
        "react-i18next",
        "moment.js",
        "redux",
        "framer-motion"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "react-i18next",
      "explanation": "react-i18next არის ფართოდ გამოყენებული ბიბლიოთეკა, რომელიც აერთიანებს i18next-ს აპლიკაციებში მრავალენოვანი მხარდაჭერისთვის, ისევე როგორც i18n ეხმარება თარგმანებსა და ენის შეცვლას."
    },
    "107": {
      "question": "თუ თავს კარგად ართმევ localStorage-თან მუშაობას, ნიშნავს თუ არა ეს რომ შენ გესმის backend-ის შესახებ?",
      "options": [
        "დიახ, localStorage არის ბექენდ მონაცემთა ბაზა",
        "არა, localStorage არის მხოლოდ კლიენტის მხარე.",
        "დიახ, რადგან ის სერვერის მსგავსად ინახავს მუდმივ მონაცემებს",
        "არა, ბექენდი დიზაინის ნიმუშებს ეხება და არა შენახვებს."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "არა, localStorage არის მხოლოდ კლიენტის მხარე.",
      "explanation": "LocalStorage მონაცემებს მხოლოდ მომხმარებლის ბრაუზერში ინახავს. Backend-ი კი წარმოადგენს სერვერებს, მონაცემთა ბაზებს და API-ის, რაც გამოყოფილია localStorage-ისგან."
    },
    "108": {
      "question": "რა მთავარი განსხვავებაა GitHub-სა და Vercel-ს შორის, პროექტის ატვირთვისას?",
      "options": [
        "GitHub მასპინძლობს კოდის საცავებს, ხოლო Vercel მასპინძლობს რეალურ ვებ აპლიკაციებს.",
        "GitHub ავტომატურად განათავსებს თქვენს საიტს ბრაუზერში, Vercel-ს ეს არ შეუძლია.",
        "Vercel მხოლოდ კოდს ინახავს, ​​პროექტებს კი GitHub-ი მართავს.",
        "GitHub-ს შეუძლია ამუშავოს backend სერვერები, Vercel-ს ეს არ შეუძლია."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "GitHub მასპინძლობს კოდის საცავებს, ხოლო Vercel მასპინძლობს რეალურ ვებ აპლიკაციებს.",
      "explanation": "GitHub ძირითადად კოდის შესანახად და გასაზიარებლადაა განკუთვნილი. ხოლო Vercel-ი განათავსებს თქვენს პროექტს ისე, რომ მისი გაშვება ბრაუზერში შესაძლებელი იყოს, ცოცხალი URL-ებით."
    },
    "109": {
      "question": "შეგვიძლია თუ არა React-ში, რომ useState-ს საწყის მნიშვნელობად პირდაპირ გადავცეთ Custom hook-ი?",
      "options": [
        "დიახ, შეგგვიძლია ნებისმიერი Hook-ი გადავცეთ საწყის მნიშვნელობად.",
        "არა, useState-ს არ შეუძლია Custom hook-ის მიღება.",
        "მხოლოდ იმ შემთხვევაში, თუ მორგებული კაუჭი აბრუნებს რიცხვს ან სტრიქონს.",
        "კი, მაგრამ მხოლოდ კლასის კომპონენტებისთვის"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "არა, useState-ს არ შეუძლია Custom hook-ის მიღება",
      "explanation": "useState-ის მსგავს ჰუკებს შეუძლიათ შეინახონ საწყის მონაცემად: String, Number, Boolean ტიპები, თუმცა მას არ შეუძლია მიიღოს სხვა custom hook-ი როგორც საწყისი ცვლადი. Hook-ები გამოიყენება კოდის ზედა ნაწილში ან სხვა ჰუკებში."
    },
    "110": {
      "question": "რას წარმოადგენს <svg> ტეგი HTML-ში?",
      "options": [
        "მასშტაბირებადი ვექტორული გრაფიკის კონტეინერი",
        "ბიტმაპ სურათების ჩვენების გზა",
        "სპეციალური CSS სტილის ბლოკი",
        "JavaScript ანიმაციის ელემენტი"
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "მასშტაბირებადი ვექტორული გრაფიკის კონტეინერი.",
      "explanation": "<svg> ტეგი განსაზღვრავს SVG გრაფიკის კონტეინერს, რომელიც ვექტორზეა დაფუძნებული, ანუ მასშტაბირება შესაძლებელია ხარისხის დაკარგვის გარეშე."
    },
    "111": {
      "question": "სად არის SVG-ის გამოყენება განსაკუთრებით სასარგებლო, ჩვეულებრივ სურათებთან შედარებით?",
      "options": [
        "დიდი ფონური ფოტოებისთვის.",
        "ლოგოებისთვის, ხატულებისთვის და მარტივი ილუსტრაციებისთვის, რომლებიც მასშტაბირებას საჭიროებენ.",
        "ვიდეოებში, ფორმებში და მსგავს ადგილებში.",
        "შრიფტის ფაილებისთვის."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "ლოგოებისთვის, ხატულებისთვის და მარტივი ილუსტრაციებისთვის, რომლებიც მასშტაბირებას საჭიროებს.",
      "explanation": "SVG ტეგი ვექტორულ ფორმატებზეა დაფუძნებული, ამიტომ ის იდეალურად მასშტაბირდება ნებისმიერი გარჩევადობით, რაც მას იდეალურს ხდის ლოგოებისთვის, icon-ებისთვის და მარტივი ილუსტრაციებისთვისაც."
    },
    "112": {
      "question": "შეგვიძლია თუ არა უნიკალური icon-ის შექმნა, <svg> ტეგის გამოყენებით?",
      "options": [
        "დიახ, path-ების, ფორმების და ფერების კომბინაციით.",
        "არა, SVG-ს მხოლოდ წინასწარ დამზადებული სურათების გამოტანა შეუძლია.",
        "მხოლოდ იმ შემთხვევაში თუ ჩვენ მას PNG კოვნერტაციას გავუკეთებთ.",
        "არა, რადგან SVG არის მხოლოდ დეკორაციებისთვის."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "დიახ, path-ების, ფორმების და ფერების კომბინაციით.",
      "explanation": "SVG-ების აწყობა შესაძლებელია ნულიდან, ძირითადი ფორმების გამოყენებით, path-ებითა და სტილებით, რაც შესაძლებობას მოგვცემს შევქმნათ სრულიად უნიკალური icon-ები, ზედმეტი სურათის ჩამოტვირთვის გარეშე."
    },
    "113": {
      "question": "როგორ შეგვიძლია გამოვიყენოთ ჩასმული SVG-ტეგი, React პროექტში?",
      "options": [
        "პირდაპირ, როგორც JSX <svg> თეგი, ბილიკებით/ფორმებით.",
        "მხოლოდ <img> თეგის სახით.",
        "მხოლოდ გარე ფაილებში.",
        "SVG-ების გამოყენება React-ში შეუძლებელია."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "პირდაპირ, როგორც JSX <svg> თეგი, ბილიკებით/ფორმებით.",
      "explanation": "React-ში SVG-ების გამოყენების ყველაზე გავრცელებული გზაა JSX-ში ჩასმა, <svg> და <path>/<circle>/<rect> ელემენტებით, რაც სრული სტილისა და მანიპულირების საშუალებას იძლევა props-ის ან CSS-ის საშუალებით."
    },
    "114": {
      "question": "ჩამოთვლილთაგან, რომელ ადგილას გამოიყენება SVG ტეგი ყველაზე ხშირად?",
      "options": [
        "ვებსაიტის ლოგოებში, ხატულებში, ილუსტრაციებში, დიაგრამებსა და ანიმაციებში.",
        "სრულმეტრაჟიან ფილმებში და აუდიო ფაილებში.",
        "იგი არ გამოიყენება front-end-ის მიმართულებით.",
        "მონაცემთა ბაზების მეხსიერებაში."
      ],
      "level": "<medium>საშუალო</medium>",
      "correct": "Website logos, icons, illustrations, charts, and animations",
      "explanation": "SVG-ები ფართოდ გამოიყენება ვებ-პროგრამირებაში, მასშტაბირებადი ვიზუალური ელემენტებისთვის, როგორიცაა ლოგოები, ხატულები, ინტერაქტიული დიაგრამები და მცირე ანიმაციებიც კი."
    },
    "115": {
      "question": "React-ში 1000-ზე მეტი ერთეულისგან შემდგარი დიდი სია გაქვთ. ერთდროულად ყველაფრის რენდერინგი შესრულების პრობლემებს იწვევს. რა არის რენდერინგის ოპტიმიზაციის საუკეთესო მიდგომა?",
      "options": [
        "ყველა ელემენტის ნორმალურად რენდერირება; React ავტომატურად აკონტროლებს შესრულებას",
        "გვერდების დაყოფა ან ვირტუალიზებული სიები, როგორიცაა react-window ან react-virtualized.",
        "სიის <div>-ში მოთავსებით და overflow: hidden-ის მითითებით.",
        "setTimeout-მეთოდის გამოყენებით, რომ მოხდეს რენდერინგის დაყოვნება სიებისთვის."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "გვერდების დაყოფა ან ვირტუალიზებული სიები, როგორიცაა react-window ან react-virtualized.",
      "explanation": "ათასობით ერთეულის ერთდროულად რენდერინგმა შეიძლება მომხმარებლის ინტერფეისი გაყინოს. ვირტუალიზებული სიების ან გვერდების დახარისხების გამოყენება მხოლოდ ხილულ ელემენტებს არენდერირებს, რაც მნიშვნელოვნად აუმჯობესებს React აპლიკაციების მუშაობას."
    },
    "116": {
      "question": "ტაილვინდში, რა არის ბეჭედი(ring)?",
      "options": [
        "border-ის მეთოდი რომელიც აკონტროლებს ღობის სისქეს.",
        "მეთოდი, რომელიც ელემენტის გარშემო კონტურის მსგავს უჯრის ჩრდილს ამატებს.",
        "ჩაშენებული გრადიენტის ფონის სტილი.",
        "მომრგვალებული კუთხეების შევსების მეთოდი."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "მეთოდი, რომელიც ელემენტის გარშემო კონტურის მსგავს უჯრის ჩრდილს ამატებს.",
      "explanation": "Tailwind-ის border-ის მსგავსად, `ring` ქმნის კონტურის ეფექტს box-shadow-ის გამოყენებით. თუმცა ის საზღვრის გარეთ იქმნება(border-ისგან განსხვავებით), რაც მას ფოკუსირების მდგომარეობებისთვის სასარგებლოს ხდის."
    },
    "117": {
      "question": "ტაილვინდში, რა განსხვავებაა Border-სა და Ring-ს შორის?",
      "options": [
        "საზღვარი გამოიყენება ელემენტის ველის შიგნით, რგოლი კი გარეთ.",
        "საზღვარი ყოველთვის უფრო სქელია, ვიდრე რგოლი.",
        "ბეჭედი მთლიანად ანაცვლებს საზღვარს.",
        "საზღვარი გამოიყენება ელემენტის ველის გარეთ, რგოლი კი შიგნით."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "საზღვარი გამოიყენება ელემენტის ველის შიგნით, რგოლი კი გარეთ.",
      "explanation": "border ელემენტი ყუთის მოდელში იკავებს ადგილს, ხოლო ბეჭედი(ring) ემატება box-shadow-ს გამოყენებით, ამიტომ ის გარეთ ჩანს და განლაგებაზე გავლენას არ ახდენს."
    },
    "118": {
      "question": "თუ ერთ ელემენტზე გამოვიყენებთ border&ring-ს, რომელი აღმოჩნდება შიდა წრეში, რომელი - გარე წრეში?",
      "options": [
        "რგოლი ელემენტის შიგნითაა, საზღვარი კი მის გარეთ.",
        "რგოლი ელემენტის გარეთაა, საზღვარი კი მის შიგნით.",
        "ისინი შემთხვევითობის პრინციპით ფარავენ ერთმანეთს.",
        "ეს Tailwind-ის თემის კონფიგურაციაზეა დამოკიდებული."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "რგოლი ელემენტის გარეთაა, საზღვარი კი მის შიგნით.",
      "explanation": "საზღვარი(border) განთავსებულია ელემენტის ყუთის ნაწილად, ხოლო ბეჭედი გარე კონტურის სახით არის რენდერირებული box-shadow-ის მეშვეობით, ანუ საზღვარი(border) შიდაა და რგოლი მას(მოცემულ ელემენტს) გარს აკრავს."
    },
    "119": {
      "question": "როგორ ისტილება ბეჭედი(ring), ტაილვინდში?",
      "options": [
        "ისეთი მეთოდების გამოყენებით, როგორიცაა: ring-{color}, ring-{size} და ring-offset",
        "მხოლოდ სპეციალური CSS-ის დაწერით",
        "სასაზღვრო ელემენტის შეცვლით.",
        "Tailwind-ში ბეჭდების გასტილვა დაუშვებელია."
      ],
      "level": "<hard>რთული</hard>",
      "correct": "ისეთი მეთოდების გამოყენებით, როგორიცაა: ring-{color}, ring-{size} და ring-offset",
      "explanation": "Tailwind-ი გვთავაზობს ისეთ პროგრამულ მეთდს, როგორიცაა `ring-2`, `ring-blue-500` და `ring-offset-2` ზომის, ფერის და დაშორების პერსონალიზაციისთვის, CSS-ის გამოყენების გარეშე."
    },
    "120": {
      "question": "რა იქნება შედეგი: console.log([] * {} + 12);",
      "options": [
        "12",
        "NaN12",
        "NaN",
        "undefined12"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "NaN",
      "explanation": "`[] * {}` მოქმედება ცდილობს ორივე ოპერანდის number ტიპად კონვერტაციას. `[]` გარდაიქმნება 0-ად, `{}`-კი NaN, ამიტომ გამრავლების შედეგი იქნება - NaN, NaN-ზე 12-ის დამატება არაფერს არ ცვლის."
    },
    "121": {
      "question": "რა იქნება შედეგი: console.log('12' + 12 + [12]);",
      "options": [
        "24",
        "'121212'",
        "'121212' (როგორც string-ი)",
        "'1212,12'"
      ],
      "level": "<hard>რთული</hard>",
      "correct": "'121212'",
      "explanation": "'12' + 12 შედეგად გვაძლევს ციფრისა და სტრინგის ნაზავს  → '1212'. შემდეგ დამატებული `[12]` `toString()`-ის გამოძახებას იწვევს მასივში, რაც გვაძლევს [12] → '12'-ს შედეგად. საბოლოოდ მივიღებთ: '121212'."
    }
  },
  "lastSec": {
    "heading": "პროექტის მიღმა",
    "p1": "შეიტყვეთ მეტი შემქმნელის ასევე, პროექტის გზის შესახებ და გაეცანით ინტერაქტიულ განახლებებს.",
    "creator": "შემქმნელი",
    "creator2": "ლუკა ქართველიშვილი",
    "role": "უმცროსი ფრონტ-ენდ დეველოპერი",
    "age": "ასაკი:",
    "box2": "სამომავლო გეგმები",
    "ul": {
      "li1": "მომხმარებლის ანგარიშის სისტემა",
      "li2": "უფრო მეტი ქვიზები (Back-end, Tailwind, TypeScript...)",
      "li3": "სირთულეები & რეიტინგის დონეები",
      "li4": "ბევრენოვანი მხარდაჭერა",
      "li5": "კოდის პრაქტიკული ტესტები"
    },
    "box3": "დამხმარე წყაროები",
    "box3Nav": {
      "heropatterns": "გმირის ნიმუშები",
      "React icons": "რეაქტ ხატულა",
      "getwaves.io": "მიიღეთ ტალღები.io",
      "ChatGPT": "ChatGPT",
      "i18n": "i18n-ენის ამრჩევი"
    }
  },
  "about": {
    "header1": "რა არის CodeMeter?",
    "header2": "რატომ შევქმენით",
    "header3": "ჩვენი ხედვა",
    "purpose": "<highlight>CodeMeter</highlight> არის თანამედროვე, ინტერაქტიული ქვიზ პლატფორმა, რომელიც შეიქმნა  <highlight>ჯუნიორ დეველოპერების</highlight> დასახმარებლად, ცოდნის შესამოწმებლად და ფრონტ-ენდული უნარების გასაუმჯობესებლად. არაქვს მნიშვნელობა, ახლახან იწყებ თუ უკვე ღრმად ერკვევი React-ის ბაზაზე,  <highlight>CodeMeter </highlight> გამოწვევის წინაშე დაგაყენებს, ინტერაქტიული კითხვებით, როგორებიცაა: <normal>HTML, CSS, JavaScript, React</normal> — ასევე უნიკალური <strong>Random Logic</strong> ქვიზით, რომელიც დაგეხმარება აზროვნების გაძლიერებაში, მისი მოულოდნელი არაპროგნოზირებადი საკითხების მეშვეობით.",
    "reason": "პროგრამირების სწავლა მხოლოდ სინტაქსის დამახსოვრებას არ გულისხმობს — ის უფრო მკაფიო აზროვნებას, რეალური პრობლემების გადაჭრას და დამოუკიდებლად დებაგისა და შექმნის უნარის განვითარებას მოითხოვს. ჩვენ შევქმენით CodeMeter, რათა ეს გზა საინტერესო, სავსე გამოწვევებით და ცოტათი დამოკიდებულების გამომწვევიც ყოფილიყო.",
    "vision": "ჩვენი მოვალეობაა გავხდეთ სანდო რესურსი დეველოპერებისთვის, რომლებსაც სურთ გაიმყარონ თავიანთი აზროვნება, და ისინი ამას შეძლებენ კარგად დამუშავებული საკითხების წყალობით. ჩვენი პლატფორმა დაეხმარება დამწყებ დეველოპერებს მოემზადნონ სამუშაო გასაუბრებებზე, ასევე დაოსტატდნენ პროგრამირების ფუნდამენტებზე და შეძლონ სიღრმისეუად გაერკვნენ პროგრამირების ლოგიკაში რაც აძლიერებს კოდს - და არა მიყვენ მას ბრმად."
  },
  "contacts": {
    "header": "დაგვიკავშირდით",
    "subheader": "დაგვიკავშირდით ნებისმიერ დროს.",
    "location": "საქართველო, ქუთაისი",
    "formHeader": "პირადად შეტყობინება გირჩევნიათ?",
    "formName": "სახელი",
    "formEmail": "ელ. ფოსტა",
    "formMessage": "შეტყობინება",
    "submit": "გაგზავნა"
  },
  "resources": {
    "res": "რესურსები",
    "recommended": "რეკომენდირებული რესურსები",
    "p": "ეს რესურსები დაგეხმარებათ გააღრმაოთ თქვენი frontend-ული ცოდნა. ეს წყაროები <highlight>სანდო, მაღალ ხარისხოვანი</highlight> და <highlight>ხშირად განახლებადია</highlight>.",
    "title1": "MDN ვებ Doc-ები",
    "title2": "React ოფიციალური Doc-ები",
    "title3": "ჯავასკრიპტის ინფორმაცია",
    "title4": "Front-End მენტორი",
    "title5": "CSS ხრიკები",
    "description1": "HTML, CSS და JavaScript-ის ყოვლისმომცველი ცნობარი.",
    "description2": "შეიტყვეთ, თუ როგორ მუშაობს React პირდაპირ შემქმნელებისგან.",
    "description3": "JavaScript-ის მექანიკის სიღრმისეული სახელმძღვანელოები.",
    "description4": "ივარჯიშეთ რეალურ სამყაროში ფრონტ-ენდ გამოწვევებში და გააუმჯობესეთ თქვენი უნარები.",
    "description5": "სასარგებლო რჩევები, სტატიები და სახელმძღვანელოები CSS-ის მოყვარულთათვის."
  },
  "Rules": {
    "rules": "წესები",
    "heading": "ქვიზის წესები",
    "p": "სანამ დაიწყებდე, წაიკითხეთ მიმდინარე <highlight>6 მარტივი</highlight>, სამართლიანი და გლუვი წესი <strong>გამოცდილების უზრუნველსაყოფად</strong>.",
    "rule1": "თითო მცდელობა თითო კითხვაზე",
    "rule2": "არანაირი უკან დახევა",
    "rule3": "არანაირი მოტყუბები",
    "rule4": "იყავი სამართლიანი",
    "rule5": "გამოიყენეთ დესკტოპი ან პლანშეტი",
    "rule6": "მზად იყავი",
    "desc1": "თითო კითხვაზე მხოლოდ ერთი პასუხის არჩევა შეგიძლიათ. ამიტომ აირჩიეთ გონივრულად!",
    "desc2": "პასუხის წარდგენის შემდეგ, მისი შეცვლა აღარ შეგიძლიათ.",
    "desc3": "გთხოვთ, ტესტის შევსებისას პასუხების ძებნას თავი აარიდოთ. ენდეთ თქვენს ტვინს — თქვენი გამოცდილება მნიშვნელოვანია.",
    "desc4": "ეს პლატფორმა თვითგანვითარებისთვისაა შექმნილი. ეს პლატფორმა თვითგანვითარებისთვისაა შექმნილი. იყავით სამართლიანი - იყავით გულახდილი საკუთარი თავის მიმართ.",
    "desc5": "საუკეთესო გამოცდილებისთვის, გაიარეთ ტესტი უფრო დიდ ეკრანზე.",
    "desc6": "დაწყების ღილაკზე დაჭერის შემდეგ თქვენ მიიღებთ კითხვას, პასუხებს და დროს, რომელიც განსაზღვრავს, თუ რამდენი დრო დაგჭირდათ და საბოლოო ქულას, რომელიც აჩვენებს თქვენი ოსტატობის დონეს.",
    "start": "დაიწყე ქვიზი",
    "p2": "წესების დარღვევა ბრაუზერს არ დააზიანებს… თუმცა შეიძლება სახალისო მომენტები ჩაშალოს!"
  }
}